{
  "name": "gcp",
  "meta": {
    "moduleFormat": "(.*)(?:/[^/]*)"
  },
  "resources": {
    "gcp:accesscontextmanager/accessLevelCondition:AccessLevelCondition": {
      "description": "Allows configuring a single access level condition to be appended to an access level's conditions.\nThis resource is intended to be used in cases where it is not possible to compile a full list\nof conditions to include in a `gcp.accesscontextmanager.AccessLevel` resource,\nto enable them to be added separately.\n\n> **Note:** If this resource is used alongside a `gcp.accesscontextmanager.AccessLevel` resource,\nthe access level resource must have a `lifecycle` block with `ignore_changes = [basic[0].conditions]` so\nthey don't fight over which service accounts should be included.\n\n\nTo get more information about AccessLevelCondition, see:\n\n* [API documentation](https://cloud.google.com/access-context-manager/docs/reference/rest/v1/accessPolicies.accessLevels)\n* How-to Guides\n    * [Access Policy Quickstart](https://cloud.google.com/access-context-manager/docs/quickstart)\n\n> **Warning:** If you are using User ADCs (Application Default Credentials) with this resource,\nyou must specify a `billing_project` and set `user_project_override` to true\nin the provider configuration. Otherwise the ACM API will return a 403 error.\nYour account must have the `serviceusage.services.use` permission on the\n`billing_project` you defined.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Access Context Manager Access Level Condition Basic\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst access_policy = new gcp.accesscontextmanager.AccessPolicy(\"access-policy\", {\n    parent: \"organizations/123456789\",\n    title: \"my policy\",\n});\nconst access_level_service_account = new gcp.accesscontextmanager.AccessLevel(\"access-level-service-account\", {\n    parent: pulumi.interpolate`accessPolicies/${access_policy.name}`,\n    title: \"tf_test_chromeos_no_lock\",\n    basic: {\n        conditions: [{\n            devicePolicy: {\n                requireScreenLock: true,\n                osConstraints: [{\n                    osType: \"DESKTOP_CHROME_OS\",\n                }],\n            },\n            regions: [\n                \"CH\",\n                \"IT\",\n                \"US\",\n            ],\n        }],\n    },\n});\nconst created_later = new gcp.serviceaccount.Account(\"created-later\", {accountId: \"tf-test\"});\nconst access_level_conditions = new gcp.accesscontextmanager.AccessLevelCondition(\"access-level-conditions\", {\n    accessLevel: access_level_service_account.name,\n    ipSubnetworks: [\"192.0.4.0/24\"],\n    members: [\n        \"user:test@google.com\",\n        \"user:test2@google.com\",\n        pulumi.interpolate`serviceAccount:${created_later.email}`,\n    ],\n    negate: false,\n    devicePolicy: {\n        requireScreenLock: false,\n        requireAdminApproval: false,\n        requireCorpOwned: true,\n        osConstraints: [{\n            osType: \"DESKTOP_CHROME_OS\",\n        }],\n    },\n    regions: [\n        \"IT\",\n        \"US\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\naccess_policy = gcp.accesscontextmanager.AccessPolicy(\"access-policy\",\n    parent=\"organizations/123456789\",\n    title=\"my policy\")\naccess_level_service_account = gcp.accesscontextmanager.AccessLevel(\"access-level-service-account\",\n    parent=access_policy.name.apply(lambda name: f\"accessPolicies/{name}\"),\n    title=\"tf_test_chromeos_no_lock\",\n    basic=gcp.accesscontextmanager.AccessLevelBasicArgs(\n        conditions=[gcp.accesscontextmanager.AccessLevelBasicConditionArgs(\n            device_policy=gcp.accesscontextmanager.AccessLevelBasicConditionDevicePolicyArgs(\n                require_screen_lock=True,\n                os_constraints=[gcp.accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraintArgs(\n                    os_type=\"DESKTOP_CHROME_OS\",\n                )],\n            ),\n            regions=[\n                \"CH\",\n                \"IT\",\n                \"US\",\n            ],\n        )],\n    ))\ncreated_later = gcp.service_account.Account(\"created-later\", account_id=\"tf-test\")\naccess_level_conditions = gcp.accesscontextmanager.AccessLevelCondition(\"access-level-conditions\",\n    access_level=access_level_service_account.name,\n    ip_subnetworks=[\"192.0.4.0/24\"],\n    members=[\n        \"user:test@google.com\",\n        \"user:test2@google.com\",\n        created_later.email.apply(lambda email: f\"serviceAccount:{email}\"),\n    ],\n    negate=False,\n    device_policy=gcp.accesscontextmanager.AccessLevelConditionDevicePolicyArgs(\n        require_screen_lock=False,\n        require_admin_approval=False,\n        require_corp_owned=True,\n        os_constraints=[gcp.accesscontextmanager.AccessLevelConditionDevicePolicyOsConstraintArgs(\n            os_type=\"DESKTOP_CHROME_OS\",\n        )],\n    ),\n    regions=[\n        \"IT\",\n        \"US\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var access_policy = new Gcp.AccessContextManager.AccessPolicy(\"access-policy\", new()\n    {\n        Parent = \"organizations/123456789\",\n        Title = \"my policy\",\n    });\n\n    var access_level_service_account = new Gcp.AccessContextManager.AccessLevel(\"access-level-service-account\", new()\n    {\n        Parent = access_policy.Name.Apply(name => $\"accessPolicies/{name}\"),\n        Title = \"tf_test_chromeos_no_lock\",\n        Basic = new Gcp.AccessContextManager.Inputs.AccessLevelBasicArgs\n        {\n            Conditions = new[]\n            {\n                new Gcp.AccessContextManager.Inputs.AccessLevelBasicConditionArgs\n                {\n                    DevicePolicy = new Gcp.AccessContextManager.Inputs.AccessLevelBasicConditionDevicePolicyArgs\n                    {\n                        RequireScreenLock = true,\n                        OsConstraints = new[]\n                        {\n                            new Gcp.AccessContextManager.Inputs.AccessLevelBasicConditionDevicePolicyOsConstraintArgs\n                            {\n                                OsType = \"DESKTOP_CHROME_OS\",\n                            },\n                        },\n                    },\n                    Regions = new[]\n                    {\n                        \"CH\",\n                        \"IT\",\n                        \"US\",\n                    },\n                },\n            },\n        },\n    });\n\n    var created_later = new Gcp.ServiceAccount.Account(\"created-later\", new()\n    {\n        AccountId = \"tf-test\",\n    });\n\n    var access_level_conditions = new Gcp.AccessContextManager.AccessLevelCondition(\"access-level-conditions\", new()\n    {\n        AccessLevel = access_level_service_account.Name,\n        IpSubnetworks = new[]\n        {\n            \"192.0.4.0/24\",\n        },\n        Members = new[]\n        {\n            \"user:test@google.com\",\n            \"user:test2@google.com\",\n            created_later.Email.Apply(email => $\"serviceAccount:{email}\"),\n        },\n        Negate = false,\n        DevicePolicy = new Gcp.AccessContextManager.Inputs.AccessLevelConditionDevicePolicyArgs\n        {\n            RequireScreenLock = false,\n            RequireAdminApproval = false,\n            RequireCorpOwned = true,\n            OsConstraints = new[]\n            {\n                new Gcp.AccessContextManager.Inputs.AccessLevelConditionDevicePolicyOsConstraintArgs\n                {\n                    OsType = \"DESKTOP_CHROME_OS\",\n                },\n            },\n        },\n        Regions = new[]\n        {\n            \"IT\",\n            \"US\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/accesscontextmanager\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/serviceAccount\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := accesscontextmanager.NewAccessPolicy(ctx, \"access-policy\", &accesscontextmanager.AccessPolicyArgs{\n\t\t\tParent: pulumi.String(\"organizations/123456789\"),\n\t\t\tTitle:  pulumi.String(\"my policy\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = accesscontextmanager.NewAccessLevel(ctx, \"access-level-service-account\", &accesscontextmanager.AccessLevelArgs{\n\t\t\tParent: access_policy.Name.ApplyT(func(name string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"accessPolicies/%v\", name), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tTitle: pulumi.String(\"tf_test_chromeos_no_lock\"),\n\t\t\tBasic: &accesscontextmanager.AccessLevelBasicArgs{\n\t\t\t\tConditions: accesscontextmanager.AccessLevelBasicConditionArray{\n\t\t\t\t\t&accesscontextmanager.AccessLevelBasicConditionArgs{\n\t\t\t\t\t\tDevicePolicy: &accesscontextmanager.AccessLevelBasicConditionDevicePolicyArgs{\n\t\t\t\t\t\t\tRequireScreenLock: pulumi.Bool(true),\n\t\t\t\t\t\t\tOsConstraints: accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraintArray{\n\t\t\t\t\t\t\t\t&accesscontextmanager.AccessLevelBasicConditionDevicePolicyOsConstraintArgs{\n\t\t\t\t\t\t\t\t\tOsType: pulumi.String(\"DESKTOP_CHROME_OS\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRegions: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"CH\"),\n\t\t\t\t\t\t\tpulumi.String(\"IT\"),\n\t\t\t\t\t\t\tpulumi.String(\"US\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = serviceAccount.NewAccount(ctx, \"created-later\", &serviceAccount.AccountArgs{\n\t\t\tAccountId: pulumi.String(\"tf-test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = accesscontextmanager.NewAccessLevelCondition(ctx, \"access-level-conditions\", &accesscontextmanager.AccessLevelConditionArgs{\n\t\t\tAccessLevel: access_level_service_account.Name,\n\t\t\tIpSubnetworks: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.0.4.0/24\"),\n\t\t\t},\n\t\t\tMembers: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"user:test@google.com\"),\n\t\t\t\tpulumi.String(\"user:test2@google.com\"),\n\t\t\t\tcreated_later.Email.ApplyT(func(email string) (string, error) {\n\t\t\t\t\treturn fmt.Sprintf(\"serviceAccount:%v\", email), nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t\tNegate: pulumi.Bool(false),\n\t\t\tDevicePolicy: &accesscontextmanager.AccessLevelConditionDevicePolicyArgs{\n\t\t\t\tRequireScreenLock:    pulumi.Bool(false),\n\t\t\t\tRequireAdminApproval: pulumi.Bool(false),\n\t\t\t\tRequireCorpOwned:     pulumi.Bool(true),\n\t\t\t\tOsConstraints: accesscontextmanager.AccessLevelConditionDevicePolicyOsConstraintArray{\n\t\t\t\t\t&accesscontextmanager.AccessLevelConditionDevicePolicyOsConstraintArgs{\n\t\t\t\t\t\tOsType: pulumi.String(\"DESKTOP_CHROME_OS\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"IT\"),\n\t\t\t\tpulumi.String(\"US\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.accesscontextmanager.AccessPolicy;\nimport com.pulumi.gcp.accesscontextmanager.AccessPolicyArgs;\nimport com.pulumi.gcp.accesscontextmanager.AccessLevel;\nimport com.pulumi.gcp.accesscontextmanager.AccessLevelArgs;\nimport com.pulumi.gcp.accesscontextmanager.inputs.AccessLevelBasicArgs;\nimport com.pulumi.gcp.serviceAccount.Account;\nimport com.pulumi.gcp.serviceAccount.AccountArgs;\nimport com.pulumi.gcp.accesscontextmanager.AccessLevelCondition;\nimport com.pulumi.gcp.accesscontextmanager.AccessLevelConditionArgs;\nimport com.pulumi.gcp.accesscontextmanager.inputs.AccessLevelConditionDevicePolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var access_policy = new AccessPolicy(\"access-policy\", AccessPolicyArgs.builder()        \n            .parent(\"organizations/123456789\")\n            .title(\"my policy\")\n            .build());\n\n        var access_level_service_account = new AccessLevel(\"access-level-service-account\", AccessLevelArgs.builder()        \n            .parent(access_policy.name().applyValue(name -> String.format(\"accessPolicies/%s\", name)))\n            .title(\"tf_test_chromeos_no_lock\")\n            .basic(AccessLevelBasicArgs.builder()\n                .conditions(AccessLevelBasicConditionArgs.builder()\n                    .devicePolicy(AccessLevelBasicConditionDevicePolicyArgs.builder()\n                        .requireScreenLock(true)\n                        .osConstraints(AccessLevelBasicConditionDevicePolicyOsConstraintArgs.builder()\n                            .osType(\"DESKTOP_CHROME_OS\")\n                            .build())\n                        .build())\n                    .regions(                    \n                        \"CH\",\n                        \"IT\",\n                        \"US\")\n                    .build())\n                .build())\n            .build());\n\n        var created_later = new Account(\"created-later\", AccountArgs.builder()        \n            .accountId(\"tf-test\")\n            .build());\n\n        var access_level_conditions = new AccessLevelCondition(\"access-level-conditions\", AccessLevelConditionArgs.builder()        \n            .accessLevel(access_level_service_account.name())\n            .ipSubnetworks(\"192.0.4.0/24\")\n            .members(            \n                \"user:test@google.com\",\n                \"user:test2@google.com\",\n                created_later.email().applyValue(email -> String.format(\"serviceAccount:%s\", email)))\n            .negate(false)\n            .devicePolicy(AccessLevelConditionDevicePolicyArgs.builder()\n                .requireScreenLock(false)\n                .requireAdminApproval(false)\n                .requireCorpOwned(true)\n                .osConstraints(AccessLevelConditionDevicePolicyOsConstraintArgs.builder()\n                    .osType(\"DESKTOP_CHROME_OS\")\n                    .build())\n                .build())\n            .regions(            \n                \"IT\",\n                \"US\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  access-level-service-account:\n    type: gcp:accesscontextmanager:AccessLevel\n    properties:\n      parent: accessPolicies/${[\"access-policy\"].name}\n      title: tf_test_chromeos_no_lock\n      basic:\n        conditions:\n          - devicePolicy:\n              requireScreenLock: true\n              osConstraints:\n                - osType: DESKTOP_CHROME_OS\n            regions:\n              - CH\n              - IT\n              - US\n  created-later:\n    type: gcp:serviceAccount:Account\n    properties:\n      accountId: tf-test\n  access-level-conditions:\n    type: gcp:accesscontextmanager:AccessLevelCondition\n    properties:\n      accessLevel: ${[\"access-level-service-account\"].name}\n      ipSubnetworks:\n        - 192.0.4.0/24\n      members:\n        - user:test@google.com\n        - user:test2@google.com\n        - serviceAccount:${[\"created-later\"].email}\n      negate: false\n      devicePolicy:\n        requireScreenLock: false\n        requireAdminApproval: false\n        requireCorpOwned: true\n        osConstraints:\n          - osType: DESKTOP_CHROME_OS\n      regions:\n        - IT\n        - US\n  access-policy:\n    type: gcp:accesscontextmanager:AccessPolicy\n    properties:\n      parent: organizations/123456789\n      title: my policy\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource does not support import. ",
      "properties": {
        "accessLevel": {
          "type": "string",
          "description": "The name of the Access Level to add this condition to.\n"
        },
        "devicePolicy": {
          "$ref": "#/types/gcp:accesscontextmanager/AccessLevelConditionDevicePolicy:AccessLevelConditionDevicePolicy",
          "description": "Device specific restrictions, all restrictions must hold for\nthe Condition to be true. If not specified, all devices are\nallowed.\nStructure is documented below.\n"
        },
        "ipSubnetworks": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of CIDR block IP subnetwork specification. May be IPv4\nor IPv6.\nNote that for a CIDR IP address block, the specified IP address\nportion must be properly truncated (i.e. all the host bits must\nbe zero) or the input is considered malformed. For example,\n\"192.0.2.0/24\" is accepted but \"192.0.2.1/24\" is not. Similarly,\nfor IPv6, \"2001:db8::/32\" is accepted whereas \"2001:db8::1/32\"\nis not. The originating IP of a request must be in one of the\nlisted subnets in order for this Condition to be true.\nIf empty, all IP addresses are allowed.\n"
        },
        "members": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "An allowed list of members (users, service accounts).\nUsing groups is not supported yet.\nThe signed-in user originating the request must be a part of one\nof the provided members. If not specified, a request may come\nfrom any user (logged in/not logged in, not present in any\ngroups, etc.).\nFormats: `user:{emailid}`, `serviceAccount:{emailid}`\n"
        },
        "negate": {
          "type": "boolean",
          "description": "Whether to negate the Condition. If true, the Condition becomes\na NAND over its non-empty fields, each field must be false for\nthe Condition overall to be satisfied. Defaults to false.\n"
        },
        "regions": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The request must originate from one of the provided\ncountries/regions.\nFormat: A valid ISO 3166-1 alpha-2 code.\n"
        },
        "requiredAccessLevels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of other access levels defined in the same Policy,\nreferenced by resource name. Referencing an AccessLevel which\ndoes not exist is an error. All access levels listed must be\ngranted for the Condition to be true.\nFormat: accessPolicies/{policy_id}/accessLevels/{short_name}\n"
        }
      },
      "required": [
        "accessLevel"
      ],
      "inputProperties": {
        "accessLevel": {
          "type": "string",
          "description": "The name of the Access Level to add this condition to.\n",
          "willReplaceOnChanges": true
        },
        "devicePolicy": {
          "$ref": "#/types/gcp:accesscontextmanager/AccessLevelConditionDevicePolicy:AccessLevelConditionDevicePolicy",
          "willReplaceOnChanges": true,
          "description": "Device specific restrictions, all restrictions must hold for\nthe Condition to be true. If not specified, all devices are\nallowed.\nStructure is documented below.\n"
        },
        "ipSubnetworks": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "willReplaceOnChanges": true,
          "description": "A list of CIDR block IP subnetwork specification. May be IPv4\nor IPv6.\nNote that for a CIDR IP address block, the specified IP address\nportion must be properly truncated (i.e. all the host bits must\nbe zero) or the input is considered malformed. For example,\n\"192.0.2.0/24\" is accepted but \"192.0.2.1/24\" is not. Similarly,\nfor IPv6, \"2001:db8::/32\" is accepted whereas \"2001:db8::1/32\"\nis not. The originating IP of a request must be in one of the\nlisted subnets in order for this Condition to be true.\nIf empty, all IP addresses are allowed.\n"
        },
        "members": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "willReplaceOnChanges": true,
          "description": "An allowed list of members (users, service accounts).\nUsing groups is not supported yet.\nThe signed-in user originating the request must be a part of one\nof the provided members. If not specified, a request may come\nfrom any user (logged in/not logged in, not present in any\ngroups, etc.).\nFormats: `user:{emailid}`, `serviceAccount:{emailid}`\n"
        },
        "negate": {
          "type": "boolean",
          "description": "Whether to negate the Condition. If true, the Condition becomes\na NAND over its non-empty fields, each field must be false for\nthe Condition overall to be satisfied. Defaults to false.\n",
          "willReplaceOnChanges": true
        },
        "regions": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "willReplaceOnChanges": true,
          "description": "The request must originate from one of the provided\ncountries/regions.\nFormat: A valid ISO 3166-1 alpha-2 code.\n"
        },
        "requiredAccessLevels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "willReplaceOnChanges": true,
          "description": "A list of other access levels defined in the same Policy,\nreferenced by resource name. Referencing an AccessLevel which\ndoes not exist is an error. All access levels listed must be\ngranted for the Condition to be true.\nFormat: accessPolicies/{policy_id}/accessLevels/{short_name}\n"
        }
      },
      "requiredInputs": [
        "accessLevel"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering AccessLevelCondition resources.\n",
        "properties": {
          "accessLevel": {
            "type": "string",
            "description": "The name of the Access Level to add this condition to.\n",
            "willReplaceOnChanges": true
          },
          "devicePolicy": {
            "$ref": "#/types/gcp:accesscontextmanager/AccessLevelConditionDevicePolicy:AccessLevelConditionDevicePolicy",
            "description": "Device specific restrictions, all restrictions must hold for\nthe Condition to be true. If not specified, all devices are\nallowed.\nStructure is documented below.\n",
            "willReplaceOnChanges": true
          },
          "ipSubnetworks": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of CIDR block IP subnetwork specification. May be IPv4\nor IPv6.\nNote that for a CIDR IP address block, the specified IP address\nportion must be properly truncated (i.e. all the host bits must\nbe zero) or the input is considered malformed. For example,\n\"192.0.2.0/24\" is accepted but \"192.0.2.1/24\" is not. Similarly,\nfor IPv6, \"2001:db8::/32\" is accepted whereas \"2001:db8::1/32\"\nis not. The originating IP of a request must be in one of the\nlisted subnets in order for this Condition to be true.\nIf empty, all IP addresses are allowed.\n",
            "willReplaceOnChanges": true
          },
          "members": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "An allowed list of members (users, service accounts).\nUsing groups is not supported yet.\nThe signed-in user originating the request must be a part of one\nof the provided members. If not specified, a request may come\nfrom any user (logged in/not logged in, not present in any\ngroups, etc.).\nFormats: `user:{emailid}`, `serviceAccount:{emailid}`\n",
            "willReplaceOnChanges": true
          },
          "negate": {
            "type": "boolean",
            "description": "Whether to negate the Condition. If true, the Condition becomes\na NAND over its non-empty fields, each field must be false for\nthe Condition overall to be satisfied. Defaults to false.\n",
            "willReplaceOnChanges": true
          },
          "regions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The request must originate from one of the provided\ncountries/regions.\nFormat: A valid ISO 3166-1 alpha-2 code.\n",
            "willReplaceOnChanges": true
          },
          "requiredAccessLevels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of other access levels defined in the same Policy,\nreferenced by resource name. Referencing an AccessLevel which\ndoes not exist is an error. All access levels listed must be\ngranted for the Condition to be true.\nFormat: accessPolicies/{policy_id}/accessLevels/{short_name}\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:appengine/applicationUrlDispatchRules:ApplicationUrlDispatchRules": {
      "description": "Rules to match an HTTP request and dispatch that request to a service.\n\n\nTo get more information about ApplicationUrlDispatchRules, see:\n\n* [API documentation](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps#UrlDispatchRule)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### App Engine Application Url Dispatch Rules Basic\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst bucket = new gcp.storage.Bucket(\"bucket\", {location: \"US\"});\nconst object = new gcp.storage.BucketObject(\"object\", {\n    bucket: bucket.name,\n    source: new pulumi.asset.FileAsset(\"./test-fixtures/appengine/hello-world.zip\"),\n});\nconst adminV3 = new gcp.appengine.StandardAppVersion(\"adminV3\", {\n    versionId: \"v3\",\n    service: \"admin\",\n    runtime: \"nodejs10\",\n    entrypoint: {\n        shell: \"node ./app.js\",\n    },\n    deployment: {\n        zip: {\n            sourceUrl: pulumi.interpolate`https://storage.googleapis.com/${bucket.name}/${object.name}`,\n        },\n    },\n    envVariables: {\n        port: \"8080\",\n    },\n    noopOnDestroy: true,\n});\nconst webService = new gcp.appengine.ApplicationUrlDispatchRules(\"webService\", {dispatchRules: [\n    {\n        domain: \"*\",\n        path: \"/*\",\n        service: \"default\",\n    },\n    {\n        domain: \"*\",\n        path: \"/admin/*\",\n        service: adminV3.service,\n    },\n]});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nbucket = gcp.storage.Bucket(\"bucket\", location=\"US\")\nobject = gcp.storage.BucketObject(\"object\",\n    bucket=bucket.name,\n    source=pulumi.FileAsset(\"./test-fixtures/appengine/hello-world.zip\"))\nadmin_v3 = gcp.appengine.StandardAppVersion(\"adminV3\",\n    version_id=\"v3\",\n    service=\"admin\",\n    runtime=\"nodejs10\",\n    entrypoint=gcp.appengine.StandardAppVersionEntrypointArgs(\n        shell=\"node ./app.js\",\n    ),\n    deployment=gcp.appengine.StandardAppVersionDeploymentArgs(\n        zip=gcp.appengine.StandardAppVersionDeploymentZipArgs(\n            source_url=pulumi.Output.all(bucket.name, object.name).apply(lambda bucketName, objectName: f\"https://storage.googleapis.com/{bucket_name}/{object_name}\"),\n        ),\n    ),\n    env_variables={\n        \"port\": \"8080\",\n    },\n    noop_on_destroy=True)\nweb_service = gcp.appengine.ApplicationUrlDispatchRules(\"webService\", dispatch_rules=[\n    gcp.appengine.ApplicationUrlDispatchRulesDispatchRuleArgs(\n        domain=\"*\",\n        path=\"/*\",\n        service=\"default\",\n    ),\n    gcp.appengine.ApplicationUrlDispatchRulesDispatchRuleArgs(\n        domain=\"*\",\n        path=\"/admin/*\",\n        service=admin_v3.service,\n    ),\n])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var bucket = new Gcp.Storage.Bucket(\"bucket\", new()\n    {\n        Location = \"US\",\n    });\n\n    var @object = new Gcp.Storage.BucketObject(\"object\", new()\n    {\n        Bucket = bucket.Name,\n        Source = new FileAsset(\"./test-fixtures/appengine/hello-world.zip\"),\n    });\n\n    var adminV3 = new Gcp.AppEngine.StandardAppVersion(\"adminV3\", new()\n    {\n        VersionId = \"v3\",\n        Service = \"admin\",\n        Runtime = \"nodejs10\",\n        Entrypoint = new Gcp.AppEngine.Inputs.StandardAppVersionEntrypointArgs\n        {\n            Shell = \"node ./app.js\",\n        },\n        Deployment = new Gcp.AppEngine.Inputs.StandardAppVersionDeploymentArgs\n        {\n            Zip = new Gcp.AppEngine.Inputs.StandardAppVersionDeploymentZipArgs\n            {\n                SourceUrl = Output.Tuple(bucket.Name, @object.Name).Apply(values =>\n                {\n                    var bucketName = values.Item1;\n                    var objectName = values.Item2;\n                    return $\"https://storage.googleapis.com/{bucketName}/{objectName}\";\n                }),\n            },\n        },\n        EnvVariables = \n        {\n            { \"port\", \"8080\" },\n        },\n        NoopOnDestroy = true,\n    });\n\n    var webService = new Gcp.AppEngine.ApplicationUrlDispatchRules(\"webService\", new()\n    {\n        DispatchRules = new[]\n        {\n            new Gcp.AppEngine.Inputs.ApplicationUrlDispatchRulesDispatchRuleArgs\n            {\n                Domain = \"*\",\n                Path = \"/*\",\n                Service = \"default\",\n            },\n            new Gcp.AppEngine.Inputs.ApplicationUrlDispatchRulesDispatchRuleArgs\n            {\n                Domain = \"*\",\n                Path = \"/admin/*\",\n                Service = adminV3.Service,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/appengine\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/storage\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tbucket, err := storage.NewBucket(ctx, \"bucket\", &storage.BucketArgs{\n\t\t\tLocation: pulumi.String(\"US\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tobject, err := storage.NewBucketObject(ctx, \"object\", &storage.BucketObjectArgs{\n\t\t\tBucket: bucket.Name,\n\t\t\tSource: pulumi.NewFileAsset(\"./test-fixtures/appengine/hello-world.zip\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tadminV3, err := appengine.NewStandardAppVersion(ctx, \"adminV3\", &appengine.StandardAppVersionArgs{\n\t\t\tVersionId: pulumi.String(\"v3\"),\n\t\t\tService:   pulumi.String(\"admin\"),\n\t\t\tRuntime:   pulumi.String(\"nodejs10\"),\n\t\t\tEntrypoint: &appengine.StandardAppVersionEntrypointArgs{\n\t\t\t\tShell: pulumi.String(\"node ./app.js\"),\n\t\t\t},\n\t\t\tDeployment: &appengine.StandardAppVersionDeploymentArgs{\n\t\t\t\tZip: &appengine.StandardAppVersionDeploymentZipArgs{\n\t\t\t\t\tSourceUrl: pulumi.All(bucket.Name, object.Name).ApplyT(func(_args []interface{}) (string, error) {\n\t\t\t\t\t\tbucketName := _args[0].(string)\n\t\t\t\t\t\tobjectName := _args[1].(string)\n\t\t\t\t\t\treturn fmt.Sprintf(\"https://storage.googleapis.com/%v/%v\", bucketName, objectName), nil\n\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t},\n\t\t\t},\n\t\t\tEnvVariables: pulumi.StringMap{\n\t\t\t\t\"port\": pulumi.String(\"8080\"),\n\t\t\t},\n\t\t\tNoopOnDestroy: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = appengine.NewApplicationUrlDispatchRules(ctx, \"webService\", &appengine.ApplicationUrlDispatchRulesArgs{\n\t\t\tDispatchRules: appengine.ApplicationUrlDispatchRulesDispatchRuleArray{\n\t\t\t\t&appengine.ApplicationUrlDispatchRulesDispatchRuleArgs{\n\t\t\t\t\tDomain:  pulumi.String(\"*\"),\n\t\t\t\t\tPath:    pulumi.String(\"/*\"),\n\t\t\t\t\tService: pulumi.String(\"default\"),\n\t\t\t\t},\n\t\t\t\t&appengine.ApplicationUrlDispatchRulesDispatchRuleArgs{\n\t\t\t\t\tDomain:  pulumi.String(\"*\"),\n\t\t\t\t\tPath:    pulumi.String(\"/admin/*\"),\n\t\t\t\t\tService: adminV3.Service,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.storage.Bucket;\nimport com.pulumi.gcp.storage.BucketArgs;\nimport com.pulumi.gcp.storage.BucketObject;\nimport com.pulumi.gcp.storage.BucketObjectArgs;\nimport com.pulumi.gcp.appengine.StandardAppVersion;\nimport com.pulumi.gcp.appengine.StandardAppVersionArgs;\nimport com.pulumi.gcp.appengine.inputs.StandardAppVersionEntrypointArgs;\nimport com.pulumi.gcp.appengine.inputs.StandardAppVersionDeploymentArgs;\nimport com.pulumi.gcp.appengine.inputs.StandardAppVersionDeploymentZipArgs;\nimport com.pulumi.gcp.appengine.ApplicationUrlDispatchRules;\nimport com.pulumi.gcp.appengine.ApplicationUrlDispatchRulesArgs;\nimport com.pulumi.gcp.appengine.inputs.ApplicationUrlDispatchRulesDispatchRuleArgs;\nimport com.pulumi.asset.FileAsset;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var bucket = new Bucket(\"bucket\", BucketArgs.builder()        \n            .location(\"US\")\n            .build());\n\n        var object = new BucketObject(\"object\", BucketObjectArgs.builder()        \n            .bucket(bucket.name())\n            .source(new FileAsset(\"./test-fixtures/appengine/hello-world.zip\"))\n            .build());\n\n        var adminV3 = new StandardAppVersion(\"adminV3\", StandardAppVersionArgs.builder()        \n            .versionId(\"v3\")\n            .service(\"admin\")\n            .runtime(\"nodejs10\")\n            .entrypoint(StandardAppVersionEntrypointArgs.builder()\n                .shell(\"node ./app.js\")\n                .build())\n            .deployment(StandardAppVersionDeploymentArgs.builder()\n                .zip(StandardAppVersionDeploymentZipArgs.builder()\n                    .sourceUrl(Output.tuple(bucket.name(), object.name()).applyValue(values -> {\n                        var bucketName = values.t1;\n                        var objectName = values.t2;\n                        return String.format(\"https://storage.googleapis.com/%s/%s\", bucketName,objectName);\n                    }))\n                    .build())\n                .build())\n            .envVariables(Map.of(\"port\", \"8080\"))\n            .noopOnDestroy(true)\n            .build());\n\n        var webService = new ApplicationUrlDispatchRules(\"webService\", ApplicationUrlDispatchRulesArgs.builder()        \n            .dispatchRules(            \n                ApplicationUrlDispatchRulesDispatchRuleArgs.builder()\n                    .domain(\"*\")\n                    .path(\"/*\")\n                    .service(\"default\")\n                    .build(),\n                ApplicationUrlDispatchRulesDispatchRuleArgs.builder()\n                    .domain(\"*\")\n                    .path(\"/admin/*\")\n                    .service(adminV3.service())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  webService:\n    type: gcp:appengine:ApplicationUrlDispatchRules\n    properties:\n      dispatchRules:\n        - domain: '*'\n          path: /*\n          service: default\n        - domain: '*'\n          path: /admin/*\n          service: ${adminV3.service}\n  adminV3:\n    type: gcp:appengine:StandardAppVersion\n    properties:\n      versionId: v3\n      service: admin\n      runtime: nodejs10\n      entrypoint:\n        shell: node ./app.js\n      deployment:\n        zip:\n          sourceUrl: https://storage.googleapis.com/${bucket.name}/${object.name}\n      envVariables:\n        port: 8080\n      noopOnDestroy: true\n  bucket:\n    type: gcp:storage:Bucket\n    properties:\n      location: US\n  object:\n    type: gcp:storage:BucketObject\n    properties:\n      bucket: ${bucket.name}\n      source:\n        Fn::FileAsset: ./test-fixtures/appengine/hello-world.zip\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nApplicationUrlDispatchRules can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:appengine/applicationUrlDispatchRules:ApplicationUrlDispatchRules default {{project}}\n```\n\n ",
      "properties": {
        "dispatchRules": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:appengine/ApplicationUrlDispatchRulesDispatchRule:ApplicationUrlDispatchRulesDispatchRule"
          },
          "description": "Rules to match an HTTP request and dispatch that request to a service.\nStructure is documented below.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n"
        }
      },
      "required": [
        "dispatchRules",
        "project"
      ],
      "inputProperties": {
        "dispatchRules": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:appengine/ApplicationUrlDispatchRulesDispatchRule:ApplicationUrlDispatchRulesDispatchRule"
          },
          "description": "Rules to match an HTTP request and dispatch that request to a service.\nStructure is documented below.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "dispatchRules"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering ApplicationUrlDispatchRules resources.\n",
        "properties": {
          "dispatchRules": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:appengine/ApplicationUrlDispatchRulesDispatchRule:ApplicationUrlDispatchRulesDispatchRule"
            },
            "description": "Rules to match an HTTP request and dispatch that request to a service.\nStructure is documented below.\n"
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:assuredworkloads/workload:Workload": {
      "description": "The AssuredWorkloads Workload resource\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic_workload\nA basic test of a assuredworkloads api\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst primary = new gcp.assuredworkloads.Workload(\"primary\", {\n    billingAccount: \"billingAccounts/000000-0000000-0000000-000000\",\n    complianceRegime: \"FEDRAMP_MODERATE\",\n    displayName: \"Workload Example\",\n    kmsSettings: {\n        nextRotationTime: \"9999-10-02T15:01:23Z\",\n        rotationPeriod: \"10368000s\",\n    },\n    labels: {\n        \"label-one\": \"value-one\",\n    },\n    location: \"us-west1\",\n    organization: \"123456789\",\n    provisionedResourcesParent: \"folders/519620126891\",\n    resourceSettings: [\n        {\n            resourceType: \"CONSUMER_PROJECT\",\n        },\n        {\n            resourceType: \"ENCRYPTION_KEYS_PROJECT\",\n        },\n        {\n            resourceId: \"ring\",\n            resourceType: \"KEYRING\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nprimary = gcp.assuredworkloads.Workload(\"primary\",\n    billing_account=\"billingAccounts/000000-0000000-0000000-000000\",\n    compliance_regime=\"FEDRAMP_MODERATE\",\n    display_name=\"Workload Example\",\n    kms_settings=gcp.assuredworkloads.WorkloadKmsSettingsArgs(\n        next_rotation_time=\"9999-10-02T15:01:23Z\",\n        rotation_period=\"10368000s\",\n    ),\n    labels={\n        \"label-one\": \"value-one\",\n    },\n    location=\"us-west1\",\n    organization=\"123456789\",\n    provisioned_resources_parent=\"folders/519620126891\",\n    resource_settings=[\n        gcp.assuredworkloads.WorkloadResourceSettingArgs(\n            resource_type=\"CONSUMER_PROJECT\",\n        ),\n        gcp.assuredworkloads.WorkloadResourceSettingArgs(\n            resource_type=\"ENCRYPTION_KEYS_PROJECT\",\n        ),\n        gcp.assuredworkloads.WorkloadResourceSettingArgs(\n            resource_id=\"ring\",\n            resource_type=\"KEYRING\",\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var primary = new Gcp.AssuredWorkloads.Workload(\"primary\", new()\n    {\n        BillingAccount = \"billingAccounts/000000-0000000-0000000-000000\",\n        ComplianceRegime = \"FEDRAMP_MODERATE\",\n        DisplayName = \"Workload Example\",\n        KmsSettings = new Gcp.AssuredWorkloads.Inputs.WorkloadKmsSettingsArgs\n        {\n            NextRotationTime = \"9999-10-02T15:01:23Z\",\n            RotationPeriod = \"10368000s\",\n        },\n        Labels = \n        {\n            { \"label-one\", \"value-one\" },\n        },\n        Location = \"us-west1\",\n        Organization = \"123456789\",\n        ProvisionedResourcesParent = \"folders/519620126891\",\n        ResourceSettings = new[]\n        {\n            new Gcp.AssuredWorkloads.Inputs.WorkloadResourceSettingArgs\n            {\n                ResourceType = \"CONSUMER_PROJECT\",\n            },\n            new Gcp.AssuredWorkloads.Inputs.WorkloadResourceSettingArgs\n            {\n                ResourceType = \"ENCRYPTION_KEYS_PROJECT\",\n            },\n            new Gcp.AssuredWorkloads.Inputs.WorkloadResourceSettingArgs\n            {\n                ResourceId = \"ring\",\n                ResourceType = \"KEYRING\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/assuredworkloads\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := assuredworkloads.NewWorkload(ctx, \"primary\", &assuredworkloads.WorkloadArgs{\n\t\t\tBillingAccount:   pulumi.String(\"billingAccounts/000000-0000000-0000000-000000\"),\n\t\t\tComplianceRegime: pulumi.String(\"FEDRAMP_MODERATE\"),\n\t\t\tDisplayName:      pulumi.String(\"Workload Example\"),\n\t\t\tKmsSettings: &assuredworkloads.WorkloadKmsSettingsArgs{\n\t\t\t\tNextRotationTime: pulumi.String(\"9999-10-02T15:01:23Z\"),\n\t\t\t\tRotationPeriod:   pulumi.String(\"10368000s\"),\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"label-one\": pulumi.String(\"value-one\"),\n\t\t\t},\n\t\t\tLocation:                   pulumi.String(\"us-west1\"),\n\t\t\tOrganization:               pulumi.String(\"123456789\"),\n\t\t\tProvisionedResourcesParent: pulumi.String(\"folders/519620126891\"),\n\t\t\tResourceSettings: assuredworkloads.WorkloadResourceSettingArray{\n\t\t\t\t&assuredworkloads.WorkloadResourceSettingArgs{\n\t\t\t\t\tResourceType: pulumi.String(\"CONSUMER_PROJECT\"),\n\t\t\t\t},\n\t\t\t\t&assuredworkloads.WorkloadResourceSettingArgs{\n\t\t\t\t\tResourceType: pulumi.String(\"ENCRYPTION_KEYS_PROJECT\"),\n\t\t\t\t},\n\t\t\t\t&assuredworkloads.WorkloadResourceSettingArgs{\n\t\t\t\t\tResourceId:   pulumi.String(\"ring\"),\n\t\t\t\t\tResourceType: pulumi.String(\"KEYRING\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.assuredworkloads.Workload;\nimport com.pulumi.gcp.assuredworkloads.WorkloadArgs;\nimport com.pulumi.gcp.assuredworkloads.inputs.WorkloadKmsSettingsArgs;\nimport com.pulumi.gcp.assuredworkloads.inputs.WorkloadResourceSettingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var primary = new Workload(\"primary\", WorkloadArgs.builder()        \n            .billingAccount(\"billingAccounts/000000-0000000-0000000-000000\")\n            .complianceRegime(\"FEDRAMP_MODERATE\")\n            .displayName(\"Workload Example\")\n            .kmsSettings(WorkloadKmsSettingsArgs.builder()\n                .nextRotationTime(\"9999-10-02T15:01:23Z\")\n                .rotationPeriod(\"10368000s\")\n                .build())\n            .labels(Map.of(\"label-one\", \"value-one\"))\n            .location(\"us-west1\")\n            .organization(\"123456789\")\n            .provisionedResourcesParent(\"folders/519620126891\")\n            .resourceSettings(            \n                WorkloadResourceSettingArgs.builder()\n                    .resourceType(\"CONSUMER_PROJECT\")\n                    .build(),\n                WorkloadResourceSettingArgs.builder()\n                    .resourceType(\"ENCRYPTION_KEYS_PROJECT\")\n                    .build(),\n                WorkloadResourceSettingArgs.builder()\n                    .resourceId(\"ring\")\n                    .resourceType(\"KEYRING\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  primary:\n    type: gcp:assuredworkloads:Workload\n    properties:\n      billingAccount: billingAccounts/000000-0000000-0000000-000000\n      complianceRegime: FEDRAMP_MODERATE\n      displayName: Workload Example\n      kmsSettings:\n        nextRotationTime: 9999-10-02T15:01:23Z\n        rotationPeriod: 10368000s\n      labels:\n        label-one: value-one\n      location: us-west1\n      organization: 123456789\n      provisionedResourcesParent: folders/519620126891\n      resourceSettings:\n        - resourceType: CONSUMER_PROJECT\n        - resourceType: ENCRYPTION_KEYS_PROJECT\n        - resourceId: ring\n          resourceType: KEYRING\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nWorkload can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:assuredworkloads/workload:Workload default organizations/{{organization}}/locations/{{location}}/workloads/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:assuredworkloads/workload:Workload default {{organization}}/{{location}}/{{name}}\n```\n\n ",
      "properties": {
        "billingAccount": {
          "type": "string",
          "description": "Required. Input only. The billing account used for the resources which are direct children of workload. This billing account is initially associated with the resources created as part of Workload creation. After the initial creation of these resources, the customer can change the assigned billing account. The resource name has the form `billingAccounts/{billing_account_id}`. For example, 'billingAccounts/012345-567890-ABCDEF`.\n"
        },
        "complianceRegime": {
          "type": "string",
          "description": "Required. Immutable. Compliance Regime associated with this workload. Possible values: COMPLIANCE_REGIME_UNSPECIFIED, IL4, CJIS, FEDRAMP_HIGH, FEDRAMP_MODERATE, US_REGIONAL_ACCESS\n"
        },
        "createTime": {
          "type": "string",
          "description": "Output only. Immutable. The Workload creation timestamp.\n"
        },
        "displayName": {
          "type": "string",
          "description": "Required. The user-assigned display name of the Workload. When present it must be between 4 to 30 characters. Allowed characters are: lowercase and uppercase letters, numbers, hyphen, and spaces. Example: My Workload\n"
        },
        "kmsSettings": {
          "$ref": "#/types/gcp:assuredworkloads/WorkloadKmsSettings:WorkloadKmsSettings",
          "description": "Input only. Settings used to create a CMEK crypto key. When set a project with a KMS CMEK key is provisioned. This field is mandatory for a subset of Compliance Regimes.\n"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. Labels applied to the workload.\n"
        },
        "location": {
          "type": "string",
          "description": "The location for the resource\n"
        },
        "name": {
          "type": "string",
          "description": "Output only. The resource name of the workload.\n"
        },
        "organization": {
          "type": "string",
          "description": "The organization for the resource\n"
        },
        "provisionedResourcesParent": {
          "type": "string",
          "description": "Input only. The parent resource for the resources managed by this Assured Workload. May be either an organization or a folder. Must be the same or a child of the Workload parent. If not specified all resources are created under the Workload parent. Formats: folders/{folder_id}, organizations/{organization_id}\n"
        },
        "resourceSettings": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:assuredworkloads/WorkloadResourceSetting:WorkloadResourceSetting"
          },
          "description": "Input only. Resource properties that are used to customize workload resources. These properties (such as custom project id) will be used to create workload resources if possible. This field is optional.\n"
        },
        "resources": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:assuredworkloads/WorkloadResource:WorkloadResource"
          },
          "description": "Output only. The resources associated with this workload. These resources will be created when creating the workload. If\nany of the projects already exist, the workload creation will fail. Always read only.\n"
        }
      },
      "required": [
        "billingAccount",
        "complianceRegime",
        "createTime",
        "displayName",
        "location",
        "name",
        "organization",
        "resources"
      ],
      "inputProperties": {
        "billingAccount": {
          "type": "string",
          "description": "Required. Input only. The billing account used for the resources which are direct children of workload. This billing account is initially associated with the resources created as part of Workload creation. After the initial creation of these resources, the customer can change the assigned billing account. The resource name has the form `billingAccounts/{billing_account_id}`. For example, 'billingAccounts/012345-567890-ABCDEF`.\n",
          "willReplaceOnChanges": true
        },
        "complianceRegime": {
          "type": "string",
          "description": "Required. Immutable. Compliance Regime associated with this workload. Possible values: COMPLIANCE_REGIME_UNSPECIFIED, IL4, CJIS, FEDRAMP_HIGH, FEDRAMP_MODERATE, US_REGIONAL_ACCESS\n",
          "willReplaceOnChanges": true
        },
        "displayName": {
          "type": "string",
          "description": "Required. The user-assigned display name of the Workload. When present it must be between 4 to 30 characters. Allowed characters are: lowercase and uppercase letters, numbers, hyphen, and spaces. Example: My Workload\n"
        },
        "kmsSettings": {
          "$ref": "#/types/gcp:assuredworkloads/WorkloadKmsSettings:WorkloadKmsSettings",
          "willReplaceOnChanges": true,
          "description": "Input only. Settings used to create a CMEK crypto key. When set a project with a KMS CMEK key is provisioned. This field is mandatory for a subset of Compliance Regimes.\n"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. Labels applied to the workload.\n"
        },
        "location": {
          "type": "string",
          "description": "The location for the resource\n",
          "willReplaceOnChanges": true
        },
        "organization": {
          "type": "string",
          "description": "The organization for the resource\n",
          "willReplaceOnChanges": true
        },
        "provisionedResourcesParent": {
          "type": "string",
          "description": "Input only. The parent resource for the resources managed by this Assured Workload. May be either an organization or a folder. Must be the same or a child of the Workload parent. If not specified all resources are created under the Workload parent. Formats: folders/{folder_id}, organizations/{organization_id}\n",
          "willReplaceOnChanges": true
        },
        "resourceSettings": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:assuredworkloads/WorkloadResourceSetting:WorkloadResourceSetting"
          },
          "willReplaceOnChanges": true,
          "description": "Input only. Resource properties that are used to customize workload resources. These properties (such as custom project id) will be used to create workload resources if possible. This field is optional.\n"
        }
      },
      "requiredInputs": [
        "billingAccount",
        "complianceRegime",
        "displayName",
        "location",
        "organization"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Workload resources.\n",
        "properties": {
          "billingAccount": {
            "type": "string",
            "description": "Required. Input only. The billing account used for the resources which are direct children of workload. This billing account is initially associated with the resources created as part of Workload creation. After the initial creation of these resources, the customer can change the assigned billing account. The resource name has the form `billingAccounts/{billing_account_id}`. For example, 'billingAccounts/012345-567890-ABCDEF`.\n",
            "willReplaceOnChanges": true
          },
          "complianceRegime": {
            "type": "string",
            "description": "Required. Immutable. Compliance Regime associated with this workload. Possible values: COMPLIANCE_REGIME_UNSPECIFIED, IL4, CJIS, FEDRAMP_HIGH, FEDRAMP_MODERATE, US_REGIONAL_ACCESS\n",
            "willReplaceOnChanges": true
          },
          "createTime": {
            "type": "string",
            "description": "Output only. Immutable. The Workload creation timestamp.\n"
          },
          "displayName": {
            "type": "string",
            "description": "Required. The user-assigned display name of the Workload. When present it must be between 4 to 30 characters. Allowed characters are: lowercase and uppercase letters, numbers, hyphen, and spaces. Example: My Workload\n"
          },
          "kmsSettings": {
            "$ref": "#/types/gcp:assuredworkloads/WorkloadKmsSettings:WorkloadKmsSettings",
            "description": "Input only. Settings used to create a CMEK crypto key. When set a project with a KMS CMEK key is provisioned. This field is mandatory for a subset of Compliance Regimes.\n",
            "willReplaceOnChanges": true
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Optional. Labels applied to the workload.\n"
          },
          "location": {
            "type": "string",
            "description": "The location for the resource\n",
            "willReplaceOnChanges": true
          },
          "name": {
            "type": "string",
            "description": "Output only. The resource name of the workload.\n"
          },
          "organization": {
            "type": "string",
            "description": "The organization for the resource\n",
            "willReplaceOnChanges": true
          },
          "provisionedResourcesParent": {
            "type": "string",
            "description": "Input only. The parent resource for the resources managed by this Assured Workload. May be either an organization or a folder. Must be the same or a child of the Workload parent. If not specified all resources are created under the Workload parent. Formats: folders/{folder_id}, organizations/{organization_id}\n",
            "willReplaceOnChanges": true
          },
          "resourceSettings": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:assuredworkloads/WorkloadResourceSetting:WorkloadResourceSetting"
            },
            "description": "Input only. Resource properties that are used to customize workload resources. These properties (such as custom project id) will be used to create workload resources if possible. This field is optional.\n",
            "willReplaceOnChanges": true
          },
          "resources": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:assuredworkloads/WorkloadResource:WorkloadResource"
            },
            "description": "Output only. The resources associated with this workload. These resources will be created when creating the workload. If\nany of the projects already exist, the workload creation will fail. Always read only.\n"
          }
        },
        "type": "object"
      }
    },
    "gcp:bigquery/dataset:Dataset": {
      "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Bigquery Dataset Basic\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst bqowner = new gcp.serviceaccount.Account(\"bqowner\", {accountId: \"bqowner\"});\nconst dataset = new gcp.bigquery.Dataset(\"dataset\", {\n    datasetId: \"example_dataset\",\n    friendlyName: \"test\",\n    description: \"This is a test description\",\n    location: \"EU\",\n    defaultTableExpirationMs: 3600000,\n    labels: {\n        env: \"default\",\n    },\n    accesses: [\n        {\n            role: \"OWNER\",\n            userByEmail: bqowner.email,\n        },\n        {\n            role: \"READER\",\n            domain: \"hashicorp.com\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nbqowner = gcp.service_account.Account(\"bqowner\", account_id=\"bqowner\")\ndataset = gcp.bigquery.Dataset(\"dataset\",\n    dataset_id=\"example_dataset\",\n    friendly_name=\"test\",\n    description=\"This is a test description\",\n    location=\"EU\",\n    default_table_expiration_ms=3600000,\n    labels={\n        \"env\": \"default\",\n    },\n    accesses=[\n        gcp.bigquery.DatasetAccessArgs(\n            role=\"OWNER\",\n            user_by_email=bqowner.email,\n        ),\n        gcp.bigquery.DatasetAccessArgs(\n            role=\"READER\",\n            domain=\"hashicorp.com\",\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var bqowner = new Gcp.ServiceAccount.Account(\"bqowner\", new()\n    {\n        AccountId = \"bqowner\",\n    });\n\n    var dataset = new Gcp.BigQuery.Dataset(\"dataset\", new()\n    {\n        DatasetId = \"example_dataset\",\n        FriendlyName = \"test\",\n        Description = \"This is a test description\",\n        Location = \"EU\",\n        DefaultTableExpirationMs = 3600000,\n        Labels = \n        {\n            { \"env\", \"default\" },\n        },\n        Accesses = new[]\n        {\n            new Gcp.BigQuery.Inputs.DatasetAccessArgs\n            {\n                Role = \"OWNER\",\n                UserByEmail = bqowner.Email,\n            },\n            new Gcp.BigQuery.Inputs.DatasetAccessArgs\n            {\n                Role = \"READER\",\n                Domain = \"hashicorp.com\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigquery\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/serviceAccount\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tbqowner, err := serviceAccount.NewAccount(ctx, \"bqowner\", &serviceAccount.AccountArgs{\n\t\t\tAccountId: pulumi.String(\"bqowner\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigquery.NewDataset(ctx, \"dataset\", &bigquery.DatasetArgs{\n\t\t\tDatasetId:                pulumi.String(\"example_dataset\"),\n\t\t\tFriendlyName:             pulumi.String(\"test\"),\n\t\t\tDescription:              pulumi.String(\"This is a test description\"),\n\t\t\tLocation:                 pulumi.String(\"EU\"),\n\t\t\tDefaultTableExpirationMs: pulumi.Int(3600000),\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"env\": pulumi.String(\"default\"),\n\t\t\t},\n\t\t\tAccesses: bigquery.DatasetAccessTypeArray{\n\t\t\t\t&bigquery.DatasetAccessTypeArgs{\n\t\t\t\t\tRole:        pulumi.String(\"OWNER\"),\n\t\t\t\t\tUserByEmail: bqowner.Email,\n\t\t\t\t},\n\t\t\t\t&bigquery.DatasetAccessTypeArgs{\n\t\t\t\t\tRole:   pulumi.String(\"READER\"),\n\t\t\t\t\tDomain: pulumi.String(\"hashicorp.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.serviceAccount.Account;\nimport com.pulumi.gcp.serviceAccount.AccountArgs;\nimport com.pulumi.gcp.bigquery.Dataset;\nimport com.pulumi.gcp.bigquery.DatasetArgs;\nimport com.pulumi.gcp.bigquery.inputs.DatasetAccessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var bqowner = new Account(\"bqowner\", AccountArgs.builder()        \n            .accountId(\"bqowner\")\n            .build());\n\n        var dataset = new Dataset(\"dataset\", DatasetArgs.builder()        \n            .datasetId(\"example_dataset\")\n            .friendlyName(\"test\")\n            .description(\"This is a test description\")\n            .location(\"EU\")\n            .defaultTableExpirationMs(3600000)\n            .labels(Map.of(\"env\", \"default\"))\n            .accesses(            \n                DatasetAccessArgs.builder()\n                    .role(\"OWNER\")\n                    .userByEmail(bqowner.email())\n                    .build(),\n                DatasetAccessArgs.builder()\n                    .role(\"READER\")\n                    .domain(\"hashicorp.com\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dataset:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: example_dataset\n      friendlyName: test\n      description: This is a test description\n      location: EU\n      defaultTableExpirationMs: 3.6e+06\n      labels:\n        env: default\n      accesses:\n        - role: OWNER\n          userByEmail: ${bqowner.email}\n        - role: READER\n          domain: hashicorp.com\n  bqowner:\n    type: gcp:serviceAccount:Account\n    properties:\n      accountId: bqowner\n```\n{{% /example %}}\n{{% example %}}\n### Bigquery Dataset Cmek\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst keyRing = new gcp.kms.KeyRing(\"keyRing\", {location: \"us\"});\nconst cryptoKey = new gcp.kms.CryptoKey(\"cryptoKey\", {keyRing: keyRing.id});\nconst dataset = new gcp.bigquery.Dataset(\"dataset\", {\n    datasetId: \"example_dataset\",\n    friendlyName: \"test\",\n    description: \"This is a test description\",\n    location: \"US\",\n    defaultTableExpirationMs: 3600000,\n    defaultEncryptionConfiguration: {\n        kmsKeyName: cryptoKey.id,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nkey_ring = gcp.kms.KeyRing(\"keyRing\", location=\"us\")\ncrypto_key = gcp.kms.CryptoKey(\"cryptoKey\", key_ring=key_ring.id)\ndataset = gcp.bigquery.Dataset(\"dataset\",\n    dataset_id=\"example_dataset\",\n    friendly_name=\"test\",\n    description=\"This is a test description\",\n    location=\"US\",\n    default_table_expiration_ms=3600000,\n    default_encryption_configuration=gcp.bigquery.DatasetDefaultEncryptionConfigurationArgs(\n        kms_key_name=crypto_key.id,\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var keyRing = new Gcp.Kms.KeyRing(\"keyRing\", new()\n    {\n        Location = \"us\",\n    });\n\n    var cryptoKey = new Gcp.Kms.CryptoKey(\"cryptoKey\", new()\n    {\n        KeyRing = keyRing.Id,\n    });\n\n    var dataset = new Gcp.BigQuery.Dataset(\"dataset\", new()\n    {\n        DatasetId = \"example_dataset\",\n        FriendlyName = \"test\",\n        Description = \"This is a test description\",\n        Location = \"US\",\n        DefaultTableExpirationMs = 3600000,\n        DefaultEncryptionConfiguration = new Gcp.BigQuery.Inputs.DatasetDefaultEncryptionConfigurationArgs\n        {\n            KmsKeyName = cryptoKey.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigquery\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/kms\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkeyRing, err := kms.NewKeyRing(ctx, \"keyRing\", &kms.KeyRingArgs{\n\t\t\tLocation: pulumi.String(\"us\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcryptoKey, err := kms.NewCryptoKey(ctx, \"cryptoKey\", &kms.CryptoKeyArgs{\n\t\t\tKeyRing: keyRing.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigquery.NewDataset(ctx, \"dataset\", &bigquery.DatasetArgs{\n\t\t\tDatasetId:                pulumi.String(\"example_dataset\"),\n\t\t\tFriendlyName:             pulumi.String(\"test\"),\n\t\t\tDescription:              pulumi.String(\"This is a test description\"),\n\t\t\tLocation:                 pulumi.String(\"US\"),\n\t\t\tDefaultTableExpirationMs: pulumi.Int(3600000),\n\t\t\tDefaultEncryptionConfiguration: &bigquery.DatasetDefaultEncryptionConfigurationArgs{\n\t\t\t\tKmsKeyName: cryptoKey.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.kms.KeyRing;\nimport com.pulumi.gcp.kms.KeyRingArgs;\nimport com.pulumi.gcp.kms.CryptoKey;\nimport com.pulumi.gcp.kms.CryptoKeyArgs;\nimport com.pulumi.gcp.bigquery.Dataset;\nimport com.pulumi.gcp.bigquery.DatasetArgs;\nimport com.pulumi.gcp.bigquery.inputs.DatasetDefaultEncryptionConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var keyRing = new KeyRing(\"keyRing\", KeyRingArgs.builder()        \n            .location(\"us\")\n            .build());\n\n        var cryptoKey = new CryptoKey(\"cryptoKey\", CryptoKeyArgs.builder()        \n            .keyRing(keyRing.id())\n            .build());\n\n        var dataset = new Dataset(\"dataset\", DatasetArgs.builder()        \n            .datasetId(\"example_dataset\")\n            .friendlyName(\"test\")\n            .description(\"This is a test description\")\n            .location(\"US\")\n            .defaultTableExpirationMs(3600000)\n            .defaultEncryptionConfiguration(DatasetDefaultEncryptionConfigurationArgs.builder()\n                .kmsKeyName(cryptoKey.id())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dataset:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: example_dataset\n      friendlyName: test\n      description: This is a test description\n      location: US\n      defaultTableExpirationMs: 3.6e+06\n      defaultEncryptionConfiguration:\n        kmsKeyName: ${cryptoKey.id}\n  cryptoKey:\n    type: gcp:kms:CryptoKey\n    properties:\n      keyRing: ${keyRing.id}\n  keyRing:\n    type: gcp:kms:KeyRing\n    properties:\n      location: us\n```\n{{% /example %}}\n{{% example %}}\n### Bigquery Dataset Authorized Dataset\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst bqowner = new gcp.serviceaccount.Account(\"bqowner\", {accountId: \"bqowner\"});\nconst _public = new gcp.bigquery.Dataset(\"public\", {\n    datasetId: \"public\",\n    friendlyName: \"test\",\n    description: \"This dataset is public\",\n    location: \"EU\",\n    defaultTableExpirationMs: 3600000,\n    labels: {\n        env: \"default\",\n    },\n    accesses: [\n        {\n            role: \"OWNER\",\n            userByEmail: bqowner.email,\n        },\n        {\n            role: \"READER\",\n            domain: \"hashicorp.com\",\n        },\n    ],\n});\nconst dataset = new gcp.bigquery.Dataset(\"dataset\", {\n    datasetId: \"private\",\n    friendlyName: \"test\",\n    description: \"This dataset is private\",\n    location: \"EU\",\n    defaultTableExpirationMs: 3600000,\n    labels: {\n        env: \"default\",\n    },\n    accesses: [\n        {\n            role: \"OWNER\",\n            userByEmail: bqowner.email,\n        },\n        {\n            role: \"READER\",\n            domain: \"hashicorp.com\",\n        },\n        {\n            dataset: {\n                dataset: {\n                    projectId: _public.project,\n                    datasetId: _public.datasetId,\n                },\n                targetTypes: [\"VIEWS\"],\n            },\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nbqowner = gcp.service_account.Account(\"bqowner\", account_id=\"bqowner\")\npublic = gcp.bigquery.Dataset(\"public\",\n    dataset_id=\"public\",\n    friendly_name=\"test\",\n    description=\"This dataset is public\",\n    location=\"EU\",\n    default_table_expiration_ms=3600000,\n    labels={\n        \"env\": \"default\",\n    },\n    accesses=[\n        gcp.bigquery.DatasetAccessArgs(\n            role=\"OWNER\",\n            user_by_email=bqowner.email,\n        ),\n        gcp.bigquery.DatasetAccessArgs(\n            role=\"READER\",\n            domain=\"hashicorp.com\",\n        ),\n    ])\ndataset = gcp.bigquery.Dataset(\"dataset\",\n    dataset_id=\"private\",\n    friendly_name=\"test\",\n    description=\"This dataset is private\",\n    location=\"EU\",\n    default_table_expiration_ms=3600000,\n    labels={\n        \"env\": \"default\",\n    },\n    accesses=[\n        gcp.bigquery.DatasetAccessArgs(\n            role=\"OWNER\",\n            user_by_email=bqowner.email,\n        ),\n        gcp.bigquery.DatasetAccessArgs(\n            role=\"READER\",\n            domain=\"hashicorp.com\",\n        ),\n        gcp.bigquery.DatasetAccessArgs(\n            dataset=gcp.bigquery.DatasetAccessDatasetArgs(\n                dataset=gcp.bigquery.DatasetAccessDatasetDatasetArgs(\n                    project_id=public.project,\n                    dataset_id=public.dataset_id,\n                ),\n                target_types=[\"VIEWS\"],\n            ),\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var bqowner = new Gcp.ServiceAccount.Account(\"bqowner\", new()\n    {\n        AccountId = \"bqowner\",\n    });\n\n    var @public = new Gcp.BigQuery.Dataset(\"public\", new()\n    {\n        DatasetId = \"public\",\n        FriendlyName = \"test\",\n        Description = \"This dataset is public\",\n        Location = \"EU\",\n        DefaultTableExpirationMs = 3600000,\n        Labels = \n        {\n            { \"env\", \"default\" },\n        },\n        Accesses = new[]\n        {\n            new Gcp.BigQuery.Inputs.DatasetAccessArgs\n            {\n                Role = \"OWNER\",\n                UserByEmail = bqowner.Email,\n            },\n            new Gcp.BigQuery.Inputs.DatasetAccessArgs\n            {\n                Role = \"READER\",\n                Domain = \"hashicorp.com\",\n            },\n        },\n    });\n\n    var dataset = new Gcp.BigQuery.Dataset(\"dataset\", new()\n    {\n        DatasetId = \"private\",\n        FriendlyName = \"test\",\n        Description = \"This dataset is private\",\n        Location = \"EU\",\n        DefaultTableExpirationMs = 3600000,\n        Labels = \n        {\n            { \"env\", \"default\" },\n        },\n        Accesses = new[]\n        {\n            new Gcp.BigQuery.Inputs.DatasetAccessArgs\n            {\n                Role = \"OWNER\",\n                UserByEmail = bqowner.Email,\n            },\n            new Gcp.BigQuery.Inputs.DatasetAccessArgs\n            {\n                Role = \"READER\",\n                Domain = \"hashicorp.com\",\n            },\n            new Gcp.BigQuery.Inputs.DatasetAccessArgs\n            {\n                Dataset = new Gcp.BigQuery.Inputs.DatasetAccessDatasetArgs\n                {\n                    Dataset = new Gcp.BigQuery.Inputs.DatasetAccessDatasetDatasetArgs\n                    {\n                        ProjectId = @public.Project,\n                        DatasetId = @public.DatasetId,\n                    },\n                    TargetTypes = new[]\n                    {\n                        \"VIEWS\",\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigquery\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/serviceAccount\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tbqowner, err := serviceAccount.NewAccount(ctx, \"bqowner\", &serviceAccount.AccountArgs{\n\t\t\tAccountId: pulumi.String(\"bqowner\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpublic, err := bigquery.NewDataset(ctx, \"public\", &bigquery.DatasetArgs{\n\t\t\tDatasetId:                pulumi.String(\"public\"),\n\t\t\tFriendlyName:             pulumi.String(\"test\"),\n\t\t\tDescription:              pulumi.String(\"This dataset is public\"),\n\t\t\tLocation:                 pulumi.String(\"EU\"),\n\t\t\tDefaultTableExpirationMs: pulumi.Int(3600000),\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"env\": pulumi.String(\"default\"),\n\t\t\t},\n\t\t\tAccesses: bigquery.DatasetAccessTypeArray{\n\t\t\t\t&bigquery.DatasetAccessTypeArgs{\n\t\t\t\t\tRole:        pulumi.String(\"OWNER\"),\n\t\t\t\t\tUserByEmail: bqowner.Email,\n\t\t\t\t},\n\t\t\t\t&bigquery.DatasetAccessTypeArgs{\n\t\t\t\t\tRole:   pulumi.String(\"READER\"),\n\t\t\t\t\tDomain: pulumi.String(\"hashicorp.com\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigquery.NewDataset(ctx, \"dataset\", &bigquery.DatasetArgs{\n\t\t\tDatasetId:                pulumi.String(\"private\"),\n\t\t\tFriendlyName:             pulumi.String(\"test\"),\n\t\t\tDescription:              pulumi.String(\"This dataset is private\"),\n\t\t\tLocation:                 pulumi.String(\"EU\"),\n\t\t\tDefaultTableExpirationMs: pulumi.Int(3600000),\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"env\": pulumi.String(\"default\"),\n\t\t\t},\n\t\t\tAccesses: bigquery.DatasetAccessTypeArray{\n\t\t\t\t&bigquery.DatasetAccessTypeArgs{\n\t\t\t\t\tRole:        pulumi.String(\"OWNER\"),\n\t\t\t\t\tUserByEmail: bqowner.Email,\n\t\t\t\t},\n\t\t\t\t&bigquery.DatasetAccessTypeArgs{\n\t\t\t\t\tRole:   pulumi.String(\"READER\"),\n\t\t\t\t\tDomain: pulumi.String(\"hashicorp.com\"),\n\t\t\t\t},\n\t\t\t\t&bigquery.DatasetAccessTypeArgs{\n\t\t\t\t\tDataset: &bigquery.DatasetAccessDatasetArgs{\n\t\t\t\t\t\tDataset: &bigquery.DatasetAccessDatasetDatasetArgs{\n\t\t\t\t\t\t\tProjectId: public.Project,\n\t\t\t\t\t\t\tDatasetId: public.DatasetId,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTargetTypes: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"VIEWS\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.serviceAccount.Account;\nimport com.pulumi.gcp.serviceAccount.AccountArgs;\nimport com.pulumi.gcp.bigquery.Dataset;\nimport com.pulumi.gcp.bigquery.DatasetArgs;\nimport com.pulumi.gcp.bigquery.inputs.DatasetAccessArgs;\nimport com.pulumi.gcp.bigquery.inputs.DatasetAccessDatasetArgs;\nimport com.pulumi.gcp.bigquery.inputs.DatasetAccessDatasetDatasetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var bqowner = new Account(\"bqowner\", AccountArgs.builder()        \n            .accountId(\"bqowner\")\n            .build());\n\n        var public_ = new Dataset(\"public\", DatasetArgs.builder()        \n            .datasetId(\"public\")\n            .friendlyName(\"test\")\n            .description(\"This dataset is public\")\n            .location(\"EU\")\n            .defaultTableExpirationMs(3600000)\n            .labels(Map.of(\"env\", \"default\"))\n            .accesses(            \n                DatasetAccessArgs.builder()\n                    .role(\"OWNER\")\n                    .userByEmail(bqowner.email())\n                    .build(),\n                DatasetAccessArgs.builder()\n                    .role(\"READER\")\n                    .domain(\"hashicorp.com\")\n                    .build())\n            .build());\n\n        var dataset = new Dataset(\"dataset\", DatasetArgs.builder()        \n            .datasetId(\"private\")\n            .friendlyName(\"test\")\n            .description(\"This dataset is private\")\n            .location(\"EU\")\n            .defaultTableExpirationMs(3600000)\n            .labels(Map.of(\"env\", \"default\"))\n            .accesses(            \n                DatasetAccessArgs.builder()\n                    .role(\"OWNER\")\n                    .userByEmail(bqowner.email())\n                    .build(),\n                DatasetAccessArgs.builder()\n                    .role(\"READER\")\n                    .domain(\"hashicorp.com\")\n                    .build(),\n                DatasetAccessArgs.builder()\n                    .dataset(DatasetAccessDatasetArgs.builder()\n                        .dataset(DatasetAccessDatasetDatasetArgs.builder()\n                            .projectId(public_.project())\n                            .datasetId(public_.datasetId())\n                            .build())\n                        .targetTypes(\"VIEWS\")\n                        .build())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  public:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: public\n      friendlyName: test\n      description: This dataset is public\n      location: EU\n      defaultTableExpirationMs: 3.6e+06\n      labels:\n        env: default\n      accesses:\n        - role: OWNER\n          userByEmail: ${bqowner.email}\n        - role: READER\n          domain: hashicorp.com\n  dataset:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: private\n      friendlyName: test\n      description: This dataset is private\n      location: EU\n      defaultTableExpirationMs: 3.6e+06\n      labels:\n        env: default\n      accesses:\n        - role: OWNER\n          userByEmail: ${bqowner.email}\n        - role: READER\n          domain: hashicorp.com\n        - dataset:\n            dataset:\n              projectId: ${public.project}\n              datasetId: ${public.datasetId}\n            targetTypes:\n              - VIEWS\n  bqowner:\n    type: gcp:serviceAccount:Account\n    properties:\n      accountId: bqowner\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDataset can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:bigquery/dataset:Dataset default projects/{{project}}/datasets/{{dataset_id}}\n```\n\n\n\n```sh\n $ pulumi import gcp:bigquery/dataset:Dataset default {{project}}/{{dataset_id}}\n```\n\n\n\n```sh\n $ pulumi import gcp:bigquery/dataset:Dataset default {{dataset_id}}\n```\n\n ",
      "properties": {
        "accesses": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:bigquery/DatasetAccess:DatasetAccess"
          },
          "description": "An array of objects that define dataset access for one or more entities.\nStructure is documented below.\n"
        },
        "creationTime": {
          "type": "integer",
          "description": "The time when this dataset was created, in milliseconds since the epoch.\n"
        },
        "datasetId": {
          "type": "string",
          "description": "The ID of the dataset containing this table.\n"
        },
        "defaultEncryptionConfiguration": {
          "$ref": "#/types/gcp:bigquery/DatasetDefaultEncryptionConfiguration:DatasetDefaultEncryptionConfiguration",
          "description": "The default encryption key for all tables in the dataset. Once this property is set,\nall newly-created partitioned tables in the dataset will have encryption key set to\nthis value, unless table creation request (or query) overrides the key.\nStructure is documented below.\n"
        },
        "defaultPartitionExpirationMs": {
          "type": "integer",
          "description": "The default partition expiration for all partitioned tables in\nthe dataset, in milliseconds.\n"
        },
        "defaultTableExpirationMs": {
          "type": "integer",
          "description": "The default lifetime of all tables in the dataset, in milliseconds.\nThe minimum value is 3600000 milliseconds (one hour).\n"
        },
        "deleteContentsOnDestroy": {
          "type": "boolean",
          "description": "If set to `true`, delete all the tables in the\ndataset when destroying the resource; otherwise,\ndestroying the resource will fail if tables are present.\n"
        },
        "description": {
          "type": "string",
          "description": "A user-friendly description of the dataset\n"
        },
        "etag": {
          "type": "string",
          "description": "A hash of the resource.\n"
        },
        "friendlyName": {
          "type": "string",
          "description": "A descriptive name for the dataset\n"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "The labels associated with this dataset. You can use these to\norganize and group your datasets\n"
        },
        "lastModifiedTime": {
          "type": "integer",
          "description": "The date when this dataset or any of its tables was last modified, in milliseconds since the epoch.\n"
        },
        "location": {
          "type": "string",
          "description": "The geographic location where the dataset should reside.\nSee [official docs](https://cloud.google.com/bigquery/docs/dataset-locations).\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n"
        },
        "selfLink": {
          "type": "string",
          "description": "The URI of the created resource.\n"
        }
      },
      "required": [
        "accesses",
        "creationTime",
        "datasetId",
        "etag",
        "lastModifiedTime",
        "project",
        "selfLink"
      ],
      "inputProperties": {
        "accesses": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:bigquery/DatasetAccess:DatasetAccess"
          },
          "description": "An array of objects that define dataset access for one or more entities.\nStructure is documented below.\n"
        },
        "datasetId": {
          "type": "string",
          "description": "The ID of the dataset containing this table.\n",
          "willReplaceOnChanges": true
        },
        "defaultEncryptionConfiguration": {
          "$ref": "#/types/gcp:bigquery/DatasetDefaultEncryptionConfiguration:DatasetDefaultEncryptionConfiguration",
          "description": "The default encryption key for all tables in the dataset. Once this property is set,\nall newly-created partitioned tables in the dataset will have encryption key set to\nthis value, unless table creation request (or query) overrides the key.\nStructure is documented below.\n"
        },
        "defaultPartitionExpirationMs": {
          "type": "integer",
          "description": "The default partition expiration for all partitioned tables in\nthe dataset, in milliseconds.\n"
        },
        "defaultTableExpirationMs": {
          "type": "integer",
          "description": "The default lifetime of all tables in the dataset, in milliseconds.\nThe minimum value is 3600000 milliseconds (one hour).\n"
        },
        "deleteContentsOnDestroy": {
          "type": "boolean",
          "description": "If set to `true`, delete all the tables in the\ndataset when destroying the resource; otherwise,\ndestroying the resource will fail if tables are present.\n"
        },
        "description": {
          "type": "string",
          "description": "A user-friendly description of the dataset\n"
        },
        "friendlyName": {
          "type": "string",
          "description": "A descriptive name for the dataset\n"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "The labels associated with this dataset. You can use these to\norganize and group your datasets\n"
        },
        "location": {
          "type": "string",
          "description": "The geographic location where the dataset should reside.\nSee [official docs](https://cloud.google.com/bigquery/docs/dataset-locations).\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "datasetId"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Dataset resources.\n",
        "properties": {
          "accesses": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:bigquery/DatasetAccess:DatasetAccess"
            },
            "description": "An array of objects that define dataset access for one or more entities.\nStructure is documented below.\n"
          },
          "creationTime": {
            "type": "integer",
            "description": "The time when this dataset was created, in milliseconds since the epoch.\n"
          },
          "datasetId": {
            "type": "string",
            "description": "The ID of the dataset containing this table.\n",
            "willReplaceOnChanges": true
          },
          "defaultEncryptionConfiguration": {
            "$ref": "#/types/gcp:bigquery/DatasetDefaultEncryptionConfiguration:DatasetDefaultEncryptionConfiguration",
            "description": "The default encryption key for all tables in the dataset. Once this property is set,\nall newly-created partitioned tables in the dataset will have encryption key set to\nthis value, unless table creation request (or query) overrides the key.\nStructure is documented below.\n"
          },
          "defaultPartitionExpirationMs": {
            "type": "integer",
            "description": "The default partition expiration for all partitioned tables in\nthe dataset, in milliseconds.\n"
          },
          "defaultTableExpirationMs": {
            "type": "integer",
            "description": "The default lifetime of all tables in the dataset, in milliseconds.\nThe minimum value is 3600000 milliseconds (one hour).\n"
          },
          "deleteContentsOnDestroy": {
            "type": "boolean",
            "description": "If set to `true`, delete all the tables in the\ndataset when destroying the resource; otherwise,\ndestroying the resource will fail if tables are present.\n"
          },
          "description": {
            "type": "string",
            "description": "A user-friendly description of the dataset\n"
          },
          "etag": {
            "type": "string",
            "description": "A hash of the resource.\n"
          },
          "friendlyName": {
            "type": "string",
            "description": "A descriptive name for the dataset\n"
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "The labels associated with this dataset. You can use these to\norganize and group your datasets\n"
          },
          "lastModifiedTime": {
            "type": "integer",
            "description": "The date when this dataset or any of its tables was last modified, in milliseconds since the epoch.\n"
          },
          "location": {
            "type": "string",
            "description": "The geographic location where the dataset should reside.\nSee [official docs](https://cloud.google.com/bigquery/docs/dataset-locations).\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          },
          "selfLink": {
            "type": "string",
            "description": "The URI of the created resource.\n"
          }
        },
        "type": "object"
      }
    },
    "gcp:bigquery/datasetAccess:DatasetAccess": {
      "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Bigquery Dataset Access Basic User\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst dataset = new gcp.bigquery.Dataset(\"dataset\", {datasetId: \"example_dataset\"});\nconst bqowner = new gcp.serviceaccount.Account(\"bqowner\", {accountId: \"bqowner\"});\nconst access = new gcp.bigquery.DatasetAccess(\"access\", {\n    datasetId: dataset.datasetId,\n    role: \"OWNER\",\n    userByEmail: bqowner.email,\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\ndataset = gcp.bigquery.Dataset(\"dataset\", dataset_id=\"example_dataset\")\nbqowner = gcp.service_account.Account(\"bqowner\", account_id=\"bqowner\")\naccess = gcp.bigquery.DatasetAccess(\"access\",\n    dataset_id=dataset.dataset_id,\n    role=\"OWNER\",\n    user_by_email=bqowner.email)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var dataset = new Gcp.BigQuery.Dataset(\"dataset\", new()\n    {\n        DatasetId = \"example_dataset\",\n    });\n\n    var bqowner = new Gcp.ServiceAccount.Account(\"bqowner\", new()\n    {\n        AccountId = \"bqowner\",\n    });\n\n    var access = new Gcp.BigQuery.DatasetAccess(\"access\", new()\n    {\n        DatasetId = dataset.DatasetId,\n        Role = \"OWNER\",\n        UserByEmail = bqowner.Email,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigquery\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/serviceAccount\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdataset, err := bigquery.NewDataset(ctx, \"dataset\", &bigquery.DatasetArgs{\n\t\t\tDatasetId: pulumi.String(\"example_dataset\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbqowner, err := serviceAccount.NewAccount(ctx, \"bqowner\", &serviceAccount.AccountArgs{\n\t\t\tAccountId: pulumi.String(\"bqowner\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigquery.NewDatasetAccess(ctx, \"access\", &bigquery.DatasetAccessArgs{\n\t\t\tDatasetId:   dataset.DatasetId,\n\t\t\tRole:        pulumi.String(\"OWNER\"),\n\t\t\tUserByEmail: bqowner.Email,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigquery.Dataset;\nimport com.pulumi.gcp.bigquery.DatasetArgs;\nimport com.pulumi.gcp.serviceAccount.Account;\nimport com.pulumi.gcp.serviceAccount.AccountArgs;\nimport com.pulumi.gcp.bigquery.DatasetAccess;\nimport com.pulumi.gcp.bigquery.DatasetAccessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dataset = new Dataset(\"dataset\", DatasetArgs.builder()        \n            .datasetId(\"example_dataset\")\n            .build());\n\n        var bqowner = new Account(\"bqowner\", AccountArgs.builder()        \n            .accountId(\"bqowner\")\n            .build());\n\n        var access = new DatasetAccess(\"access\", DatasetAccessArgs.builder()        \n            .datasetId(dataset.datasetId())\n            .role(\"OWNER\")\n            .userByEmail(bqowner.email())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  access:\n    type: gcp:bigquery:DatasetAccess\n    properties:\n      datasetId: ${dataset.datasetId}\n      role: OWNER\n      userByEmail: ${bqowner.email}\n  dataset:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: example_dataset\n  bqowner:\n    type: gcp:serviceAccount:Account\n    properties:\n      accountId: bqowner\n```\n{{% /example %}}\n{{% example %}}\n### Bigquery Dataset Access View\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst _private = new gcp.bigquery.Dataset(\"private\", {datasetId: \"example_dataset\"});\nconst publicDataset = new gcp.bigquery.Dataset(\"publicDataset\", {datasetId: \"example_dataset2\"});\nconst publicTable = new gcp.bigquery.Table(\"publicTable\", {\n    deletionProtection: false,\n    datasetId: publicDataset.datasetId,\n    tableId: \"example_table\",\n    view: {\n        query: \"SELECT state FROM [lookerdata:cdc.project_tycho_reports]\",\n        useLegacySql: false,\n    },\n});\nconst access = new gcp.bigquery.DatasetAccess(\"access\", {\n    datasetId: _private.datasetId,\n    view: {\n        projectId: publicTable.project,\n        datasetId: publicDataset.datasetId,\n        tableId: publicTable.tableId,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nprivate = gcp.bigquery.Dataset(\"private\", dataset_id=\"example_dataset\")\npublic_dataset = gcp.bigquery.Dataset(\"publicDataset\", dataset_id=\"example_dataset2\")\npublic_table = gcp.bigquery.Table(\"publicTable\",\n    deletion_protection=False,\n    dataset_id=public_dataset.dataset_id,\n    table_id=\"example_table\",\n    view=gcp.bigquery.TableViewArgs(\n        query=\"SELECT state FROM [lookerdata:cdc.project_tycho_reports]\",\n        use_legacy_sql=False,\n    ))\naccess = gcp.bigquery.DatasetAccess(\"access\",\n    dataset_id=private.dataset_id,\n    view=gcp.bigquery.DatasetAccessViewArgs(\n        project_id=public_table.project,\n        dataset_id=public_dataset.dataset_id,\n        table_id=public_table.table_id,\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var @private = new Gcp.BigQuery.Dataset(\"private\", new()\n    {\n        DatasetId = \"example_dataset\",\n    });\n\n    var publicDataset = new Gcp.BigQuery.Dataset(\"publicDataset\", new()\n    {\n        DatasetId = \"example_dataset2\",\n    });\n\n    var publicTable = new Gcp.BigQuery.Table(\"publicTable\", new()\n    {\n        DeletionProtection = false,\n        DatasetId = publicDataset.DatasetId,\n        TableId = \"example_table\",\n        View = new Gcp.BigQuery.Inputs.TableViewArgs\n        {\n            Query = \"SELECT state FROM [lookerdata:cdc.project_tycho_reports]\",\n            UseLegacySql = false,\n        },\n    });\n\n    var access = new Gcp.BigQuery.DatasetAccess(\"access\", new()\n    {\n        DatasetId = @private.DatasetId,\n        View = new Gcp.BigQuery.Inputs.DatasetAccessViewArgs\n        {\n            ProjectId = publicTable.Project,\n            DatasetId = publicDataset.DatasetId,\n            TableId = publicTable.TableId,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigquery\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tprivate, err := bigquery.NewDataset(ctx, \"private\", &bigquery.DatasetArgs{\n\t\t\tDatasetId: pulumi.String(\"example_dataset\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpublicDataset, err := bigquery.NewDataset(ctx, \"publicDataset\", &bigquery.DatasetArgs{\n\t\t\tDatasetId: pulumi.String(\"example_dataset2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpublicTable, err := bigquery.NewTable(ctx, \"publicTable\", &bigquery.TableArgs{\n\t\t\tDeletionProtection: pulumi.Bool(false),\n\t\t\tDatasetId:          publicDataset.DatasetId,\n\t\t\tTableId:            pulumi.String(\"example_table\"),\n\t\t\tView: &bigquery.TableViewArgs{\n\t\t\t\tQuery:        pulumi.String(\"SELECT state FROM [lookerdata:cdc.project_tycho_reports]\"),\n\t\t\t\tUseLegacySql: pulumi.Bool(false),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigquery.NewDatasetAccess(ctx, \"access\", &bigquery.DatasetAccessArgs{\n\t\t\tDatasetId: private.DatasetId,\n\t\t\tView: &bigquery.DatasetAccessViewArgs{\n\t\t\t\tProjectId: publicTable.Project,\n\t\t\t\tDatasetId: publicDataset.DatasetId,\n\t\t\t\tTableId:   publicTable.TableId,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigquery.Dataset;\nimport com.pulumi.gcp.bigquery.DatasetArgs;\nimport com.pulumi.gcp.bigquery.Table;\nimport com.pulumi.gcp.bigquery.TableArgs;\nimport com.pulumi.gcp.bigquery.inputs.TableViewArgs;\nimport com.pulumi.gcp.bigquery.DatasetAccess;\nimport com.pulumi.gcp.bigquery.DatasetAccessArgs;\nimport com.pulumi.gcp.bigquery.inputs.DatasetAccessViewArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var private_ = new Dataset(\"private\", DatasetArgs.builder()        \n            .datasetId(\"example_dataset\")\n            .build());\n\n        var publicDataset = new Dataset(\"publicDataset\", DatasetArgs.builder()        \n            .datasetId(\"example_dataset2\")\n            .build());\n\n        var publicTable = new Table(\"publicTable\", TableArgs.builder()        \n            .deletionProtection(false)\n            .datasetId(publicDataset.datasetId())\n            .tableId(\"example_table\")\n            .view(TableViewArgs.builder()\n                .query(\"SELECT state FROM [lookerdata:cdc.project_tycho_reports]\")\n                .useLegacySql(false)\n                .build())\n            .build());\n\n        var access = new DatasetAccess(\"access\", DatasetAccessArgs.builder()        \n            .datasetId(private_.datasetId())\n            .view(DatasetAccessViewArgs.builder()\n                .projectId(publicTable.project())\n                .datasetId(publicDataset.datasetId())\n                .tableId(publicTable.tableId())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  access:\n    type: gcp:bigquery:DatasetAccess\n    properties:\n      datasetId: ${private.datasetId}\n      view:\n        projectId: ${publicTable.project}\n        datasetId: ${publicDataset.datasetId}\n        tableId: ${publicTable.tableId}\n  private:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: example_dataset\n  publicDataset:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: example_dataset2\n  publicTable:\n    type: gcp:bigquery:Table\n    properties:\n      deletionProtection: false\n      datasetId: ${publicDataset.datasetId}\n      tableId: example_table\n      view:\n        query: SELECT state FROM [lookerdata:cdc.project_tycho_reports]\n        useLegacySql: false\n```\n{{% /example %}}\n{{% example %}}\n### Bigquery Dataset Access Authorized Dataset\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst _private = new gcp.bigquery.Dataset(\"private\", {datasetId: \"private\"});\nconst _public = new gcp.bigquery.Dataset(\"public\", {datasetId: \"public\"});\nconst access = new gcp.bigquery.DatasetAccess(\"access\", {\n    datasetId: _private.datasetId,\n    authorizedDataset: {\n        dataset: {\n            projectId: _public.project,\n            datasetId: _public.datasetId,\n        },\n        targetTypes: [\"VIEWS\"],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nprivate = gcp.bigquery.Dataset(\"private\", dataset_id=\"private\")\npublic = gcp.bigquery.Dataset(\"public\", dataset_id=\"public\")\naccess = gcp.bigquery.DatasetAccess(\"access\",\n    dataset_id=private.dataset_id,\n    authorized_dataset=gcp.bigquery.DatasetAccessAuthorizedDatasetArgs(\n        dataset=gcp.bigquery.DatasetAccessAuthorizedDatasetDatasetArgs(\n            project_id=public.project,\n            dataset_id=public.dataset_id,\n        ),\n        target_types=[\"VIEWS\"],\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var @private = new Gcp.BigQuery.Dataset(\"private\", new()\n    {\n        DatasetId = \"private\",\n    });\n\n    var @public = new Gcp.BigQuery.Dataset(\"public\", new()\n    {\n        DatasetId = \"public\",\n    });\n\n    var access = new Gcp.BigQuery.DatasetAccess(\"access\", new()\n    {\n        DatasetId = @private.DatasetId,\n        AuthorizedDataset = new Gcp.BigQuery.Inputs.DatasetAccessAuthorizedDatasetArgs\n        {\n            Dataset = new Gcp.BigQuery.Inputs.DatasetAccessAuthorizedDatasetDatasetArgs\n            {\n                ProjectId = @public.Project,\n                DatasetId = @public.DatasetId,\n            },\n            TargetTypes = new[]\n            {\n                \"VIEWS\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigquery\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tprivate, err := bigquery.NewDataset(ctx, \"private\", &bigquery.DatasetArgs{\n\t\t\tDatasetId: pulumi.String(\"private\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpublic, err := bigquery.NewDataset(ctx, \"public\", &bigquery.DatasetArgs{\n\t\t\tDatasetId: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigquery.NewDatasetAccess(ctx, \"access\", &bigquery.DatasetAccessArgs{\n\t\t\tDatasetId: private.DatasetId,\n\t\t\tAuthorizedDataset: &bigquery.DatasetAccessAuthorizedDatasetArgs{\n\t\t\t\tDataset: &bigquery.DatasetAccessAuthorizedDatasetDatasetArgs{\n\t\t\t\t\tProjectId: public.Project,\n\t\t\t\t\tDatasetId: public.DatasetId,\n\t\t\t\t},\n\t\t\t\tTargetTypes: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"VIEWS\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigquery.Dataset;\nimport com.pulumi.gcp.bigquery.DatasetArgs;\nimport com.pulumi.gcp.bigquery.DatasetAccess;\nimport com.pulumi.gcp.bigquery.DatasetAccessArgs;\nimport com.pulumi.gcp.bigquery.inputs.DatasetAccessAuthorizedDatasetArgs;\nimport com.pulumi.gcp.bigquery.inputs.DatasetAccessAuthorizedDatasetDatasetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var private_ = new Dataset(\"private\", DatasetArgs.builder()        \n            .datasetId(\"private\")\n            .build());\n\n        var public_ = new Dataset(\"public\", DatasetArgs.builder()        \n            .datasetId(\"public\")\n            .build());\n\n        var access = new DatasetAccess(\"access\", DatasetAccessArgs.builder()        \n            .datasetId(private_.datasetId())\n            .authorizedDataset(DatasetAccessAuthorizedDatasetArgs.builder()\n                .dataset(DatasetAccessAuthorizedDatasetDatasetArgs.builder()\n                    .projectId(public_.project())\n                    .datasetId(public_.datasetId())\n                    .build())\n                .targetTypes(\"VIEWS\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  access:\n    type: gcp:bigquery:DatasetAccess\n    properties:\n      datasetId: ${private.datasetId}\n      authorizedDataset:\n        dataset:\n          projectId: ${public.project}\n          datasetId: ${public.datasetId}\n        targetTypes:\n          - VIEWS\n  private:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: private\n  public:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: public\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource does not support import. ",
      "properties": {
        "apiUpdatedMember": {
          "type": "boolean",
          "description": "If true, represents that that the iam_member in the config was translated to a different member type by the API, and is\nstored in state as a different member type\n"
        },
        "authorizedDataset": {
          "$ref": "#/types/gcp:bigquery/DatasetAccessAuthorizedDataset:DatasetAccessAuthorizedDataset",
          "description": "The dataset this entry applies to\nStructure is documented below.\n"
        },
        "datasetId": {
          "type": "string",
          "description": "The ID of the dataset containing this table.\n"
        },
        "domain": {
          "type": "string",
          "description": "A domain to grant access to. Any users signed in with the\ndomain specified will be granted the specified access\n"
        },
        "groupByEmail": {
          "type": "string",
          "description": "An email address of a Google Group to grant access to.\n"
        },
        "iamMember": {
          "type": "string",
          "description": "Some other type of member that appears in the IAM Policy but isn't a user,\ngroup, domain, or special group. For example: `allUsers`\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n"
        },
        "role": {
          "type": "string",
          "description": "Describes the rights granted to the user specified by the other\nmember of the access object. Basic, predefined, and custom roles are\nsupported. Predefined roles that have equivalent basic roles are\nswapped by the API to their basic counterparts, and will show a diff\npost-create. See\n[official docs](https://cloud.google.com/bigquery/docs/access-control).\n"
        },
        "specialGroup": {
          "type": "string",
          "description": "A special group to grant access to. Possible values include:\n"
        },
        "userByEmail": {
          "type": "string",
          "description": "An email address of a user to grant access to. For example:\nfred@example.com\n"
        },
        "view": {
          "$ref": "#/types/gcp:bigquery/DatasetAccessView:DatasetAccessView",
          "description": "A view from a different dataset to grant access to. Queries\nexecuted against that view will have read access to tables in\nthis dataset. The role field is not required when this field is\nset. If that view is updated by any user, access to the view\nneeds to be granted again via an update operation.\nStructure is documented below.\n"
        }
      },
      "required": [
        "apiUpdatedMember",
        "datasetId",
        "project"
      ],
      "inputProperties": {
        "authorizedDataset": {
          "$ref": "#/types/gcp:bigquery/DatasetAccessAuthorizedDataset:DatasetAccessAuthorizedDataset",
          "willReplaceOnChanges": true,
          "description": "The dataset this entry applies to\nStructure is documented below.\n"
        },
        "datasetId": {
          "type": "string",
          "description": "The ID of the dataset containing this table.\n",
          "willReplaceOnChanges": true
        },
        "domain": {
          "type": "string",
          "description": "A domain to grant access to. Any users signed in with the\ndomain specified will be granted the specified access\n",
          "willReplaceOnChanges": true
        },
        "groupByEmail": {
          "type": "string",
          "description": "An email address of a Google Group to grant access to.\n",
          "willReplaceOnChanges": true
        },
        "iamMember": {
          "type": "string",
          "description": "Some other type of member that appears in the IAM Policy but isn't a user,\ngroup, domain, or special group. For example: `allUsers`\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        },
        "role": {
          "type": "string",
          "description": "Describes the rights granted to the user specified by the other\nmember of the access object. Basic, predefined, and custom roles are\nsupported. Predefined roles that have equivalent basic roles are\nswapped by the API to their basic counterparts, and will show a diff\npost-create. See\n[official docs](https://cloud.google.com/bigquery/docs/access-control).\n",
          "willReplaceOnChanges": true
        },
        "specialGroup": {
          "type": "string",
          "description": "A special group to grant access to. Possible values include:\n",
          "willReplaceOnChanges": true
        },
        "userByEmail": {
          "type": "string",
          "description": "An email address of a user to grant access to. For example:\nfred@example.com\n",
          "willReplaceOnChanges": true
        },
        "view": {
          "$ref": "#/types/gcp:bigquery/DatasetAccessView:DatasetAccessView",
          "willReplaceOnChanges": true,
          "description": "A view from a different dataset to grant access to. Queries\nexecuted against that view will have read access to tables in\nthis dataset. The role field is not required when this field is\nset. If that view is updated by any user, access to the view\nneeds to be granted again via an update operation.\nStructure is documented below.\n"
        }
      },
      "requiredInputs": [
        "datasetId"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering DatasetAccess resources.\n",
        "properties": {
          "apiUpdatedMember": {
            "type": "boolean",
            "description": "If true, represents that that the iam_member in the config was translated to a different member type by the API, and is\nstored in state as a different member type\n"
          },
          "authorizedDataset": {
            "$ref": "#/types/gcp:bigquery/DatasetAccessAuthorizedDataset:DatasetAccessAuthorizedDataset",
            "description": "The dataset this entry applies to\nStructure is documented below.\n",
            "willReplaceOnChanges": true
          },
          "datasetId": {
            "type": "string",
            "description": "The ID of the dataset containing this table.\n",
            "willReplaceOnChanges": true
          },
          "domain": {
            "type": "string",
            "description": "A domain to grant access to. Any users signed in with the\ndomain specified will be granted the specified access\n",
            "willReplaceOnChanges": true
          },
          "groupByEmail": {
            "type": "string",
            "description": "An email address of a Google Group to grant access to.\n",
            "willReplaceOnChanges": true
          },
          "iamMember": {
            "type": "string",
            "description": "Some other type of member that appears in the IAM Policy but isn't a user,\ngroup, domain, or special group. For example: `allUsers`\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          },
          "role": {
            "type": "string",
            "description": "Describes the rights granted to the user specified by the other\nmember of the access object. Basic, predefined, and custom roles are\nsupported. Predefined roles that have equivalent basic roles are\nswapped by the API to their basic counterparts, and will show a diff\npost-create. See\n[official docs](https://cloud.google.com/bigquery/docs/access-control).\n",
            "willReplaceOnChanges": true
          },
          "specialGroup": {
            "type": "string",
            "description": "A special group to grant access to. Possible values include:\n",
            "willReplaceOnChanges": true
          },
          "userByEmail": {
            "type": "string",
            "description": "An email address of a user to grant access to. For example:\nfred@example.com\n",
            "willReplaceOnChanges": true
          },
          "view": {
            "$ref": "#/types/gcp:bigquery/DatasetAccessView:DatasetAccessView",
            "description": "A view from a different dataset to grant access to. Queries\nexecuted against that view will have read access to tables in\nthis dataset. The role field is not required when this field is\nset. If that view is updated by any user, access to the view\nneeds to be granted again via an update operation.\nStructure is documented below.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:bigquery/routine:Routine": {
      "description": "A user-defined function or a stored procedure that belongs to a Dataset\n\n\nTo get more information about Routine, see:\n\n* [API documentation](https://cloud.google.com/bigquery/docs/reference/rest/v2/routines)\n* How-to Guides\n    * [Routines Intro](https://cloud.google.com/bigquery/docs/reference/rest/v2/routines)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Big Query Routine Basic\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst test = new gcp.bigquery.Dataset(\"test\", {datasetId: \"dataset_id\"});\nconst sproc = new gcp.bigquery.Routine(\"sproc\", {\n    datasetId: test.datasetId,\n    routineId: \"routine_id\",\n    routineType: \"PROCEDURE\",\n    language: \"SQL\",\n    definitionBody: \"CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\ntest = gcp.bigquery.Dataset(\"test\", dataset_id=\"dataset_id\")\nsproc = gcp.bigquery.Routine(\"sproc\",\n    dataset_id=test.dataset_id,\n    routine_id=\"routine_id\",\n    routine_type=\"PROCEDURE\",\n    language=\"SQL\",\n    definition_body=\"CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var test = new Gcp.BigQuery.Dataset(\"test\", new()\n    {\n        DatasetId = \"dataset_id\",\n    });\n\n    var sproc = new Gcp.BigQuery.Routine(\"sproc\", new()\n    {\n        DatasetId = test.DatasetId,\n        RoutineId = \"routine_id\",\n        RoutineType = \"PROCEDURE\",\n        Language = \"SQL\",\n        DefinitionBody = \"CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigquery\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := bigquery.NewDataset(ctx, \"test\", &bigquery.DatasetArgs{\n\t\t\tDatasetId: pulumi.String(\"dataset_id\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigquery.NewRoutine(ctx, \"sproc\", &bigquery.RoutineArgs{\n\t\t\tDatasetId:      test.DatasetId,\n\t\t\tRoutineId:      pulumi.String(\"routine_id\"),\n\t\t\tRoutineType:    pulumi.String(\"PROCEDURE\"),\n\t\t\tLanguage:       pulumi.String(\"SQL\"),\n\t\t\tDefinitionBody: pulumi.String(\"CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigquery.Dataset;\nimport com.pulumi.gcp.bigquery.DatasetArgs;\nimport com.pulumi.gcp.bigquery.Routine;\nimport com.pulumi.gcp.bigquery.RoutineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Dataset(\"test\", DatasetArgs.builder()        \n            .datasetId(\"dataset_id\")\n            .build());\n\n        var sproc = new Routine(\"sproc\", RoutineArgs.builder()        \n            .datasetId(test.datasetId())\n            .routineId(\"routine_id\")\n            .routineType(\"PROCEDURE\")\n            .language(\"SQL\")\n            .definitionBody(\"CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: dataset_id\n  sproc:\n    type: gcp:bigquery:Routine\n    properties:\n      datasetId: ${test.datasetId}\n      routineId: routine_id\n      routineType: PROCEDURE\n      language: SQL\n      definitionBody: CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);\n```\n{{% /example %}}\n{{% example %}}\n### Big Query Routine Json\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst test = new gcp.bigquery.Dataset(\"test\", {datasetId: \"dataset_id\"});\nconst sproc = new gcp.bigquery.Routine(\"sproc\", {\n    datasetId: test.datasetId,\n    routineId: \"tf_test_routine_id\",\n    routineType: \"SCALAR_FUNCTION\",\n    language: \"JAVASCRIPT\",\n    definitionBody: \"CREATE FUNCTION multiplyInputs return x*y;\",\n    arguments: [\n        {\n            name: \"x\",\n            dataType: \"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\",\n        },\n        {\n            name: \"y\",\n            dataType: \"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\",\n        },\n    ],\n    returnType: \"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\ntest = gcp.bigquery.Dataset(\"test\", dataset_id=\"dataset_id\")\nsproc = gcp.bigquery.Routine(\"sproc\",\n    dataset_id=test.dataset_id,\n    routine_id=\"tf_test_routine_id\",\n    routine_type=\"SCALAR_FUNCTION\",\n    language=\"JAVASCRIPT\",\n    definition_body=\"CREATE FUNCTION multiplyInputs return x*y;\",\n    arguments=[\n        gcp.bigquery.RoutineArgumentArgs(\n            name=\"x\",\n            data_type=\"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\",\n        ),\n        gcp.bigquery.RoutineArgumentArgs(\n            name=\"y\",\n            data_type=\"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\",\n        ),\n    ],\n    return_type=\"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var test = new Gcp.BigQuery.Dataset(\"test\", new()\n    {\n        DatasetId = \"dataset_id\",\n    });\n\n    var sproc = new Gcp.BigQuery.Routine(\"sproc\", new()\n    {\n        DatasetId = test.DatasetId,\n        RoutineId = \"tf_test_routine_id\",\n        RoutineType = \"SCALAR_FUNCTION\",\n        Language = \"JAVASCRIPT\",\n        DefinitionBody = \"CREATE FUNCTION multiplyInputs return x*y;\",\n        Arguments = new[]\n        {\n            new Gcp.BigQuery.Inputs.RoutineArgumentArgs\n            {\n                Name = \"x\",\n                DataType = \"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\",\n            },\n            new Gcp.BigQuery.Inputs.RoutineArgumentArgs\n            {\n                Name = \"y\",\n                DataType = \"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\",\n            },\n        },\n        ReturnType = \"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigquery\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := bigquery.NewDataset(ctx, \"test\", &bigquery.DatasetArgs{\n\t\t\tDatasetId: pulumi.String(\"dataset_id\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigquery.NewRoutine(ctx, \"sproc\", &bigquery.RoutineArgs{\n\t\t\tDatasetId:      test.DatasetId,\n\t\t\tRoutineId:      pulumi.String(\"tf_test_routine_id\"),\n\t\t\tRoutineType:    pulumi.String(\"SCALAR_FUNCTION\"),\n\t\t\tLanguage:       pulumi.String(\"JAVASCRIPT\"),\n\t\t\tDefinitionBody: pulumi.String(\"CREATE FUNCTION multiplyInputs return x*y;\"),\n\t\t\tArguments: bigquery.RoutineArgumentArray{\n\t\t\t\t&bigquery.RoutineArgumentArgs{\n\t\t\t\t\tName:     pulumi.String(\"x\"),\n\t\t\t\t\tDataType: pulumi.String(\"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\"),\n\t\t\t\t},\n\t\t\t\t&bigquery.RoutineArgumentArgs{\n\t\t\t\t\tName:     pulumi.String(\"y\"),\n\t\t\t\t\tDataType: pulumi.String(\"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tReturnType: pulumi.String(\"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigquery.Dataset;\nimport com.pulumi.gcp.bigquery.DatasetArgs;\nimport com.pulumi.gcp.bigquery.Routine;\nimport com.pulumi.gcp.bigquery.RoutineArgs;\nimport com.pulumi.gcp.bigquery.inputs.RoutineArgumentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Dataset(\"test\", DatasetArgs.builder()        \n            .datasetId(\"dataset_id\")\n            .build());\n\n        var sproc = new Routine(\"sproc\", RoutineArgs.builder()        \n            .datasetId(test.datasetId())\n            .routineId(\"tf_test_routine_id\")\n            .routineType(\"SCALAR_FUNCTION\")\n            .language(\"JAVASCRIPT\")\n            .definitionBody(\"CREATE FUNCTION multiplyInputs return x*y;\")\n            .arguments(            \n                RoutineArgumentArgs.builder()\n                    .name(\"x\")\n                    .dataType(\"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\")\n                    .build(),\n                RoutineArgumentArgs.builder()\n                    .name(\"y\")\n                    .dataType(\"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\")\n                    .build())\n            .returnType(\"{\\\"typeKind\\\" :  \\\"FLOAT64\\\"}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: dataset_id\n  sproc:\n    type: gcp:bigquery:Routine\n    properties:\n      datasetId: ${test.datasetId}\n      routineId: tf_test_routine_id\n      routineType: SCALAR_FUNCTION\n      language: JAVASCRIPT\n      definitionBody: CREATE FUNCTION multiplyInputs return x*y;\n      arguments:\n        - name: x\n          dataType: '{\"typeKind\" :  \"FLOAT64\"}'\n        - name: y\n          dataType: '{\"typeKind\" :  \"FLOAT64\"}'\n      returnType: '{\"typeKind\" :  \"FLOAT64\"}'\n```\n{{% /example %}}\n{{% example %}}\n### Big Query Routine Tvf\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst test = new gcp.bigquery.Dataset(\"test\", {datasetId: \"dataset_id\"});\nconst sproc = new gcp.bigquery.Routine(\"sproc\", {\n    datasetId: test.datasetId,\n    routineId: \"tf_test_routine_id\",\n    routineType: \"TABLE_VALUED_FUNCTION\",\n    language: \"SQL\",\n    definitionBody: \"SELECT 1 + value AS value\\n\",\n    arguments: [{\n        name: \"value\",\n        argumentKind: \"FIXED_TYPE\",\n        dataType: JSON.stringify({\n            typeKind: \"INT64\",\n        }),\n    }],\n    returnTableType: JSON.stringify({\n        columns: [{\n            name: \"value\",\n            type: {\n                typeKind: \"INT64\",\n            },\n        }],\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_gcp as gcp\n\ntest = gcp.bigquery.Dataset(\"test\", dataset_id=\"dataset_id\")\nsproc = gcp.bigquery.Routine(\"sproc\",\n    dataset_id=test.dataset_id,\n    routine_id=\"tf_test_routine_id\",\n    routine_type=\"TABLE_VALUED_FUNCTION\",\n    language=\"SQL\",\n    definition_body=\"SELECT 1 + value AS value\\n\",\n    arguments=[gcp.bigquery.RoutineArgumentArgs(\n        name=\"value\",\n        argument_kind=\"FIXED_TYPE\",\n        data_type=json.dumps({\n            \"typeKind\": \"INT64\",\n        }),\n    )],\n    return_table_type=json.dumps({\n        \"columns\": [{\n            \"name\": \"value\",\n            \"type\": {\n                \"typeKind\": \"INT64\",\n            },\n        }],\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var test = new Gcp.BigQuery.Dataset(\"test\", new()\n    {\n        DatasetId = \"dataset_id\",\n    });\n\n    var sproc = new Gcp.BigQuery.Routine(\"sproc\", new()\n    {\n        DatasetId = test.DatasetId,\n        RoutineId = \"tf_test_routine_id\",\n        RoutineType = \"TABLE_VALUED_FUNCTION\",\n        Language = \"SQL\",\n        DefinitionBody = @\"SELECT 1 + value AS value\n\",\n        Arguments = new[]\n        {\n            new Gcp.BigQuery.Inputs.RoutineArgumentArgs\n            {\n                Name = \"value\",\n                ArgumentKind = \"FIXED_TYPE\",\n                DataType = JsonSerializer.Serialize(new Dictionary<string, object?>\n                {\n                    [\"typeKind\"] = \"INT64\",\n                }),\n            },\n        },\n        ReturnTableType = JsonSerializer.Serialize(new Dictionary<string, object?>\n        {\n            [\"columns\"] = new[]\n            {\n                new Dictionary<string, object?>\n                {\n                    [\"name\"] = \"value\",\n                    [\"type\"] = new Dictionary<string, object?>\n                    {\n                        [\"typeKind\"] = \"INT64\",\n                    },\n                },\n            },\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigquery\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := bigquery.NewDataset(ctx, \"test\", &bigquery.DatasetArgs{\n\t\t\tDatasetId: pulumi.String(\"dataset_id\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"typeKind\": \"INT64\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\ttmpJSON1, err := json.Marshal(map[string]interface{}{\n\t\t\t\"columns\": []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\": \"value\",\n\t\t\t\t\t\"type\": map[string]interface{}{\n\t\t\t\t\t\t\"typeKind\": \"INT64\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson1 := string(tmpJSON1)\n\t\t_, err = bigquery.NewRoutine(ctx, \"sproc\", &bigquery.RoutineArgs{\n\t\t\tDatasetId:      test.DatasetId,\n\t\t\tRoutineId:      pulumi.String(\"tf_test_routine_id\"),\n\t\t\tRoutineType:    pulumi.String(\"TABLE_VALUED_FUNCTION\"),\n\t\t\tLanguage:       pulumi.String(\"SQL\"),\n\t\t\tDefinitionBody: pulumi.String(\"SELECT 1 + value AS value\\n\"),\n\t\t\tArguments: bigquery.RoutineArgumentArray{\n\t\t\t\t&bigquery.RoutineArgumentArgs{\n\t\t\t\t\tName:         pulumi.String(\"value\"),\n\t\t\t\t\tArgumentKind: pulumi.String(\"FIXED_TYPE\"),\n\t\t\t\t\tDataType:     pulumi.String(json0),\n\t\t\t\t},\n\t\t\t},\n\t\t\tReturnTableType: pulumi.String(json1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigquery.Dataset;\nimport com.pulumi.gcp.bigquery.DatasetArgs;\nimport com.pulumi.gcp.bigquery.Routine;\nimport com.pulumi.gcp.bigquery.RoutineArgs;\nimport com.pulumi.gcp.bigquery.inputs.RoutineArgumentArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Dataset(\"test\", DatasetArgs.builder()        \n            .datasetId(\"dataset_id\")\n            .build());\n\n        var sproc = new Routine(\"sproc\", RoutineArgs.builder()        \n            .datasetId(test.datasetId())\n            .routineId(\"tf_test_routine_id\")\n            .routineType(\"TABLE_VALUED_FUNCTION\")\n            .language(\"SQL\")\n            .definitionBody(\"\"\"\nSELECT 1 + value AS value\n            \"\"\")\n            .arguments(RoutineArgumentArgs.builder()\n                .name(\"value\")\n                .argumentKind(\"FIXED_TYPE\")\n                .dataType(serializeJson(\n                    jsonObject(\n                        jsonProperty(\"typeKind\", \"INT64\")\n                    )))\n                .build())\n            .returnTableType(serializeJson(\n                jsonObject(\n                    jsonProperty(\"columns\", jsonArray(jsonObject(\n                        jsonProperty(\"name\", \"value\"),\n                        jsonProperty(\"type\", jsonObject(\n                            jsonProperty(\"typeKind\", \"INT64\")\n                        ))\n                    )))\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gcp:bigquery:Dataset\n    properties:\n      datasetId: dataset_id\n  sproc:\n    type: gcp:bigquery:Routine\n    properties:\n      datasetId: ${test.datasetId}\n      routineId: tf_test_routine_id\n      routineType: TABLE_VALUED_FUNCTION\n      language: SQL\n      definitionBody: |\n        SELECT 1 + value AS value\n      arguments:\n        - name: value\n          argumentKind: FIXED_TYPE\n          dataType:\n            Fn::ToJSON:\n              typeKind: INT64\n      returnTableType:\n        Fn::ToJSON:\n          columns:\n            - name: value\n              type:\n                typeKind: INT64\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRoutine can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:bigquery/routine:Routine default projects/{{project}}/datasets/{{dataset_id}}/routines/{{routine_id}}\n```\n\n\n\n```sh\n $ pulumi import gcp:bigquery/routine:Routine default {{project}}/{{dataset_id}}/{{routine_id}}\n```\n\n\n\n```sh\n $ pulumi import gcp:bigquery/routine:Routine default {{dataset_id}}/{{routine_id}}\n```\n\n ",
      "properties": {
        "arguments": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:bigquery/RoutineArgument:RoutineArgument"
          },
          "description": "Input/output argument of a function or a stored procedure.\nStructure is documented below.\n"
        },
        "creationTime": {
          "type": "integer",
          "description": "The time when this routine was created, in milliseconds since the epoch.\n"
        },
        "datasetId": {
          "type": "string",
          "description": "The ID of the dataset containing this routine\n"
        },
        "definitionBody": {
          "type": "string",
          "description": "The body of the routine. For functions, this is the expression in the AS clause.\nIf language=SQL, it is the substring inside (but excluding) the parentheses.\n"
        },
        "description": {
          "type": "string",
          "description": "The description of the routine if defined.\n"
        },
        "determinismLevel": {
          "type": "string",
          "description": "The determinism level of the JavaScript UDF if defined.\nPossible values are `DETERMINISM_LEVEL_UNSPECIFIED`, `DETERMINISTIC`, and `NOT_DETERMINISTIC`.\n"
        },
        "importedLibraries": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Optional. If language = \"JAVASCRIPT\", this field stores the path of the\nimported JAVASCRIPT libraries.\n"
        },
        "language": {
          "type": "string",
          "description": "The language of the routine.\nPossible values are `SQL` and `JAVASCRIPT`.\n"
        },
        "lastModifiedTime": {
          "type": "integer",
          "description": "The time when this routine was modified, in milliseconds since the epoch.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n"
        },
        "returnTableType": {
          "type": "string",
          "description": "Optional. Can be set only if routineType = \"TABLE_VALUED_FUNCTION\".\nIf absent, the return table type is inferred from definitionBody at query time in each query\nthat references this routine. If present, then the columns in the evaluated table result will\nbe cast to match the column types specificed in return table type, at query time.\n"
        },
        "returnType": {
          "type": "string",
          "description": "A JSON schema for the return type. Optional if language = \"SQL\"; required otherwise.\nIf absent, the return type is inferred from definitionBody at query time in each query\nthat references this routine. If present, then the evaluated result will be cast to\nthe specified returned type at query time. ~>**NOTE**: Because this field expects a JSON\nstring, any changes to the string will create a diff, even if the JSON itself hasn't\nchanged. If the API returns a different value for the same schema, e.g. it switche\nd the order of values or replaced STRUCT field type with RECORD field type, we currently\ncannot suppress the recurring diff this causes. As a workaround, we recommend using\nthe schema as returned by the API.\n"
        },
        "routineId": {
          "type": "string",
          "description": "The ID of the the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.\n"
        },
        "routineType": {
          "type": "string",
          "description": "The type of routine.\nPossible values are `SCALAR_FUNCTION`, `PROCEDURE`, and `TABLE_VALUED_FUNCTION`.\n"
        }
      },
      "required": [
        "creationTime",
        "datasetId",
        "definitionBody",
        "lastModifiedTime",
        "project",
        "routineId"
      ],
      "inputProperties": {
        "arguments": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:bigquery/RoutineArgument:RoutineArgument"
          },
          "description": "Input/output argument of a function or a stored procedure.\nStructure is documented below.\n"
        },
        "datasetId": {
          "type": "string",
          "description": "The ID of the dataset containing this routine\n",
          "willReplaceOnChanges": true
        },
        "definitionBody": {
          "type": "string",
          "description": "The body of the routine. For functions, this is the expression in the AS clause.\nIf language=SQL, it is the substring inside (but excluding) the parentheses.\n"
        },
        "description": {
          "type": "string",
          "description": "The description of the routine if defined.\n"
        },
        "determinismLevel": {
          "type": "string",
          "description": "The determinism level of the JavaScript UDF if defined.\nPossible values are `DETERMINISM_LEVEL_UNSPECIFIED`, `DETERMINISTIC`, and `NOT_DETERMINISTIC`.\n"
        },
        "importedLibraries": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Optional. If language = \"JAVASCRIPT\", this field stores the path of the\nimported JAVASCRIPT libraries.\n"
        },
        "language": {
          "type": "string",
          "description": "The language of the routine.\nPossible values are `SQL` and `JAVASCRIPT`.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        },
        "returnTableType": {
          "type": "string",
          "description": "Optional. Can be set only if routineType = \"TABLE_VALUED_FUNCTION\".\nIf absent, the return table type is inferred from definitionBody at query time in each query\nthat references this routine. If present, then the columns in the evaluated table result will\nbe cast to match the column types specificed in return table type, at query time.\n"
        },
        "returnType": {
          "type": "string",
          "description": "A JSON schema for the return type. Optional if language = \"SQL\"; required otherwise.\nIf absent, the return type is inferred from definitionBody at query time in each query\nthat references this routine. If present, then the evaluated result will be cast to\nthe specified returned type at query time. ~>**NOTE**: Because this field expects a JSON\nstring, any changes to the string will create a diff, even if the JSON itself hasn't\nchanged. If the API returns a different value for the same schema, e.g. it switche\nd the order of values or replaced STRUCT field type with RECORD field type, we currently\ncannot suppress the recurring diff this causes. As a workaround, we recommend using\nthe schema as returned by the API.\n"
        },
        "routineId": {
          "type": "string",
          "description": "The ID of the the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.\n",
          "willReplaceOnChanges": true
        },
        "routineType": {
          "type": "string",
          "description": "The type of routine.\nPossible values are `SCALAR_FUNCTION`, `PROCEDURE`, and `TABLE_VALUED_FUNCTION`.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "datasetId",
        "definitionBody",
        "routineId"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Routine resources.\n",
        "properties": {
          "arguments": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:bigquery/RoutineArgument:RoutineArgument"
            },
            "description": "Input/output argument of a function or a stored procedure.\nStructure is documented below.\n"
          },
          "creationTime": {
            "type": "integer",
            "description": "The time when this routine was created, in milliseconds since the epoch.\n"
          },
          "datasetId": {
            "type": "string",
            "description": "The ID of the dataset containing this routine\n",
            "willReplaceOnChanges": true
          },
          "definitionBody": {
            "type": "string",
            "description": "The body of the routine. For functions, this is the expression in the AS clause.\nIf language=SQL, it is the substring inside (but excluding) the parentheses.\n"
          },
          "description": {
            "type": "string",
            "description": "The description of the routine if defined.\n"
          },
          "determinismLevel": {
            "type": "string",
            "description": "The determinism level of the JavaScript UDF if defined.\nPossible values are `DETERMINISM_LEVEL_UNSPECIFIED`, `DETERMINISTIC`, and `NOT_DETERMINISTIC`.\n"
          },
          "importedLibraries": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional. If language = \"JAVASCRIPT\", this field stores the path of the\nimported JAVASCRIPT libraries.\n"
          },
          "language": {
            "type": "string",
            "description": "The language of the routine.\nPossible values are `SQL` and `JAVASCRIPT`.\n"
          },
          "lastModifiedTime": {
            "type": "integer",
            "description": "The time when this routine was modified, in milliseconds since the epoch.\n"
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          },
          "returnTableType": {
            "type": "string",
            "description": "Optional. Can be set only if routineType = \"TABLE_VALUED_FUNCTION\".\nIf absent, the return table type is inferred from definitionBody at query time in each query\nthat references this routine. If present, then the columns in the evaluated table result will\nbe cast to match the column types specificed in return table type, at query time.\n"
          },
          "returnType": {
            "type": "string",
            "description": "A JSON schema for the return type. Optional if language = \"SQL\"; required otherwise.\nIf absent, the return type is inferred from definitionBody at query time in each query\nthat references this routine. If present, then the evaluated result will be cast to\nthe specified returned type at query time. ~>**NOTE**: Because this field expects a JSON\nstring, any changes to the string will create a diff, even if the JSON itself hasn't\nchanged. If the API returns a different value for the same schema, e.g. it switche\nd the order of values or replaced STRUCT field type with RECORD field type, we currently\ncannot suppress the recurring diff this causes. As a workaround, we recommend using\nthe schema as returned by the API.\n"
          },
          "routineId": {
            "type": "string",
            "description": "The ID of the the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.\n",
            "willReplaceOnChanges": true
          },
          "routineType": {
            "type": "string",
            "description": "The type of routine.\nPossible values are `SCALAR_FUNCTION`, `PROCEDURE`, and `TABLE_VALUED_FUNCTION`.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:bigtable/gCPolicy:GCPolicy": {
      "description": "Creates a Google Cloud Bigtable GC Policy inside a family. For more information see\n[the official documentation](https://cloud.google.com/bigtable/) and\n[API](https://cloud.google.com/bigtable/docs/go/reference).\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst instance = new gcp.bigtable.Instance(\"instance\", {clusters: [{\n    clusterId: \"tf-instance-cluster\",\n    numNodes: 3,\n    storageType: \"HDD\",\n}]});\nconst table = new gcp.bigtable.Table(\"table\", {\n    instanceName: instance.name,\n    columnFamilies: [{\n        family: \"name\",\n    }],\n});\nconst policy = new gcp.bigtable.GCPolicy(\"policy\", {\n    instanceName: instance.name,\n    table: table.name,\n    columnFamily: \"name\",\n    maxAge: {\n        duration: \"168h\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\ninstance = gcp.bigtable.Instance(\"instance\", clusters=[gcp.bigtable.InstanceClusterArgs(\n    cluster_id=\"tf-instance-cluster\",\n    num_nodes=3,\n    storage_type=\"HDD\",\n)])\ntable = gcp.bigtable.Table(\"table\",\n    instance_name=instance.name,\n    column_families=[gcp.bigtable.TableColumnFamilyArgs(\n        family=\"name\",\n    )])\npolicy = gcp.bigtable.GCPolicy(\"policy\",\n    instance_name=instance.name,\n    table=table.name,\n    column_family=\"name\",\n    max_age=gcp.bigtable.GCPolicyMaxAgeArgs(\n        duration=\"168h\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var instance = new Gcp.BigTable.Instance(\"instance\", new()\n    {\n        Clusters = new[]\n        {\n            new Gcp.BigTable.Inputs.InstanceClusterArgs\n            {\n                ClusterId = \"tf-instance-cluster\",\n                NumNodes = 3,\n                StorageType = \"HDD\",\n            },\n        },\n    });\n\n    var table = new Gcp.BigTable.Table(\"table\", new()\n    {\n        InstanceName = instance.Name,\n        ColumnFamilies = new[]\n        {\n            new Gcp.BigTable.Inputs.TableColumnFamilyArgs\n            {\n                Family = \"name\",\n            },\n        },\n    });\n\n    var policy = new Gcp.BigTable.GCPolicy(\"policy\", new()\n    {\n        InstanceName = instance.Name,\n        Table = table.Name,\n        ColumnFamily = \"name\",\n        MaxAge = new Gcp.BigTable.Inputs.GCPolicyMaxAgeArgs\n        {\n            Duration = \"168h\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigtable\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinstance, err := bigtable.NewInstance(ctx, \"instance\", &bigtable.InstanceArgs{\n\t\t\tClusters: bigtable.InstanceClusterArray{\n\t\t\t\t&bigtable.InstanceClusterArgs{\n\t\t\t\t\tClusterId:   pulumi.String(\"tf-instance-cluster\"),\n\t\t\t\t\tNumNodes:    pulumi.Int(3),\n\t\t\t\t\tStorageType: pulumi.String(\"HDD\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttable, err := bigtable.NewTable(ctx, \"table\", &bigtable.TableArgs{\n\t\t\tInstanceName: instance.Name,\n\t\t\tColumnFamilies: bigtable.TableColumnFamilyArray{\n\t\t\t\t&bigtable.TableColumnFamilyArgs{\n\t\t\t\t\tFamily: pulumi.String(\"name\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigtable.NewGCPolicy(ctx, \"policy\", &bigtable.GCPolicyArgs{\n\t\t\tInstanceName: instance.Name,\n\t\t\tTable:        table.Name,\n\t\t\tColumnFamily: pulumi.String(\"name\"),\n\t\t\tMaxAge: &bigtable.GCPolicyMaxAgeArgs{\n\t\t\t\tDuration: pulumi.String(\"168h\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigtable.Instance;\nimport com.pulumi.gcp.bigtable.InstanceArgs;\nimport com.pulumi.gcp.bigtable.inputs.InstanceClusterArgs;\nimport com.pulumi.gcp.bigtable.Table;\nimport com.pulumi.gcp.bigtable.TableArgs;\nimport com.pulumi.gcp.bigtable.inputs.TableColumnFamilyArgs;\nimport com.pulumi.gcp.bigtable.GCPolicy;\nimport com.pulumi.gcp.bigtable.GCPolicyArgs;\nimport com.pulumi.gcp.bigtable.inputs.GCPolicyMaxAgeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var instance = new Instance(\"instance\", InstanceArgs.builder()        \n            .clusters(InstanceClusterArgs.builder()\n                .clusterId(\"tf-instance-cluster\")\n                .numNodes(3)\n                .storageType(\"HDD\")\n                .build())\n            .build());\n\n        var table = new Table(\"table\", TableArgs.builder()        \n            .instanceName(instance.name())\n            .columnFamilies(TableColumnFamilyArgs.builder()\n                .family(\"name\")\n                .build())\n            .build());\n\n        var policy = new GCPolicy(\"policy\", GCPolicyArgs.builder()        \n            .instanceName(instance.name())\n            .table(table.name())\n            .columnFamily(\"name\")\n            .maxAge(GCPolicyMaxAgeArgs.builder()\n                .duration(\"168h\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  instance:\n    type: gcp:bigtable:Instance\n    properties:\n      clusters:\n        - clusterId: tf-instance-cluster\n          numNodes: 3\n          storageType: HDD\n  table:\n    type: gcp:bigtable:Table\n    properties:\n      instanceName: ${instance.name}\n      columnFamilies:\n        - family: name\n  policy:\n    type: gcp:bigtable:GCPolicy\n    properties:\n      instanceName: ${instance.name}\n      table: ${table.name}\n      columnFamily: name\n      maxAge:\n        duration: 168h\n```\n\nMultiple conditions is also supported. `UNION` when any of its sub-policies apply (OR). `INTERSECTION` when all its sub-policies apply (AND)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst policy = new gcp.bigtable.GCPolicy(\"policy\", {\n    instanceName: google_bigtable_instance.instance.name,\n    table: google_bigtable_table.table.name,\n    columnFamily: \"name\",\n    mode: \"UNION\",\n    maxAge: {\n        duration: \"168h\",\n    },\n    maxVersions: [{\n        number: 10,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\npolicy = gcp.bigtable.GCPolicy(\"policy\",\n    instance_name=google_bigtable_instance[\"instance\"][\"name\"],\n    table=google_bigtable_table[\"table\"][\"name\"],\n    column_family=\"name\",\n    mode=\"UNION\",\n    max_age=gcp.bigtable.GCPolicyMaxAgeArgs(\n        duration=\"168h\",\n    ),\n    max_versions=[gcp.bigtable.GCPolicyMaxVersionArgs(\n        number=10,\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var policy = new Gcp.BigTable.GCPolicy(\"policy\", new()\n    {\n        InstanceName = google_bigtable_instance.Instance.Name,\n        Table = google_bigtable_table.Table.Name,\n        ColumnFamily = \"name\",\n        Mode = \"UNION\",\n        MaxAge = new Gcp.BigTable.Inputs.GCPolicyMaxAgeArgs\n        {\n            Duration = \"168h\",\n        },\n        MaxVersions = new[]\n        {\n            new Gcp.BigTable.Inputs.GCPolicyMaxVersionArgs\n            {\n                Number = 10,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigtable\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := bigtable.NewGCPolicy(ctx, \"policy\", &bigtable.GCPolicyArgs{\n\t\t\tInstanceName: pulumi.Any(google_bigtable_instance.Instance.Name),\n\t\t\tTable:        pulumi.Any(google_bigtable_table.Table.Name),\n\t\t\tColumnFamily: pulumi.String(\"name\"),\n\t\t\tMode:         pulumi.String(\"UNION\"),\n\t\t\tMaxAge: &bigtable.GCPolicyMaxAgeArgs{\n\t\t\t\tDuration: pulumi.String(\"168h\"),\n\t\t\t},\n\t\t\tMaxVersions: bigtable.GCPolicyMaxVersionArray{\n\t\t\t\t&bigtable.GCPolicyMaxVersionArgs{\n\t\t\t\t\tNumber: pulumi.Int(10),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigtable.GCPolicy;\nimport com.pulumi.gcp.bigtable.GCPolicyArgs;\nimport com.pulumi.gcp.bigtable.inputs.GCPolicyMaxAgeArgs;\nimport com.pulumi.gcp.bigtable.inputs.GCPolicyMaxVersionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var policy = new GCPolicy(\"policy\", GCPolicyArgs.builder()        \n            .instanceName(google_bigtable_instance.instance().name())\n            .table(google_bigtable_table.table().name())\n            .columnFamily(\"name\")\n            .mode(\"UNION\")\n            .maxAge(GCPolicyMaxAgeArgs.builder()\n                .duration(\"168h\")\n                .build())\n            .maxVersions(GCPolicyMaxVersionArgs.builder()\n                .number(10)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  policy:\n    type: gcp:bigtable:GCPolicy\n    properties:\n      instanceName: ${google_bigtable_instance.instance.name}\n      table: ${google_bigtable_table.table.name}\n      columnFamily: name\n      mode: UNION\n      maxAge:\n        duration: 168h\n      maxVersions:\n        - number: 10\n```\n\nFor complex, nested policies, an optional `gc_rules` field are supported. This field\nconflicts with `mode`, `max_age` and `max_version`. This field is a serialized JSON\nstring. Example:\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst instance = new gcp.bigtable.Instance(\"instance\", {\n    clusters: [{\n        clusterId: \"cid\",\n        zone: \"us-central1-b\",\n    }],\n    instanceType: \"DEVELOPMENT\",\n    deletionProtection: false,\n});\nconst table = new gcp.bigtable.Table(\"table\", {\n    instanceName: instance.id,\n    columnFamilies: [{\n        family: \"cf1\",\n    }],\n});\nconst policy = new gcp.bigtable.GCPolicy(\"policy\", {\n    instanceName: instance.id,\n    table: table.name,\n    columnFamily: \"cf1\",\n    gcRules: `{\n  \"mode\": \"union\",\n  \"rules\": [\n    {\n      \"max_age\": \"10h\"\n    },\n    {\n      \"mode\": \"intersection\",\n      \"rules\": [\n        {\n          \"max_age\": \"2h\"\n        },\n        {\n          \"max_version\": 2\n        }\n      ]\n    }\n  ]\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\ninstance = gcp.bigtable.Instance(\"instance\",\n    clusters=[gcp.bigtable.InstanceClusterArgs(\n        cluster_id=\"cid\",\n        zone=\"us-central1-b\",\n    )],\n    instance_type=\"DEVELOPMENT\",\n    deletion_protection=False)\ntable = gcp.bigtable.Table(\"table\",\n    instance_name=instance.id,\n    column_families=[gcp.bigtable.TableColumnFamilyArgs(\n        family=\"cf1\",\n    )])\npolicy = gcp.bigtable.GCPolicy(\"policy\",\n    instance_name=instance.id,\n    table=table.name,\n    column_family=\"cf1\",\n    gc_rules=\"\"\"{\n  \"mode\": \"union\",\n  \"rules\": [\n    {\n      \"max_age\": \"10h\"\n    },\n    {\n      \"mode\": \"intersection\",\n      \"rules\": [\n        {\n          \"max_age\": \"2h\"\n        },\n        {\n          \"max_version\": 2\n        }\n      ]\n    }\n  ]\n}\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var instance = new Gcp.BigTable.Instance(\"instance\", new()\n    {\n        Clusters = new[]\n        {\n            new Gcp.BigTable.Inputs.InstanceClusterArgs\n            {\n                ClusterId = \"cid\",\n                Zone = \"us-central1-b\",\n            },\n        },\n        InstanceType = \"DEVELOPMENT\",\n        DeletionProtection = false,\n    });\n\n    var table = new Gcp.BigTable.Table(\"table\", new()\n    {\n        InstanceName = instance.Id,\n        ColumnFamilies = new[]\n        {\n            new Gcp.BigTable.Inputs.TableColumnFamilyArgs\n            {\n                Family = \"cf1\",\n            },\n        },\n    });\n\n    var policy = new Gcp.BigTable.GCPolicy(\"policy\", new()\n    {\n        InstanceName = instance.Id,\n        Table = table.Name,\n        ColumnFamily = \"cf1\",\n        GcRules = @\"{\n  \"\"mode\"\": \"\"union\"\",\n  \"\"rules\"\": [\n    {\n      \"\"max_age\"\": \"\"10h\"\"\n    },\n    {\n      \"\"mode\"\": \"\"intersection\"\",\n      \"\"rules\"\": [\n        {\n          \"\"max_age\"\": \"\"2h\"\"\n        },\n        {\n          \"\"max_version\"\": 2\n        }\n      ]\n    }\n  ]\n}\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigtable\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinstance, err := bigtable.NewInstance(ctx, \"instance\", &bigtable.InstanceArgs{\n\t\t\tClusters: bigtable.InstanceClusterArray{\n\t\t\t\t&bigtable.InstanceClusterArgs{\n\t\t\t\t\tClusterId: pulumi.String(\"cid\"),\n\t\t\t\t\tZone:      pulumi.String(\"us-central1-b\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tInstanceType:       pulumi.String(\"DEVELOPMENT\"),\n\t\t\tDeletionProtection: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttable, err := bigtable.NewTable(ctx, \"table\", &bigtable.TableArgs{\n\t\t\tInstanceName: instance.ID(),\n\t\t\tColumnFamilies: bigtable.TableColumnFamilyArray{\n\t\t\t\t&bigtable.TableColumnFamilyArgs{\n\t\t\t\t\tFamily: pulumi.String(\"cf1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigtable.NewGCPolicy(ctx, \"policy\", &bigtable.GCPolicyArgs{\n\t\t\tInstanceName: instance.ID(),\n\t\t\tTable:        table.Name,\n\t\t\tColumnFamily: pulumi.String(\"cf1\"),\n\t\t\tGcRules: pulumi.String(fmt.Sprintf(`{\n  \"mode\": \"union\",\n  \"rules\": [\n    {\n      \"max_age\": \"10h\"\n    },\n    {\n      \"mode\": \"intersection\",\n      \"rules\": [\n        {\n          \"max_age\": \"2h\"\n        },\n        {\n          \"max_version\": 2\n        }\n      ]\n    }\n  ]\n}\n`)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigtable.Instance;\nimport com.pulumi.gcp.bigtable.InstanceArgs;\nimport com.pulumi.gcp.bigtable.inputs.InstanceClusterArgs;\nimport com.pulumi.gcp.bigtable.Table;\nimport com.pulumi.gcp.bigtable.TableArgs;\nimport com.pulumi.gcp.bigtable.inputs.TableColumnFamilyArgs;\nimport com.pulumi.gcp.bigtable.GCPolicy;\nimport com.pulumi.gcp.bigtable.GCPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var instance = new Instance(\"instance\", InstanceArgs.builder()        \n            .clusters(InstanceClusterArgs.builder()\n                .clusterId(\"cid\")\n                .zone(\"us-central1-b\")\n                .build())\n            .instanceType(\"DEVELOPMENT\")\n            .deletionProtection(false)\n            .build());\n\n        var table = new Table(\"table\", TableArgs.builder()        \n            .instanceName(instance.id())\n            .columnFamilies(TableColumnFamilyArgs.builder()\n                .family(\"cf1\")\n                .build())\n            .build());\n\n        var policy = new GCPolicy(\"policy\", GCPolicyArgs.builder()        \n            .instanceName(instance.id())\n            .table(table.name())\n            .columnFamily(\"cf1\")\n            .gcRules(\"\"\"\n{\n  \"mode\": \"union\",\n  \"rules\": [\n    {\n      \"max_age\": \"10h\"\n    },\n    {\n      \"mode\": \"intersection\",\n      \"rules\": [\n        {\n          \"max_age\": \"2h\"\n        },\n        {\n          \"max_version\": 2\n        }\n      ]\n    }\n  ]\n}\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  instance:\n    type: gcp:bigtable:Instance\n    properties:\n      clusters:\n        - clusterId: cid\n          zone: us-central1-b\n      instanceType: DEVELOPMENT\n      deletionProtection: false\n  table:\n    type: gcp:bigtable:Table\n    properties:\n      instanceName: ${instance.id}\n      columnFamilies:\n        - family: cf1\n  policy:\n    type: gcp:bigtable:GCPolicy\n    properties:\n      instanceName: ${instance.id}\n      table: ${table.name}\n      columnFamily: cf1\n      gcRules: |\n        {\n          \"mode\": \"union\",\n          \"rules\": [\n            {\n              \"max_age\": \"10h\"\n            },\n            {\n              \"mode\": \"intersection\",\n              \"rules\": [\n                {\n                  \"max_age\": \"2h\"\n                },\n                {\n                  \"max_version\": 2\n                }\n              ]\n            }\n          ]\n        }\n```\nThis is equivalent to running the following `cbt` command:\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() => \n{\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n    }\n}\n```\n```yaml\n{}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource does not support import. ",
      "properties": {
        "columnFamily": {
          "type": "string",
          "description": "The name of the column family.\n"
        },
        "gcRules": {
          "type": "string",
          "description": "Serialized JSON object to represent a more complex GC policy. Conflicts with `mode`, `max_age` and `max_version`. Conflicts with `mode`, `max_age` and `max_version`.\n"
        },
        "instanceName": {
          "type": "string",
          "description": "The name of the Bigtable instance.\n"
        },
        "maxAge": {
          "$ref": "#/types/gcp:bigtable/GCPolicyMaxAge:GCPolicyMaxAge",
          "description": "GC policy that applies to all cells older than the given age.\n"
        },
        "maxVersions": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:bigtable/GCPolicyMaxVersion:GCPolicyMaxVersion"
          },
          "description": "GC policy that applies to all versions of a cell except for the most recent.\n"
        },
        "mode": {
          "type": "string",
          "description": "If multiple policies are set, you should choose between `UNION` OR `INTERSECTION`.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs. If it is not provided, the provider project is used.\n"
        },
        "table": {
          "type": "string",
          "description": "The name of the table.\n"
        }
      },
      "required": [
        "columnFamily",
        "instanceName",
        "project",
        "table"
      ],
      "inputProperties": {
        "columnFamily": {
          "type": "string",
          "description": "The name of the column family.\n",
          "willReplaceOnChanges": true
        },
        "gcRules": {
          "type": "string",
          "description": "Serialized JSON object to represent a more complex GC policy. Conflicts with `mode`, `max_age` and `max_version`. Conflicts with `mode`, `max_age` and `max_version`.\n"
        },
        "instanceName": {
          "type": "string",
          "description": "The name of the Bigtable instance.\n",
          "willReplaceOnChanges": true
        },
        "maxAge": {
          "$ref": "#/types/gcp:bigtable/GCPolicyMaxAge:GCPolicyMaxAge",
          "willReplaceOnChanges": true,
          "description": "GC policy that applies to all cells older than the given age.\n"
        },
        "maxVersions": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:bigtable/GCPolicyMaxVersion:GCPolicyMaxVersion"
          },
          "willReplaceOnChanges": true,
          "description": "GC policy that applies to all versions of a cell except for the most recent.\n"
        },
        "mode": {
          "type": "string",
          "description": "If multiple policies are set, you should choose between `UNION` OR `INTERSECTION`.\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs. If it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        },
        "table": {
          "type": "string",
          "description": "The name of the table.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "columnFamily",
        "instanceName",
        "table"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering GCPolicy resources.\n",
        "properties": {
          "columnFamily": {
            "type": "string",
            "description": "The name of the column family.\n",
            "willReplaceOnChanges": true
          },
          "gcRules": {
            "type": "string",
            "description": "Serialized JSON object to represent a more complex GC policy. Conflicts with `mode`, `max_age` and `max_version`. Conflicts with `mode`, `max_age` and `max_version`.\n"
          },
          "instanceName": {
            "type": "string",
            "description": "The name of the Bigtable instance.\n",
            "willReplaceOnChanges": true
          },
          "maxAge": {
            "$ref": "#/types/gcp:bigtable/GCPolicyMaxAge:GCPolicyMaxAge",
            "description": "GC policy that applies to all cells older than the given age.\n",
            "willReplaceOnChanges": true
          },
          "maxVersions": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:bigtable/GCPolicyMaxVersion:GCPolicyMaxVersion"
            },
            "description": "GC policy that applies to all versions of a cell except for the most recent.\n",
            "willReplaceOnChanges": true
          },
          "mode": {
            "type": "string",
            "description": "If multiple policies are set, you should choose between `UNION` OR `INTERSECTION`.\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs. If it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          },
          "table": {
            "type": "string",
            "description": "The name of the table.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:compute/instance:Instance": {
      "description": "Manages a VM instance resource within GCE. For more information see\n[the official documentation](https://cloud.google.com/compute/docs/instances)\nand\n[API](https://cloud.google.com/compute/docs/reference/latest/instances).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst defaultAccount = new gcp.serviceaccount.Account(\"defaultAccount\", {\n    accountId: \"service_account_id\",\n    displayName: \"Service Account\",\n});\nconst defaultInstance = new gcp.compute.Instance(\"defaultInstance\", {\n    machineType: \"e2-medium\",\n    zone: \"us-central1-a\",\n    tags: [\n        \"foo\",\n        \"bar\",\n    ],\n    bootDisk: {\n        initializeParams: {\n            image: \"debian-cloud/debian-11\",\n        },\n    },\n    scratchDisks: [{\n        \"interface\": \"SCSI\",\n    }],\n    networkInterfaces: [{\n        network: \"default\",\n        accessConfigs: [{}],\n    }],\n    metadata: {\n        foo: \"bar\",\n    },\n    metadataStartupScript: \"echo hi \u003e /test.txt\",\n    serviceAccount: {\n        email: defaultAccount.email,\n        scopes: [\"cloud-platform\"],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\ndefault_account = gcp.service_account.Account(\"defaultAccount\",\n    account_id=\"service_account_id\",\n    display_name=\"Service Account\")\ndefault_instance = gcp.compute.Instance(\"defaultInstance\",\n    machine_type=\"e2-medium\",\n    zone=\"us-central1-a\",\n    tags=[\n        \"foo\",\n        \"bar\",\n    ],\n    boot_disk=gcp.compute.InstanceBootDiskArgs(\n        initialize_params=gcp.compute.InstanceBootDiskInitializeParamsArgs(\n            image=\"debian-cloud/debian-11\",\n        ),\n    ),\n    scratch_disks=[gcp.compute.InstanceScratchDiskArgs(\n        interface=\"SCSI\",\n    )],\n    network_interfaces=[gcp.compute.InstanceNetworkInterfaceArgs(\n        network=\"default\",\n        access_configs=[gcp.compute.InstanceNetworkInterfaceAccessConfigArgs()],\n    )],\n    metadata={\n        \"foo\": \"bar\",\n    },\n    metadata_startup_script=\"echo hi \u003e /test.txt\",\n    service_account=gcp.compute.InstanceServiceAccountArgs(\n        email=default_account.email,\n        scopes=[\"cloud-platform\"],\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var defaultAccount = new Gcp.ServiceAccount.Account(\"defaultAccount\", new()\n    {\n        AccountId = \"service_account_id\",\n        DisplayName = \"Service Account\",\n    });\n\n    var defaultInstance = new Gcp.Compute.Instance(\"defaultInstance\", new()\n    {\n        MachineType = \"e2-medium\",\n        Zone = \"us-central1-a\",\n        Tags = new[]\n        {\n            \"foo\",\n            \"bar\",\n        },\n        BootDisk = new Gcp.Compute.Inputs.InstanceBootDiskArgs\n        {\n            InitializeParams = new Gcp.Compute.Inputs.InstanceBootDiskInitializeParamsArgs\n            {\n                Image = \"debian-cloud/debian-11\",\n            },\n        },\n        ScratchDisks = new[]\n        {\n            new Gcp.Compute.Inputs.InstanceScratchDiskArgs\n            {\n                Interface = \"SCSI\",\n            },\n        },\n        NetworkInterfaces = new[]\n        {\n            new Gcp.Compute.Inputs.InstanceNetworkInterfaceArgs\n            {\n                Network = \"default\",\n                AccessConfigs = new[]\n                {\n                    ,\n                },\n            },\n        },\n        Metadata = \n        {\n            { \"foo\", \"bar\" },\n        },\n        MetadataStartupScript = \"echo hi \u003e /test.txt\",\n        ServiceAccount = new Gcp.Compute.Inputs.InstanceServiceAccountArgs\n        {\n            Email = defaultAccount.Email,\n            Scopes = new[]\n            {\n                \"cloud-platform\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/serviceAccount\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdefaultAccount, err := serviceAccount.NewAccount(ctx, \"defaultAccount\", \u0026serviceAccount.AccountArgs{\n\t\t\tAccountId:   pulumi.String(\"service_account_id\"),\n\t\t\tDisplayName: pulumi.String(\"Service Account\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewInstance(ctx, \"defaultInstance\", \u0026compute.InstanceArgs{\n\t\t\tMachineType: pulumi.String(\"e2-medium\"),\n\t\t\tZone:        pulumi.String(\"us-central1-a\"),\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"foo\"),\n\t\t\t\tpulumi.String(\"bar\"),\n\t\t\t},\n\t\t\tBootDisk: \u0026compute.InstanceBootDiskArgs{\n\t\t\t\tInitializeParams: \u0026compute.InstanceBootDiskInitializeParamsArgs{\n\t\t\t\t\tImage: pulumi.String(\"debian-cloud/debian-11\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tScratchDisks: compute.InstanceScratchDiskArray{\n\t\t\t\t\u0026compute.InstanceScratchDiskArgs{\n\t\t\t\t\tInterface: pulumi.String(\"SCSI\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tNetworkInterfaces: compute.InstanceNetworkInterfaceArray{\n\t\t\t\t\u0026compute.InstanceNetworkInterfaceArgs{\n\t\t\t\t\tNetwork: pulumi.String(\"default\"),\n\t\t\t\t\tAccessConfigs: compute.InstanceNetworkInterfaceAccessConfigArray{\n\t\t\t\t\t\tnil,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tMetadata: pulumi.StringMap{\n\t\t\t\t\"foo\": pulumi.String(\"bar\"),\n\t\t\t},\n\t\t\tMetadataStartupScript: pulumi.String(\"echo hi \u003e /test.txt\"),\n\t\t\tServiceAccount: \u0026compute.InstanceServiceAccountArgs{\n\t\t\t\tEmail: defaultAccount.Email,\n\t\t\t\tScopes: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"cloud-platform\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.serviceAccount.Account;\nimport com.pulumi.gcp.serviceAccount.AccountArgs;\nimport com.pulumi.gcp.compute.Instance;\nimport com.pulumi.gcp.compute.InstanceArgs;\nimport com.pulumi.gcp.compute.inputs.InstanceBootDiskArgs;\nimport com.pulumi.gcp.compute.inputs.InstanceBootDiskInitializeParamsArgs;\nimport com.pulumi.gcp.compute.inputs.InstanceScratchDiskArgs;\nimport com.pulumi.gcp.compute.inputs.InstanceNetworkInterfaceArgs;\nimport com.pulumi.gcp.compute.inputs.InstanceServiceAccountArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var defaultAccount = new Account(\"defaultAccount\", AccountArgs.builder()        \n            .accountId(\"service_account_id\")\n            .displayName(\"Service Account\")\n            .build());\n\n        var defaultInstance = new Instance(\"defaultInstance\", InstanceArgs.builder()        \n            .machineType(\"e2-medium\")\n            .zone(\"us-central1-a\")\n            .tags(            \n                \"foo\",\n                \"bar\")\n            .bootDisk(InstanceBootDiskArgs.builder()\n                .initializeParams(InstanceBootDiskInitializeParamsArgs.builder()\n                    .image(\"debian-cloud/debian-11\")\n                    .build())\n                .build())\n            .scratchDisks(InstanceScratchDiskArgs.builder()\n                .interface_(\"SCSI\")\n                .build())\n            .networkInterfaces(InstanceNetworkInterfaceArgs.builder()\n                .network(\"default\")\n                .accessConfigs()\n                .build())\n            .metadata(Map.of(\"foo\", \"bar\"))\n            .metadataStartupScript(\"echo hi \u003e /test.txt\")\n            .serviceAccount(InstanceServiceAccountArgs.builder()\n                .email(defaultAccount.email())\n                .scopes(\"cloud-platform\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  defaultAccount:\n    type: gcp:serviceAccount:Account\n    properties:\n      accountId: service_account_id\n      displayName: Service Account\n  defaultInstance:\n    type: gcp:compute:Instance\n    properties:\n      machineType: e2-medium\n      zone: us-central1-a\n      tags:\n        - foo\n        - bar\n      bootDisk:\n        initializeParams:\n          image: debian-cloud/debian-11\n      # Local SSD disk\n      scratchDisks:\n        - interface: SCSI\n      networkInterfaces:\n        - network: default\n          accessConfigs:\n            - {}\n      metadata:\n        foo: bar\n      metadataStartupScript: echo hi \u003e /test.txt\n      serviceAccount:\n        email: ${defaultAccount.email}\n        scopes:\n          - cloud-platform\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nInstances can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:compute/instance:Instance default projects/{{project}}/zones/{{zone}}/instances/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:compute/instance:Instance default {{project}}/{{zone}}/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:compute/instance:Instance default {{name}}\n```\n\n [custom-vm-types]https://cloud.google.com/dataproc/docs/concepts/compute/custom-machine-types [network-tier]https://cloud.google.com/network-tiers/docs/overview [extended-custom-vm-type]https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#extendedmemory ",
      "properties": {
        "advancedMachineFeatures": {
          "$ref": "#/types/gcp:compute/InstanceAdvancedMachineFeatures:InstanceAdvancedMachineFeatures",
          "description": "Configure Nested Virtualisation and Simultaneous Hyper Threading  on this VM. Structure is documented below\n"
        },
        "allowStoppingForUpdate": {
          "type": "boolean",
          "description": "If true, allows this prvider to stop the instance to update its properties.\nIf you try to update a property that requires stopping the instance without setting this field, the update will fail.\n"
        },
        "attachedDisks": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceAttachedDisk:InstanceAttachedDisk"
          },
          "description": "Additional disks to attach to the instance. Can be repeated multiple times for multiple disks. Structure is documented below.\n"
        },
        "bootDisk": {
          "$ref": "#/types/gcp:compute/InstanceBootDisk:InstanceBootDisk",
          "description": "The boot disk for the instance.\nStructure is documented below.\n"
        },
        "canIpForward": {
          "type": "boolean",
          "description": "Whether to allow sending and receiving of\npackets with non-matching source or destination IPs.\nThis defaults to false.\n"
        },
        "confidentialInstanceConfig": {
          "$ref": "#/types/gcp:compute/InstanceConfidentialInstanceConfig:InstanceConfidentialInstanceConfig",
          "description": "Enable [Confidential Mode](https://cloud.google.com/compute/confidential-vm/docs/about-cvm) on this VM. Structure is documented below\n"
        },
        "cpuPlatform": {
          "type": "string",
          "description": "The CPU platform used by this instance.\n"
        },
        "currentStatus": {
          "type": "string",
          "description": "Current status of the instance.\n"
        },
        "deletionProtection": {
          "type": "boolean",
          "description": "Enable deletion protection on this instance. Defaults to false.\n**Note:** you must disable deletion protection before removing the resource (e.g., via `pulumi destroy`), or the instance cannot be deleted and the provider run will not complete successfully.\n"
        },
        "description": {
          "type": "string",
          "description": "A brief description of this resource.\n"
        },
        "desiredStatus": {
          "type": "string",
          "description": "Desired status of the instance. Either\n`\"RUNNING\"` or `\"TERMINATED\"`.\n"
        },
        "enableDisplay": {
          "type": "boolean",
          "description": "Enable [Virtual Displays](https://cloud.google.com/compute/docs/instances/enable-instance-virtual-display#verify_display_driver) on this instance.\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
        },
        "guestAccelerators": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceGuestAccelerator:InstanceGuestAccelerator"
          },
          "description": "List of the type and count of accelerator cards attached to the instance. Structure documented below.\n**Note:** GPU accelerators can only be used with `on_host_maintenance` option set to TERMINATE.\n"
        },
        "hostname": {
          "type": "string",
          "description": "A custom hostname for the instance. Must be a fully qualified DNS name and RFC-1035-valid.\nValid format is a series of labels 1-63 characters long matching the regular expression `a-z`, concatenated with periods.\nThe entire hostname must not exceed 253 characters. Changing this forces a new resource to be created.\n"
        },
        "instanceId": {
          "type": "string",
          "description": "The server-assigned unique identifier of this instance.\n"
        },
        "labelFingerprint": {
          "type": "string",
          "description": "The unique fingerprint of the labels.\n"
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A map of key/value label pairs to assign to the instance.\n"
        },
        "machineType": {
          "type": "string",
          "description": "The machine type to create.\n"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Metadata key/value pairs to make available from\nwithin the instance. Ssh keys attached in the Cloud Console will be removed.\nAdd them to your config in order to keep them attached to your instance.\n"
        },
        "metadataFingerprint": {
          "type": "string",
          "description": "The unique fingerprint of the metadata.\n"
        },
        "metadataStartupScript": {
          "type": "string",
          "description": "An alternative to using the\nstartup-script metadata key, except this one forces the instance to be recreated\n(thus re-running the script) if it is changed. This replaces the startup-script\nmetadata key on the created instance and thus the two mechanisms are not\nallowed to be used simultaneously.  Users are free to use either mechanism - the\nonly distinction is that this separate attribute will cause a recreate on\nmodification.  On import, `metadata_startup_script` will not be set - if you\nchoose to specify it you will see a diff immediately after import causing a\ndestroy/recreate operation. If importing an instance and specifying this value\nis desired, you will need to modify your state file.\n"
        },
        "minCpuPlatform": {
          "type": "string",
          "description": "Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms, such as\n`Intel Haswell` or `Intel Skylake`. See the complete list [here](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform).\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
        },
        "name": {
          "type": "string",
          "description": "A unique name for the resource, required by GCE.\nChanging this forces a new resource to be created.\n"
        },
        "networkInterfaces": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceNetworkInterface:InstanceNetworkInterface"
          },
          "description": "Networks to attach to the instance. This can\nbe specified multiple times. Structure is documented below.\n"
        },
        "networkPerformanceConfig": {
          "$ref": "#/types/gcp:compute/InstanceNetworkPerformanceConfig:InstanceNetworkPerformanceConfig",
          "description": "Configures network performance settings for the instance. Structure is\ndocumented below. **Note**: `machine_type` must be a [supported type](https://cloud.google.com/compute/docs/networking/configure-vm-with-high-bandwidth-configuration),\nthe `image` used must include the [`GVNIC`](https://cloud.google.com/compute/docs/networking/using-gvnic#create-instance-gvnic-image)\nin `guest-os-features`, and `network_interface.0.nic-type` must be `GVNIC`\nin order for this setting to take effect.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs. If it\nis not provided, the provider project is used.\n"
        },
        "reservationAffinity": {
          "$ref": "#/types/gcp:compute/InstanceReservationAffinity:InstanceReservationAffinity",
          "description": "Specifies the reservations that this instance can consume from.\nStructure is documented below.\n"
        },
        "resourcePolicies": {
          "type": "string",
          "description": "-- A list of self_links of resource policies to attach to the instance. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.\n"
        },
        "scheduling": {
          "$ref": "#/types/gcp:compute/InstanceScheduling:InstanceScheduling",
          "description": "The scheduling strategy to use. More details about\nthis configuration option are detailed below.\n"
        },
        "scratchDisks": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceScratchDisk:InstanceScratchDisk"
          },
          "description": "Scratch disks to attach to the instance. This can be\nspecified multiple times for multiple scratch disks. Structure is documented below.\n"
        },
        "selfLink": {
          "type": "string",
          "description": "The URI of the created resource.\n"
        },
        "serviceAccount": {
          "$ref": "#/types/gcp:compute/InstanceServiceAccount:InstanceServiceAccount",
          "description": "Service account to attach to the instance.\nStructure is documented below.\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
        },
        "shieldedInstanceConfig": {
          "$ref": "#/types/gcp:compute/InstanceShieldedInstanceConfig:InstanceShieldedInstanceConfig",
          "description": "Enable [Shielded VM](https://cloud.google.com/security/shielded-cloud/shielded-vm) on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.\n**Note**: `shielded_instance_config` can only be used with boot images with shielded vm support. See the complete list [here](https://cloud.google.com/compute/docs/images#shielded-images).\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of network tags to attach to the instance.\n"
        },
        "tagsFingerprint": {
          "type": "string",
          "description": "The unique fingerprint of the tags.\n"
        },
        "zone": {
          "type": "string",
          "description": "The zone that the machine should be created in. If it is not provided, the provider zone is used.\n"
        }
      },
      "required": [
        "bootDisk",
        "confidentialInstanceConfig",
        "cpuPlatform",
        "currentStatus",
        "guestAccelerators",
        "instanceId",
        "labelFingerprint",
        "machineType",
        "metadataFingerprint",
        "minCpuPlatform",
        "name",
        "networkInterfaces",
        "project",
        "reservationAffinity",
        "scheduling",
        "selfLink",
        "shieldedInstanceConfig",
        "tagsFingerprint",
        "zone"
      ],
      "inputProperties": {
        "advancedMachineFeatures": {
          "$ref": "#/types/gcp:compute/InstanceAdvancedMachineFeatures:InstanceAdvancedMachineFeatures",
          "description": "Configure Nested Virtualisation and Simultaneous Hyper Threading  on this VM. Structure is documented below\n"
        },
        "allowStoppingForUpdate": {
          "type": "boolean",
          "description": "If true, allows this prvider to stop the instance to update its properties.\nIf you try to update a property that requires stopping the instance without setting this field, the update will fail.\n"
        },
        "attachedDisks": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceAttachedDisk:InstanceAttachedDisk"
          },
          "description": "Additional disks to attach to the instance. Can be repeated multiple times for multiple disks. Structure is documented below.\n"
        },
        "bootDisk": {
          "$ref": "#/types/gcp:compute/InstanceBootDisk:InstanceBootDisk",
          "description": "The boot disk for the instance.\nStructure is documented below.\n",
          "willReplaceOnChanges": true
        },
        "canIpForward": {
          "type": "boolean",
          "description": "Whether to allow sending and receiving of\npackets with non-matching source or destination IPs.\nThis defaults to false.\n"
        },
        "confidentialInstanceConfig": {
          "$ref": "#/types/gcp:compute/InstanceConfidentialInstanceConfig:InstanceConfidentialInstanceConfig",
          "description": "Enable [Confidential Mode](https://cloud.google.com/compute/confidential-vm/docs/about-cvm) on this VM. Structure is documented below\n",
          "willReplaceOnChanges": true
        },
        "deletionProtection": {
          "type": "boolean",
          "description": "Enable deletion protection on this instance. Defaults to false.\n**Note:** you must disable deletion protection before removing the resource (e.g., via `pulumi destroy`), or the instance cannot be deleted and the provider run will not complete successfully.\n"
        },
        "description": {
          "type": "string",
          "description": "A brief description of this resource.\n",
          "willReplaceOnChanges": true
        },
        "desiredStatus": {
          "type": "string",
          "description": "Desired status of the instance. Either\n`\"RUNNING\"` or `\"TERMINATED\"`.\n"
        },
        "enableDisplay": {
          "type": "boolean",
          "description": "Enable [Virtual Displays](https://cloud.google.com/compute/docs/instances/enable-instance-virtual-display#verify_display_driver) on this instance.\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
        },
        "guestAccelerators": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceGuestAccelerator:InstanceGuestAccelerator"
          },
          "description": "List of the type and count of accelerator cards attached to the instance. Structure documented below.\n**Note:** GPU accelerators can only be used with `on_host_maintenance` option set to TERMINATE.\n",
          "willReplaceOnChanges": true
        },
        "hostname": {
          "type": "string",
          "description": "A custom hostname for the instance. Must be a fully qualified DNS name and RFC-1035-valid.\nValid format is a series of labels 1-63 characters long matching the regular expression `a-z`, concatenated with periods.\nThe entire hostname must not exceed 253 characters. Changing this forces a new resource to be created.\n",
          "willReplaceOnChanges": true
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A map of key/value label pairs to assign to the instance.\n"
        },
        "machineType": {
          "type": "string",
          "description": "The machine type to create.\n"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Metadata key/value pairs to make available from\nwithin the instance. Ssh keys attached in the Cloud Console will be removed.\nAdd them to your config in order to keep them attached to your instance.\n"
        },
        "metadataStartupScript": {
          "type": "string",
          "description": "An alternative to using the\nstartup-script metadata key, except this one forces the instance to be recreated\n(thus re-running the script) if it is changed. This replaces the startup-script\nmetadata key on the created instance and thus the two mechanisms are not\nallowed to be used simultaneously.  Users are free to use either mechanism - the\nonly distinction is that this separate attribute will cause a recreate on\nmodification.  On import, `metadata_startup_script` will not be set - if you\nchoose to specify it you will see a diff immediately after import causing a\ndestroy/recreate operation. If importing an instance and specifying this value\nis desired, you will need to modify your state file.\n",
          "willReplaceOnChanges": true
        },
        "minCpuPlatform": {
          "type": "string",
          "description": "Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms, such as\n`Intel Haswell` or `Intel Skylake`. See the complete list [here](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform).\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
        },
        "name": {
          "type": "string",
          "description": "A unique name for the resource, required by GCE.\nChanging this forces a new resource to be created.\n",
          "willReplaceOnChanges": true
        },
        "networkInterfaces": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceNetworkInterface:InstanceNetworkInterface"
          },
          "description": "Networks to attach to the instance. This can\nbe specified multiple times. Structure is documented below.\n",
          "willReplaceOnChanges": true
        },
        "networkPerformanceConfig": {
          "$ref": "#/types/gcp:compute/InstanceNetworkPerformanceConfig:InstanceNetworkPerformanceConfig",
          "description": "Configures network performance settings for the instance. Structure is\ndocumented below. **Note**: `machine_type` must be a [supported type](https://cloud.google.com/compute/docs/networking/configure-vm-with-high-bandwidth-configuration),\nthe `image` used must include the [`GVNIC`](https://cloud.google.com/compute/docs/networking/using-gvnic#create-instance-gvnic-image)\nin `guest-os-features`, and `network_interface.0.nic-type` must be `GVNIC`\nin order for this setting to take effect.\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs. If it\nis not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        },
        "reservationAffinity": {
          "$ref": "#/types/gcp:compute/InstanceReservationAffinity:InstanceReservationAffinity",
          "description": "Specifies the reservations that this instance can consume from.\nStructure is documented below.\n",
          "willReplaceOnChanges": true
        },
        "resourcePolicies": {
          "type": "string",
          "description": "-- A list of self_links of resource policies to attach to the instance. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.\n"
        },
        "scheduling": {
          "$ref": "#/types/gcp:compute/InstanceScheduling:InstanceScheduling",
          "description": "The scheduling strategy to use. More details about\nthis configuration option are detailed below.\n"
        },
        "scratchDisks": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceScratchDisk:InstanceScratchDisk"
          },
          "description": "Scratch disks to attach to the instance. This can be\nspecified multiple times for multiple scratch disks. Structure is documented below.\n",
          "willReplaceOnChanges": true
        },
        "serviceAccount": {
          "$ref": "#/types/gcp:compute/InstanceServiceAccount:InstanceServiceAccount",
          "description": "Service account to attach to the instance.\nStructure is documented below.\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
        },
        "shieldedInstanceConfig": {
          "$ref": "#/types/gcp:compute/InstanceShieldedInstanceConfig:InstanceShieldedInstanceConfig",
          "description": "Enable [Shielded VM](https://cloud.google.com/security/shielded-cloud/shielded-vm) on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.\n**Note**: `shielded_instance_config` can only be used with boot images with shielded vm support. See the complete list [here](https://cloud.google.com/compute/docs/images#shielded-images).\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of network tags to attach to the instance.\n"
        },
        "zone": {
          "type": "string",
          "description": "The zone that the machine should be created in. If it is not provided, the provider zone is used.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "bootDisk",
        "machineType",
        "networkInterfaces"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Instance resources.\n",
        "properties": {
          "advancedMachineFeatures": {
            "$ref": "#/types/gcp:compute/InstanceAdvancedMachineFeatures:InstanceAdvancedMachineFeatures",
            "description": "Configure Nested Virtualisation and Simultaneous Hyper Threading  on this VM. Structure is documented below\n"
          },
          "allowStoppingForUpdate": {
            "type": "boolean",
            "description": "If true, allows this prvider to stop the instance to update its properties.\nIf you try to update a property that requires stopping the instance without setting this field, the update will fail.\n"
          },
          "attachedDisks": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:compute/InstanceAttachedDisk:InstanceAttachedDisk"
            },
            "description": "Additional disks to attach to the instance. Can be repeated multiple times for multiple disks. Structure is documented below.\n"
          },
          "bootDisk": {
            "$ref": "#/types/gcp:compute/InstanceBootDisk:InstanceBootDisk",
            "description": "The boot disk for the instance.\nStructure is documented below.\n",
            "willReplaceOnChanges": true
          },
          "canIpForward": {
            "type": "boolean",
            "description": "Whether to allow sending and receiving of\npackets with non-matching source or destination IPs.\nThis defaults to false.\n"
          },
          "confidentialInstanceConfig": {
            "$ref": "#/types/gcp:compute/InstanceConfidentialInstanceConfig:InstanceConfidentialInstanceConfig",
            "description": "Enable [Confidential Mode](https://cloud.google.com/compute/confidential-vm/docs/about-cvm) on this VM. Structure is documented below\n",
            "willReplaceOnChanges": true
          },
          "cpuPlatform": {
            "type": "string",
            "description": "The CPU platform used by this instance.\n"
          },
          "currentStatus": {
            "type": "string",
            "description": "Current status of the instance.\n"
          },
          "deletionProtection": {
            "type": "boolean",
            "description": "Enable deletion protection on this instance. Defaults to false.\n**Note:** you must disable deletion protection before removing the resource (e.g., via `pulumi destroy`), or the instance cannot be deleted and the provider run will not complete successfully.\n"
          },
          "description": {
            "type": "string",
            "description": "A brief description of this resource.\n",
            "willReplaceOnChanges": true
          },
          "desiredStatus": {
            "type": "string",
            "description": "Desired status of the instance. Either\n`\"RUNNING\"` or `\"TERMINATED\"`.\n"
          },
          "enableDisplay": {
            "type": "boolean",
            "description": "Enable [Virtual Displays](https://cloud.google.com/compute/docs/instances/enable-instance-virtual-display#verify_display_driver) on this instance.\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
          },
          "guestAccelerators": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:compute/InstanceGuestAccelerator:InstanceGuestAccelerator"
            },
            "description": "List of the type and count of accelerator cards attached to the instance. Structure documented below.\n**Note:** GPU accelerators can only be used with `on_host_maintenance` option set to TERMINATE.\n",
            "willReplaceOnChanges": true
          },
          "hostname": {
            "type": "string",
            "description": "A custom hostname for the instance. Must be a fully qualified DNS name and RFC-1035-valid.\nValid format is a series of labels 1-63 characters long matching the regular expression `a-z`, concatenated with periods.\nThe entire hostname must not exceed 253 characters. Changing this forces a new resource to be created.\n",
            "willReplaceOnChanges": true
          },
          "instanceId": {
            "type": "string",
            "description": "The server-assigned unique identifier of this instance.\n"
          },
          "labelFingerprint": {
            "type": "string",
            "description": "The unique fingerprint of the labels.\n"
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "A map of key/value label pairs to assign to the instance.\n"
          },
          "machineType": {
            "type": "string",
            "description": "The machine type to create.\n"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Metadata key/value pairs to make available from\nwithin the instance. Ssh keys attached in the Cloud Console will be removed.\nAdd them to your config in order to keep them attached to your instance.\n"
          },
          "metadataFingerprint": {
            "type": "string",
            "description": "The unique fingerprint of the metadata.\n"
          },
          "metadataStartupScript": {
            "type": "string",
            "description": "An alternative to using the\nstartup-script metadata key, except this one forces the instance to be recreated\n(thus re-running the script) if it is changed. This replaces the startup-script\nmetadata key on the created instance and thus the two mechanisms are not\nallowed to be used simultaneously.  Users are free to use either mechanism - the\nonly distinction is that this separate attribute will cause a recreate on\nmodification.  On import, `metadata_startup_script` will not be set - if you\nchoose to specify it you will see a diff immediately after import causing a\ndestroy/recreate operation. If importing an instance and specifying this value\nis desired, you will need to modify your state file.\n",
            "willReplaceOnChanges": true
          },
          "minCpuPlatform": {
            "type": "string",
            "description": "Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms, such as\n`Intel Haswell` or `Intel Skylake`. See the complete list [here](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform).\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
          },
          "name": {
            "type": "string",
            "description": "A unique name for the resource, required by GCE.\nChanging this forces a new resource to be created.\n",
            "willReplaceOnChanges": true
          },
          "networkInterfaces": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:compute/InstanceNetworkInterface:InstanceNetworkInterface"
            },
            "description": "Networks to attach to the instance. This can\nbe specified multiple times. Structure is documented below.\n",
            "willReplaceOnChanges": true
          },
          "networkPerformanceConfig": {
            "$ref": "#/types/gcp:compute/InstanceNetworkPerformanceConfig:InstanceNetworkPerformanceConfig",
            "description": "Configures network performance settings for the instance. Structure is\ndocumented below. **Note**: `machine_type` must be a [supported type](https://cloud.google.com/compute/docs/networking/configure-vm-with-high-bandwidth-configuration),\nthe `image` used must include the [`GVNIC`](https://cloud.google.com/compute/docs/networking/using-gvnic#create-instance-gvnic-image)\nin `guest-os-features`, and `network_interface.0.nic-type` must be `GVNIC`\nin order for this setting to take effect.\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs. If it\nis not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          },
          "reservationAffinity": {
            "$ref": "#/types/gcp:compute/InstanceReservationAffinity:InstanceReservationAffinity",
            "description": "Specifies the reservations that this instance can consume from.\nStructure is documented below.\n",
            "willReplaceOnChanges": true
          },
          "resourcePolicies": {
            "type": "string",
            "description": "-- A list of self_links of resource policies to attach to the instance. Modifying this list will cause the instance to recreate. Currently a max of 1 resource policy is supported.\n"
          },
          "scheduling": {
            "$ref": "#/types/gcp:compute/InstanceScheduling:InstanceScheduling",
            "description": "The scheduling strategy to use. More details about\nthis configuration option are detailed below.\n"
          },
          "scratchDisks": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:compute/InstanceScratchDisk:InstanceScratchDisk"
            },
            "description": "Scratch disks to attach to the instance. This can be\nspecified multiple times for multiple scratch disks. Structure is documented below.\n",
            "willReplaceOnChanges": true
          },
          "selfLink": {
            "type": "string",
            "description": "The URI of the created resource.\n"
          },
          "serviceAccount": {
            "$ref": "#/types/gcp:compute/InstanceServiceAccount:InstanceServiceAccount",
            "description": "Service account to attach to the instance.\nStructure is documented below.\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
          },
          "shieldedInstanceConfig": {
            "$ref": "#/types/gcp:compute/InstanceShieldedInstanceConfig:InstanceShieldedInstanceConfig",
            "description": "Enable [Shielded VM](https://cloud.google.com/security/shielded-cloud/shielded-vm) on this instance. Shielded VM provides verifiable integrity to prevent against malware and rootkits. Defaults to disabled. Structure is documented below.\n**Note**: `shielded_instance_config` can only be used with boot images with shielded vm support. See the complete list [here](https://cloud.google.com/compute/docs/images#shielded-images).\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of network tags to attach to the instance.\n"
          },
          "tagsFingerprint": {
            "type": "string",
            "description": "The unique fingerprint of the tags.\n"
          },
          "zone": {
            "type": "string",
            "description": "The zone that the machine should be created in. If it is not provided, the provider zone is used.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:bigtable/instance:Instance": {
      "description": "## +---\n\nsubcategory: \"Cloud Bigtable\"\npage_title: \"Google: gcp.bigtable.Instance\"\ndescription: |-\n  Creates a Google Bigtable instance.\n---\n\n# gcp.bigtable.Instance\n\nCreates a Google Bigtable instance. For more information see:\n\n* [API documentation](https://cloud.google.com/bigtable/docs/reference/admin/rest/v2/projects.instances.clusters)\n* How-to Guides\n    * [Official Documentation](https://cloud.google.com/bigtable/docs)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Simple Instance\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst production_instance = new gcp.bigtable.Instance(\"production-instance\", {\n    clusters: [{\n        clusterId: \"tf-instance-cluster\",\n        numNodes: 1,\n        storageType: \"HDD\",\n    }],\n    labels: {\n        \"my-label\": \"prod-label\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nproduction_instance = gcp.bigtable.Instance(\"production-instance\",\n    clusters=[gcp.bigtable.InstanceClusterArgs(\n        cluster_id=\"tf-instance-cluster\",\n        num_nodes=1,\n        storage_type=\"HDD\",\n    )],\n    labels={\n        \"my-label\": \"prod-label\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var production_instance = new Gcp.BigTable.Instance(\"production-instance\", new()\n    {\n        Clusters = new[]\n        {\n            new Gcp.BigTable.Inputs.InstanceClusterArgs\n            {\n                ClusterId = \"tf-instance-cluster\",\n                NumNodes = 1,\n                StorageType = \"HDD\",\n            },\n        },\n        Labels = \n        {\n            { \"my-label\", \"prod-label\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigtable\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := bigtable.NewInstance(ctx, \"production-instance\", &bigtable.InstanceArgs{\n\t\t\tClusters: bigtable.InstanceClusterArray{\n\t\t\t\t&bigtable.InstanceClusterArgs{\n\t\t\t\t\tClusterId:   pulumi.String(\"tf-instance-cluster\"),\n\t\t\t\t\tNumNodes:    pulumi.Int(1),\n\t\t\t\t\tStorageType: pulumi.String(\"HDD\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"my-label\": pulumi.String(\"prod-label\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigtable.Instance;\nimport com.pulumi.gcp.bigtable.InstanceArgs;\nimport com.pulumi.gcp.bigtable.inputs.InstanceClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var production_instance = new Instance(\"production-instance\", InstanceArgs.builder()        \n            .clusters(InstanceClusterArgs.builder()\n                .clusterId(\"tf-instance-cluster\")\n                .numNodes(1)\n                .storageType(\"HDD\")\n                .build())\n            .labels(Map.of(\"my-label\", \"prod-label\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  production-instance:\n    type: gcp:bigtable:Instance\n    properties:\n      clusters:\n        - clusterId: tf-instance-cluster\n          numNodes: 1\n          storageType: HDD\n      labels:\n        my-label: prod-label\n```\n{{% /example %}}\n{{% example %}}\n### Replicated Instance\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst production_instance = new gcp.bigtable.Instance(\"production-instance\", {\n    clusters: [\n        // A cluster with fixed number of nodes.\n        {\n            clusterId: \"tf-instance-cluster1\",\n            numNodes: 1,\n            storageType: \"HDD\",\n            zone: \"us-central1-c\",\n        },\n        // a cluster with auto scaling.\n        {\n            autoscalingConfig: {\n                cpuTarget: 50,\n                maxNodes: 3,\n                minNodes: 1,\n            },\n            clusterId: \"tf-instance-cluster2\",\n            storageType: \"HDD\",\n            zone: \"us-central1-b\",\n        },\n    ],\n    labels: {\n        \"my-label\": \"prod-label\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nproduction_instance = gcp.bigtable.Instance(\"production-instance\",\n    clusters=[\n        gcp.bigtable.InstanceClusterArgs(\n            cluster_id=\"tf-instance-cluster1\",\n            num_nodes=1,\n            storage_type=\"HDD\",\n            zone=\"us-central1-c\",\n        ),\n        gcp.bigtable.InstanceClusterArgs(\n            autoscaling_config=gcp.bigtable.InstanceClusterAutoscalingConfigArgs(\n                cpu_target=50,\n                max_nodes=3,\n                min_nodes=1,\n            ),\n            cluster_id=\"tf-instance-cluster2\",\n            storage_type=\"HDD\",\n            zone=\"us-central1-b\",\n        ),\n    ],\n    labels={\n        \"my-label\": \"prod-label\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var production_instance = new Gcp.BigTable.Instance(\"production-instance\", new()\n    {\n        Clusters = new[]\n        {\n            new Gcp.BigTable.Inputs.InstanceClusterArgs\n            {\n                ClusterId = \"tf-instance-cluster1\",\n                NumNodes = 1,\n                StorageType = \"HDD\",\n                Zone = \"us-central1-c\",\n            },\n            new Gcp.BigTable.Inputs.InstanceClusterArgs\n            {\n                AutoscalingConfig = new Gcp.BigTable.Inputs.InstanceClusterAutoscalingConfigArgs\n                {\n                    CpuTarget = 50,\n                    MaxNodes = 3,\n                    MinNodes = 1,\n                },\n                ClusterId = \"tf-instance-cluster2\",\n                StorageType = \"HDD\",\n                Zone = \"us-central1-b\",\n            },\n        },\n        Labels = \n        {\n            { \"my-label\", \"prod-label\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigtable\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := bigtable.NewInstance(ctx, \"production-instance\", &bigtable.InstanceArgs{\n\t\t\tClusters: bigtable.InstanceClusterArray{\n\t\t\t\t&bigtable.InstanceClusterArgs{\n\t\t\t\t\tClusterId:   pulumi.String(\"tf-instance-cluster1\"),\n\t\t\t\t\tNumNodes:    pulumi.Int(1),\n\t\t\t\t\tStorageType: pulumi.String(\"HDD\"),\n\t\t\t\t\tZone:        pulumi.String(\"us-central1-c\"),\n\t\t\t\t},\n\t\t\t\t&bigtable.InstanceClusterArgs{\n\t\t\t\t\tAutoscalingConfig: &bigtable.InstanceClusterAutoscalingConfigArgs{\n\t\t\t\t\t\tCpuTarget: pulumi.Int(50),\n\t\t\t\t\t\tMaxNodes:  pulumi.Int(3),\n\t\t\t\t\t\tMinNodes:  pulumi.Int(1),\n\t\t\t\t\t},\n\t\t\t\t\tClusterId:   pulumi.String(\"tf-instance-cluster2\"),\n\t\t\t\t\tStorageType: pulumi.String(\"HDD\"),\n\t\t\t\t\tZone:        pulumi.String(\"us-central1-b\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"my-label\": pulumi.String(\"prod-label\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigtable.Instance;\nimport com.pulumi.gcp.bigtable.InstanceArgs;\nimport com.pulumi.gcp.bigtable.inputs.InstanceClusterArgs;\nimport com.pulumi.gcp.bigtable.inputs.InstanceClusterAutoscalingConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var production_instance = new Instance(\"production-instance\", InstanceArgs.builder()        \n            .clusters(            \n                InstanceClusterArgs.builder()\n                    .clusterId(\"tf-instance-cluster1\")\n                    .numNodes(1)\n                    .storageType(\"HDD\")\n                    .zone(\"us-central1-c\")\n                    .build(),\n                InstanceClusterArgs.builder()\n                    .autoscalingConfig(InstanceClusterAutoscalingConfigArgs.builder()\n                        .cpuTarget(50)\n                        .maxNodes(3)\n                        .minNodes(1)\n                        .build())\n                    .clusterId(\"tf-instance-cluster2\")\n                    .storageType(\"HDD\")\n                    .zone(\"us-central1-b\")\n                    .build())\n            .labels(Map.of(\"my-label\", \"prod-label\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  production-instance:\n    type: gcp:bigtable:Instance\n    properties:\n      clusters:\n        - clusterId: tf-instance-cluster1\n          numNodes: 1\n          storageType: HDD\n          zone: us-central1-c\n        - autoscalingConfig:\n            cpuTarget: 50\n            maxNodes: 3\n            minNodes: 1\n          clusterId: tf-instance-cluster2\n          storageType: HDD\n          zone: us-central1-b\n      labels:\n        my-label: prod-label\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBigtable Instances can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:bigtable/instance:Instance default projects/{{project}}/instances/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:bigtable/instance:Instance default {{project}}/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:bigtable/instance:Instance default {{name}}\n```\n\n ",
      "properties": {
        "clusters": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:bigtable/InstanceCluster:InstanceCluster"
          },
          "description": "A block of cluster configuration options. This can be specified at least once, and up to 4 times.\nSee structure below.\n"
        },
        "deletionProtection": {
          "type": "boolean",
          "description": "Whether or not to allow this provider to destroy the instance. Unless this field is set to false\nin the statefile, a `pulumi destroy` or `pulumi up` that would delete the instance will fail.\n"
        },
        "displayName": {
          "type": "string",
          "description": "The human-readable display name of the Bigtable instance. Defaults to the instance `name`.\n"
        },
        "instanceType": {
          "type": "string",
          "description": "The instance type to create. One of `\"DEVELOPMENT\"` or `\"PRODUCTION\"`. Defaults to `\"PRODUCTION\"`.\nIt is recommended to leave this field unspecified since the distinction between `\"DEVELOPMENT\"` and `\"PRODUCTION\"` instances is going away,\nand all instances will become `\"PRODUCTION\"` instances. This means that new and existing `\"DEVELOPMENT\"` instances will be converted to\n`\"PRODUCTION\"` instances. It is recommended for users to use `\"PRODUCTION\"` instances in any case, since a 1-node `\"PRODUCTION\"` instance\nis functionally identical to a `\"DEVELOPMENT\"` instance, but without the accompanying restrictions.\n",
          "deprecationMessage": "It is recommended to leave this field unspecified since the distinction between \"DEVELOPMENT\" and \"PRODUCTION\" instances is going away, and all instances will become \"PRODUCTION\" instances. This means that new and existing \"DEVELOPMENT\" instances will be converted to \"PRODUCTION\" instances. It is recommended for users to use \"PRODUCTION\" instances in any case, since a 1-node \"PRODUCTION\" instance is functionally identical to a \"DEVELOPMENT\" instance, but without the accompanying restrictions."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A set of key/value label pairs to assign to the resource. Label keys must follow the requirements at https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements.\n"
        },
        "name": {
          "type": "string",
          "description": "The name (also called Instance Id in the Cloud Console) of the Cloud Bigtable instance.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs. If it\nis not provided, the provider project is used.\n"
        }
      },
      "required": [
        "clusters",
        "displayName",
        "name",
        "project"
      ],
      "inputProperties": {
        "clusters": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:bigtable/InstanceCluster:InstanceCluster"
          },
          "description": "A block of cluster configuration options. This can be specified at least once, and up to 4 times.\nSee structure below.\n"
        },
        "deletionProtection": {
          "type": "boolean",
          "description": "Whether or not to allow this provider to destroy the instance. Unless this field is set to false\nin the statefile, a `pulumi destroy` or `pulumi up` that would delete the instance will fail.\n"
        },
        "displayName": {
          "type": "string",
          "description": "The human-readable display name of the Bigtable instance. Defaults to the instance `name`.\n"
        },
        "instanceType": {
          "type": "string",
          "description": "The instance type to create. One of `\"DEVELOPMENT\"` or `\"PRODUCTION\"`. Defaults to `\"PRODUCTION\"`.\nIt is recommended to leave this field unspecified since the distinction between `\"DEVELOPMENT\"` and `\"PRODUCTION\"` instances is going away,\nand all instances will become `\"PRODUCTION\"` instances. This means that new and existing `\"DEVELOPMENT\"` instances will be converted to\n`\"PRODUCTION\"` instances. It is recommended for users to use `\"PRODUCTION\"` instances in any case, since a 1-node `\"PRODUCTION\"` instance\nis functionally identical to a `\"DEVELOPMENT\"` instance, but without the accompanying restrictions.\n",
          "deprecationMessage": "It is recommended to leave this field unspecified since the distinction between \"DEVELOPMENT\" and \"PRODUCTION\" instances is going away, and all instances will become \"PRODUCTION\" instances. This means that new and existing \"DEVELOPMENT\" instances will be converted to \"PRODUCTION\" instances. It is recommended for users to use \"PRODUCTION\" instances in any case, since a 1-node \"PRODUCTION\" instance is functionally identical to a \"DEVELOPMENT\" instance, but without the accompanying restrictions."
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A set of key/value label pairs to assign to the resource. Label keys must follow the requirements at https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements.\n"
        },
        "name": {
          "type": "string",
          "description": "The name (also called Instance Id in the Cloud Console) of the Cloud Bigtable instance.\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs. If it\nis not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Instance resources.\n",
        "properties": {
          "clusters": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:bigtable/InstanceCluster:InstanceCluster"
            },
            "description": "A block of cluster configuration options. This can be specified at least once, and up to 4 times.\nSee structure below.\n"
          },
          "deletionProtection": {
            "type": "boolean",
            "description": "Whether or not to allow this provider to destroy the instance. Unless this field is set to false\nin the statefile, a `pulumi destroy` or `pulumi up` that would delete the instance will fail.\n"
          },
          "displayName": {
            "type": "string",
            "description": "The human-readable display name of the Bigtable instance. Defaults to the instance `name`.\n"
          },
          "instanceType": {
            "type": "string",
            "description": "The instance type to create. One of `\"DEVELOPMENT\"` or `\"PRODUCTION\"`. Defaults to `\"PRODUCTION\"`.\nIt is recommended to leave this field unspecified since the distinction between `\"DEVELOPMENT\"` and `\"PRODUCTION\"` instances is going away,\nand all instances will become `\"PRODUCTION\"` instances. This means that new and existing `\"DEVELOPMENT\"` instances will be converted to\n`\"PRODUCTION\"` instances. It is recommended for users to use `\"PRODUCTION\"` instances in any case, since a 1-node `\"PRODUCTION\"` instance\nis functionally identical to a `\"DEVELOPMENT\"` instance, but without the accompanying restrictions.\n",
            "deprecationMessage": "It is recommended to leave this field unspecified since the distinction between \"DEVELOPMENT\" and \"PRODUCTION\" instances is going away, and all instances will become \"PRODUCTION\" instances. This means that new and existing \"DEVELOPMENT\" instances will be converted to \"PRODUCTION\" instances. It is recommended for users to use \"PRODUCTION\" instances in any case, since a 1-node \"PRODUCTION\" instance is functionally identical to a \"DEVELOPMENT\" instance, but without the accompanying restrictions."
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "A set of key/value label pairs to assign to the resource. Label keys must follow the requirements at https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements.\n"
          },
          "name": {
            "type": "string",
            "description": "The name (also called Instance Id in the Cloud Console) of the Cloud Bigtable instance.\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs. If it\nis not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:bigtable/table:Table": {
      "description": "Creates a Google Cloud Bigtable table inside an instance. For more information see\n[the official documentation](https://cloud.google.com/bigtable/) and\n[API](https://cloud.google.com/bigtable/docs/go/reference).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst instance = new gcp.bigtable.Instance(\"instance\", {clusters: [{\n    clusterId: \"tf-instance-cluster\",\n    zone: \"us-central1-b\",\n    numNodes: 3,\n    storageType: \"HDD\",\n}]});\nconst table = new gcp.bigtable.Table(\"table\", {\n    instanceName: instance.name,\n    splitKeys: [\n        \"a\",\n        \"b\",\n        \"c\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\ninstance = gcp.bigtable.Instance(\"instance\", clusters=[gcp.bigtable.InstanceClusterArgs(\n    cluster_id=\"tf-instance-cluster\",\n    zone=\"us-central1-b\",\n    num_nodes=3,\n    storage_type=\"HDD\",\n)])\ntable = gcp.bigtable.Table(\"table\",\n    instance_name=instance.name,\n    split_keys=[\n        \"a\",\n        \"b\",\n        \"c\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var instance = new Gcp.BigTable.Instance(\"instance\", new()\n    {\n        Clusters = new[]\n        {\n            new Gcp.BigTable.Inputs.InstanceClusterArgs\n            {\n                ClusterId = \"tf-instance-cluster\",\n                Zone = \"us-central1-b\",\n                NumNodes = 3,\n                StorageType = \"HDD\",\n            },\n        },\n    });\n\n    var table = new Gcp.BigTable.Table(\"table\", new()\n    {\n        InstanceName = instance.Name,\n        SplitKeys = new[]\n        {\n            \"a\",\n            \"b\",\n            \"c\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/bigtable\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinstance, err := bigtable.NewInstance(ctx, \"instance\", &bigtable.InstanceArgs{\n\t\t\tClusters: bigtable.InstanceClusterArray{\n\t\t\t\t&bigtable.InstanceClusterArgs{\n\t\t\t\t\tClusterId:   pulumi.String(\"tf-instance-cluster\"),\n\t\t\t\t\tZone:        pulumi.String(\"us-central1-b\"),\n\t\t\t\t\tNumNodes:    pulumi.Int(3),\n\t\t\t\t\tStorageType: pulumi.String(\"HDD\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = bigtable.NewTable(ctx, \"table\", &bigtable.TableArgs{\n\t\t\tInstanceName: instance.Name,\n\t\t\tSplitKeys: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"a\"),\n\t\t\t\tpulumi.String(\"b\"),\n\t\t\t\tpulumi.String(\"c\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.bigtable.Instance;\nimport com.pulumi.gcp.bigtable.InstanceArgs;\nimport com.pulumi.gcp.bigtable.inputs.InstanceClusterArgs;\nimport com.pulumi.gcp.bigtable.Table;\nimport com.pulumi.gcp.bigtable.TableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var instance = new Instance(\"instance\", InstanceArgs.builder()        \n            .clusters(InstanceClusterArgs.builder()\n                .clusterId(\"tf-instance-cluster\")\n                .zone(\"us-central1-b\")\n                .numNodes(3)\n                .storageType(\"HDD\")\n                .build())\n            .build());\n\n        var table = new Table(\"table\", TableArgs.builder()        \n            .instanceName(instance.name())\n            .splitKeys(            \n                \"a\",\n                \"b\",\n                \"c\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  instance:\n    type: gcp:bigtable:Instance\n    properties:\n      clusters:\n        - clusterId: tf-instance-cluster\n          zone: us-central1-b\n          numNodes: 3\n          storageType: HDD\n  table:\n    type: gcp:bigtable:Table\n    properties:\n      instanceName: ${instance.name}\n      splitKeys:\n        - a\n        - b\n        - c\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBigtable Tables can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:bigtable/table:Table default projects/{{project}}/instances/{{instance_name}}/tables/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:bigtable/table:Table default {{project}}/{{instance_name}}/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:bigtable/table:Table default {{instance_name}}/{{name}}\n```\n\n The following fields can't be read and will show diffs if set in config when imported- `split_keys` ",
      "properties": {
        "columnFamilies": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:bigtable/TableColumnFamily:TableColumnFamily"
          },
          "description": "A group of columns within a table which share a common configuration. This can be specified multiple times. Structure is documented below.\n"
        },
        "instanceName": {
          "type": "string",
          "description": "The name of the Bigtable instance.\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the table.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs. If it\nis not provided, the provider project is used.\n"
        },
        "splitKeys": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of predefined keys to split the table on.\n!> **Warning:** Modifying the `split_keys` of an existing table will cause the provider\nto delete/recreate the entire `gcp.bigtable.Table` resource.\n"
        }
      },
      "required": [
        "instanceName",
        "name",
        "project"
      ],
      "inputProperties": {
        "columnFamilies": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:bigtable/TableColumnFamily:TableColumnFamily"
          },
          "description": "A group of columns within a table which share a common configuration. This can be specified multiple times. Structure is documented below.\n"
        },
        "instanceName": {
          "type": "string",
          "description": "The name of the Bigtable instance.\n",
          "willReplaceOnChanges": true
        },
        "name": {
          "type": "string",
          "description": "The name of the table.\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs. If it\nis not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        },
        "splitKeys": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "willReplaceOnChanges": true,
          "description": "A list of predefined keys to split the table on.\n!> **Warning:** Modifying the `split_keys` of an existing table will cause the provider\nto delete/recreate the entire `gcp.bigtable.Table` resource.\n"
        }
      },
      "requiredInputs": [
        "instanceName"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Table resources.\n",
        "properties": {
          "columnFamilies": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:bigtable/TableColumnFamily:TableColumnFamily"
            },
            "description": "A group of columns within a table which share a common configuration. This can be specified multiple times. Structure is documented below.\n"
          },
          "instanceName": {
            "type": "string",
            "description": "The name of the Bigtable instance.\n",
            "willReplaceOnChanges": true
          },
          "name": {
            "type": "string",
            "description": "The name of the table.\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs. If it\nis not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          },
          "splitKeys": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of predefined keys to split the table on.\n!> **Warning:** Modifying the `split_keys` of an existing table will cause the provider\nto delete/recreate the entire `gcp.bigtable.Table` resource.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:binaryauthorization/attestor:Attestor": {
      "description": "An attestor that attests to container image artifacts.\n\n\nTo get more information about Attestor, see:\n\n* [API documentation](https://cloud.google.com/binary-authorization/docs/reference/rest/)\n* How-to Guides\n    * [Official Documentation](https://cloud.google.com/binary-authorization/)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Binary Authorization Attestor Basic\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst note = new gcp.containeranalysis.Note(\"note\", {attestationAuthority: {\n    hint: {\n        humanReadableName: \"Attestor Note\",\n    },\n}});\nconst attestor = new gcp.binaryauthorization.Attestor(\"attestor\", {attestationAuthorityNote: {\n    noteReference: note.name,\n    publicKeys: [{\n        asciiArmoredPgpPublicKey: `mQENBFtP0doBCADF+joTiXWKVuP8kJt3fgpBSjT9h8ezMfKA4aXZctYLx5wslWQl\nbB7Iu2ezkECNzoEeU7WxUe8a61pMCh9cisS9H5mB2K2uM4Jnf8tgFeXn3akJDVo0\noR1IC+Dp9mXbRSK3MAvKkOwWlG99sx3uEdvmeBRHBOO+grchLx24EThXFOyP9Fk6\nV39j6xMjw4aggLD15B4V0v9JqBDdJiIYFzszZDL6pJwZrzcP0z8JO4rTZd+f64bD\nMpj52j/pQfA8lZHOaAgb1OrthLdMrBAjoDjArV4Ek7vSbrcgYWcI6BhsQrFoxKdX\n83TZKai55ZCfCLIskwUIzA1NLVwyzCS+fSN/ABEBAAG0KCJUZXN0IEF0dGVzdG9y\nIiA8ZGFuYWhvZmZtYW5AZ29vZ2xlLmNvbT6JAU4EEwEIADgWIQRfWkqHt6hpTA1L\nuY060eeM4dc66AUCW0/R2gIbLwULCQgHAgYVCgkICwIEFgIDAQIeAQIXgAAKCRA6\n0eeM4dc66HdpCAC4ot3b0OyxPb0Ip+WT2U0PbpTBPJklesuwpIrM4Lh0N+1nVRLC\n51WSmVbM8BiAFhLbN9LpdHhds1kUrHF7+wWAjdR8sqAj9otc6HGRM/3qfa2qgh+U\nWTEk/3us/rYSi7T7TkMuutRMIa1IkR13uKiW56csEMnbOQpn9rDqwIr5R8nlZP5h\nMAU9vdm1DIv567meMqTaVZgR3w7bck2P49AO8lO5ERFpVkErtu/98y+rUy9d789l\n+OPuS1NGnxI1YKsNaWJF4uJVuvQuZ1twrhCbGNtVorO2U12+cEq+YtUxj7kmdOC1\nqoIRW6y0+UlAc+MbqfL0ziHDOAmcqz1GnROg\n=6Bvm\n`,\n    }],\n}});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nnote = gcp.containeranalysis.Note(\"note\", attestation_authority=gcp.containeranalysis.NoteAttestationAuthorityArgs(\n    hint=gcp.containeranalysis.NoteAttestationAuthorityHintArgs(\n        human_readable_name=\"Attestor Note\",\n    ),\n))\nattestor = gcp.binaryauthorization.Attestor(\"attestor\", attestation_authority_note=gcp.binaryauthorization.AttestorAttestationAuthorityNoteArgs(\n    note_reference=note.name,\n    public_keys=[gcp.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyArgs(\n        ascii_armored_pgp_public_key=\"\"\"mQENBFtP0doBCADF+joTiXWKVuP8kJt3fgpBSjT9h8ezMfKA4aXZctYLx5wslWQl\nbB7Iu2ezkECNzoEeU7WxUe8a61pMCh9cisS9H5mB2K2uM4Jnf8tgFeXn3akJDVo0\noR1IC+Dp9mXbRSK3MAvKkOwWlG99sx3uEdvmeBRHBOO+grchLx24EThXFOyP9Fk6\nV39j6xMjw4aggLD15B4V0v9JqBDdJiIYFzszZDL6pJwZrzcP0z8JO4rTZd+f64bD\nMpj52j/pQfA8lZHOaAgb1OrthLdMrBAjoDjArV4Ek7vSbrcgYWcI6BhsQrFoxKdX\n83TZKai55ZCfCLIskwUIzA1NLVwyzCS+fSN/ABEBAAG0KCJUZXN0IEF0dGVzdG9y\nIiA8ZGFuYWhvZmZtYW5AZ29vZ2xlLmNvbT6JAU4EEwEIADgWIQRfWkqHt6hpTA1L\nuY060eeM4dc66AUCW0/R2gIbLwULCQgHAgYVCgkICwIEFgIDAQIeAQIXgAAKCRA6\n0eeM4dc66HdpCAC4ot3b0OyxPb0Ip+WT2U0PbpTBPJklesuwpIrM4Lh0N+1nVRLC\n51WSmVbM8BiAFhLbN9LpdHhds1kUrHF7+wWAjdR8sqAj9otc6HGRM/3qfa2qgh+U\nWTEk/3us/rYSi7T7TkMuutRMIa1IkR13uKiW56csEMnbOQpn9rDqwIr5R8nlZP5h\nMAU9vdm1DIv567meMqTaVZgR3w7bck2P49AO8lO5ERFpVkErtu/98y+rUy9d789l\n+OPuS1NGnxI1YKsNaWJF4uJVuvQuZ1twrhCbGNtVorO2U12+cEq+YtUxj7kmdOC1\nqoIRW6y0+UlAc+MbqfL0ziHDOAmcqz1GnROg\n=6Bvm\n\"\"\",\n    )],\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var note = new Gcp.ContainerAnalysis.Note(\"note\", new()\n    {\n        AttestationAuthority = new Gcp.ContainerAnalysis.Inputs.NoteAttestationAuthorityArgs\n        {\n            Hint = new Gcp.ContainerAnalysis.Inputs.NoteAttestationAuthorityHintArgs\n            {\n                HumanReadableName = \"Attestor Note\",\n            },\n        },\n    });\n\n    var attestor = new Gcp.BinaryAuthorization.Attestor(\"attestor\", new()\n    {\n        AttestationAuthorityNote = new Gcp.BinaryAuthorization.Inputs.AttestorAttestationAuthorityNoteArgs\n        {\n            NoteReference = note.Name,\n            PublicKeys = new[]\n            {\n                new Gcp.BinaryAuthorization.Inputs.AttestorAttestationAuthorityNotePublicKeyArgs\n                {\n                    AsciiArmoredPgpPublicKey = @\"mQENBFtP0doBCADF+joTiXWKVuP8kJt3fgpBSjT9h8ezMfKA4aXZctYLx5wslWQl\nbB7Iu2ezkECNzoEeU7WxUe8a61pMCh9cisS9H5mB2K2uM4Jnf8tgFeXn3akJDVo0\noR1IC+Dp9mXbRSK3MAvKkOwWlG99sx3uEdvmeBRHBOO+grchLx24EThXFOyP9Fk6\nV39j6xMjw4aggLD15B4V0v9JqBDdJiIYFzszZDL6pJwZrzcP0z8JO4rTZd+f64bD\nMpj52j/pQfA8lZHOaAgb1OrthLdMrBAjoDjArV4Ek7vSbrcgYWcI6BhsQrFoxKdX\n83TZKai55ZCfCLIskwUIzA1NLVwyzCS+fSN/ABEBAAG0KCJUZXN0IEF0dGVzdG9y\nIiA8ZGFuYWhvZmZtYW5AZ29vZ2xlLmNvbT6JAU4EEwEIADgWIQRfWkqHt6hpTA1L\nuY060eeM4dc66AUCW0/R2gIbLwULCQgHAgYVCgkICwIEFgIDAQIeAQIXgAAKCRA6\n0eeM4dc66HdpCAC4ot3b0OyxPb0Ip+WT2U0PbpTBPJklesuwpIrM4Lh0N+1nVRLC\n51WSmVbM8BiAFhLbN9LpdHhds1kUrHF7+wWAjdR8sqAj9otc6HGRM/3qfa2qgh+U\nWTEk/3us/rYSi7T7TkMuutRMIa1IkR13uKiW56csEMnbOQpn9rDqwIr5R8nlZP5h\nMAU9vdm1DIv567meMqTaVZgR3w7bck2P49AO8lO5ERFpVkErtu/98y+rUy9d789l\n+OPuS1NGnxI1YKsNaWJF4uJVuvQuZ1twrhCbGNtVorO2U12+cEq+YtUxj7kmdOC1\nqoIRW6y0+UlAc+MbqfL0ziHDOAmcqz1GnROg\n=6Bvm\n\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/binaryauthorization\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/containeranalysis\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnote, err := containeranalysis.NewNote(ctx, \"note\", &containeranalysis.NoteArgs{\n\t\t\tAttestationAuthority: &containeranalysis.NoteAttestationAuthorityArgs{\n\t\t\t\tHint: &containeranalysis.NoteAttestationAuthorityHintArgs{\n\t\t\t\t\tHumanReadableName: pulumi.String(\"Attestor Note\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = binaryauthorization.NewAttestor(ctx, \"attestor\", &binaryauthorization.AttestorArgs{\n\t\t\tAttestationAuthorityNote: &binaryauthorization.AttestorAttestationAuthorityNoteArgs{\n\t\t\t\tNoteReference: note.Name,\n\t\t\t\tPublicKeys: binaryauthorization.AttestorAttestationAuthorityNotePublicKeyArray{\n\t\t\t\t\t&binaryauthorization.AttestorAttestationAuthorityNotePublicKeyArgs{\n\t\t\t\t\t\tAsciiArmoredPgpPublicKey: pulumi.String(fmt.Sprintf(`mQENBFtP0doBCADF+joTiXWKVuP8kJt3fgpBSjT9h8ezMfKA4aXZctYLx5wslWQl\nbB7Iu2ezkECNzoEeU7WxUe8a61pMCh9cisS9H5mB2K2uM4Jnf8tgFeXn3akJDVo0\noR1IC+Dp9mXbRSK3MAvKkOwWlG99sx3uEdvmeBRHBOO+grchLx24EThXFOyP9Fk6\nV39j6xMjw4aggLD15B4V0v9JqBDdJiIYFzszZDL6pJwZrzcP0z8JO4rTZd+f64bD\nMpj52j/pQfA8lZHOaAgb1OrthLdMrBAjoDjArV4Ek7vSbrcgYWcI6BhsQrFoxKdX\n83TZKai55ZCfCLIskwUIzA1NLVwyzCS+fSN/ABEBAAG0KCJUZXN0IEF0dGVzdG9y\nIiA8ZGFuYWhvZmZtYW5AZ29vZ2xlLmNvbT6JAU4EEwEIADgWIQRfWkqHt6hpTA1L\nuY060eeM4dc66AUCW0/R2gIbLwULCQgHAgYVCgkICwIEFgIDAQIeAQIXgAAKCRA6\n0eeM4dc66HdpCAC4ot3b0OyxPb0Ip+WT2U0PbpTBPJklesuwpIrM4Lh0N+1nVRLC\n51WSmVbM8BiAFhLbN9LpdHhds1kUrHF7+wWAjdR8sqAj9otc6HGRM/3qfa2qgh+U\nWTEk/3us/rYSi7T7TkMuutRMIa1IkR13uKiW56csEMnbOQpn9rDqwIr5R8nlZP5h\nMAU9vdm1DIv567meMqTaVZgR3w7bck2P49AO8lO5ERFpVkErtu/98y+rUy9d789l\n+OPuS1NGnxI1YKsNaWJF4uJVuvQuZ1twrhCbGNtVorO2U12+cEq+YtUxj7kmdOC1\nqoIRW6y0+UlAc+MbqfL0ziHDOAmcqz1GnROg\n=6Bvm\n`)),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.containeranalysis.Note;\nimport com.pulumi.gcp.containeranalysis.NoteArgs;\nimport com.pulumi.gcp.containeranalysis.inputs.NoteAttestationAuthorityArgs;\nimport com.pulumi.gcp.containeranalysis.inputs.NoteAttestationAuthorityHintArgs;\nimport com.pulumi.gcp.binaryauthorization.Attestor;\nimport com.pulumi.gcp.binaryauthorization.AttestorArgs;\nimport com.pulumi.gcp.binaryauthorization.inputs.AttestorAttestationAuthorityNoteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var note = new Note(\"note\", NoteArgs.builder()        \n            .attestationAuthority(NoteAttestationAuthorityArgs.builder()\n                .hint(NoteAttestationAuthorityHintArgs.builder()\n                    .humanReadableName(\"Attestor Note\")\n                    .build())\n                .build())\n            .build());\n\n        var attestor = new Attestor(\"attestor\", AttestorArgs.builder()        \n            .attestationAuthorityNote(AttestorAttestationAuthorityNoteArgs.builder()\n                .noteReference(note.name())\n                .publicKeys(AttestorAttestationAuthorityNotePublicKeyArgs.builder()\n                    .asciiArmoredPgpPublicKey(\"\"\"\nmQENBFtP0doBCADF+joTiXWKVuP8kJt3fgpBSjT9h8ezMfKA4aXZctYLx5wslWQl\nbB7Iu2ezkECNzoEeU7WxUe8a61pMCh9cisS9H5mB2K2uM4Jnf8tgFeXn3akJDVo0\noR1IC+Dp9mXbRSK3MAvKkOwWlG99sx3uEdvmeBRHBOO+grchLx24EThXFOyP9Fk6\nV39j6xMjw4aggLD15B4V0v9JqBDdJiIYFzszZDL6pJwZrzcP0z8JO4rTZd+f64bD\nMpj52j/pQfA8lZHOaAgb1OrthLdMrBAjoDjArV4Ek7vSbrcgYWcI6BhsQrFoxKdX\n83TZKai55ZCfCLIskwUIzA1NLVwyzCS+fSN/ABEBAAG0KCJUZXN0IEF0dGVzdG9y\nIiA8ZGFuYWhvZmZtYW5AZ29vZ2xlLmNvbT6JAU4EEwEIADgWIQRfWkqHt6hpTA1L\nuY060eeM4dc66AUCW0/R2gIbLwULCQgHAgYVCgkICwIEFgIDAQIeAQIXgAAKCRA6\n0eeM4dc66HdpCAC4ot3b0OyxPb0Ip+WT2U0PbpTBPJklesuwpIrM4Lh0N+1nVRLC\n51WSmVbM8BiAFhLbN9LpdHhds1kUrHF7+wWAjdR8sqAj9otc6HGRM/3qfa2qgh+U\nWTEk/3us/rYSi7T7TkMuutRMIa1IkR13uKiW56csEMnbOQpn9rDqwIr5R8nlZP5h\nMAU9vdm1DIv567meMqTaVZgR3w7bck2P49AO8lO5ERFpVkErtu/98y+rUy9d789l\n+OPuS1NGnxI1YKsNaWJF4uJVuvQuZ1twrhCbGNtVorO2U12+cEq+YtUxj7kmdOC1\nqoIRW6y0+UlAc+MbqfL0ziHDOAmcqz1GnROg\n=6Bvm\n                    \"\"\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attestor:\n    type: gcp:binaryauthorization:Attestor\n    properties:\n      attestationAuthorityNote:\n        noteReference: ${note.name}\n        publicKeys:\n          - asciiArmoredPgpPublicKey: |\n              mQENBFtP0doBCADF+joTiXWKVuP8kJt3fgpBSjT9h8ezMfKA4aXZctYLx5wslWQl\n              bB7Iu2ezkECNzoEeU7WxUe8a61pMCh9cisS9H5mB2K2uM4Jnf8tgFeXn3akJDVo0\n              oR1IC+Dp9mXbRSK3MAvKkOwWlG99sx3uEdvmeBRHBOO+grchLx24EThXFOyP9Fk6\n              V39j6xMjw4aggLD15B4V0v9JqBDdJiIYFzszZDL6pJwZrzcP0z8JO4rTZd+f64bD\n              Mpj52j/pQfA8lZHOaAgb1OrthLdMrBAjoDjArV4Ek7vSbrcgYWcI6BhsQrFoxKdX\n              83TZKai55ZCfCLIskwUIzA1NLVwyzCS+fSN/ABEBAAG0KCJUZXN0IEF0dGVzdG9y\n              IiA8ZGFuYWhvZmZtYW5AZ29vZ2xlLmNvbT6JAU4EEwEIADgWIQRfWkqHt6hpTA1L\n              uY060eeM4dc66AUCW0/R2gIbLwULCQgHAgYVCgkICwIEFgIDAQIeAQIXgAAKCRA6\n              0eeM4dc66HdpCAC4ot3b0OyxPb0Ip+WT2U0PbpTBPJklesuwpIrM4Lh0N+1nVRLC\n              51WSmVbM8BiAFhLbN9LpdHhds1kUrHF7+wWAjdR8sqAj9otc6HGRM/3qfa2qgh+U\n              WTEk/3us/rYSi7T7TkMuutRMIa1IkR13uKiW56csEMnbOQpn9rDqwIr5R8nlZP5h\n              MAU9vdm1DIv567meMqTaVZgR3w7bck2P49AO8lO5ERFpVkErtu/98y+rUy9d789l\n              +OPuS1NGnxI1YKsNaWJF4uJVuvQuZ1twrhCbGNtVorO2U12+cEq+YtUxj7kmdOC1\n              qoIRW6y0+UlAc+MbqfL0ziHDOAmcqz1GnROg\n              =6Bvm\n  note:\n    type: gcp:containeranalysis:Note\n    properties:\n      attestationAuthority:\n        hint:\n          humanReadableName: Attestor Note\n```\n{{% /example %}}\n{{% example %}}\n### Binary Authorization Attestor Kms\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst keyring = new gcp.kms.KeyRing(\"keyring\", {location: \"global\"});\nconst crypto_key = new gcp.kms.CryptoKey(\"crypto-key\", {\n    keyRing: keyring.id,\n    purpose: \"ASYMMETRIC_SIGN\",\n    versionTemplate: {\n        algorithm: \"RSA_SIGN_PKCS1_4096_SHA512\",\n    },\n});\nconst version = gcp.kms.getKMSCryptoKeyVersionOutput({\n    cryptoKey: crypto_key.id,\n});\nconst note = new gcp.containeranalysis.Note(\"note\", {attestationAuthority: {\n    hint: {\n        humanReadableName: \"Attestor Note\",\n    },\n}});\nconst attestor = new gcp.binaryauthorization.Attestor(\"attestor\", {attestationAuthorityNote: {\n    noteReference: note.name,\n    publicKeys: [{\n        id: version.apply(version => version.id),\n        pkixPublicKey: {\n            publicKeyPem: version.apply(version => version.publicKeys?[0]?.pem),\n            signatureAlgorithm: version.apply(version => version.publicKeys?[0]?.algorithm),\n        },\n    }],\n}});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nkeyring = gcp.kms.KeyRing(\"keyring\", location=\"global\")\ncrypto_key = gcp.kms.CryptoKey(\"crypto-key\",\n    key_ring=keyring.id,\n    purpose=\"ASYMMETRIC_SIGN\",\n    version_template=gcp.kms.CryptoKeyVersionTemplateArgs(\n        algorithm=\"RSA_SIGN_PKCS1_4096_SHA512\",\n    ))\nversion = gcp.kms.get_kms_crypto_key_version_output(crypto_key=crypto_key.id)\nnote = gcp.containeranalysis.Note(\"note\", attestation_authority=gcp.containeranalysis.NoteAttestationAuthorityArgs(\n    hint=gcp.containeranalysis.NoteAttestationAuthorityHintArgs(\n        human_readable_name=\"Attestor Note\",\n    ),\n))\nattestor = gcp.binaryauthorization.Attestor(\"attestor\", attestation_authority_note=gcp.binaryauthorization.AttestorAttestationAuthorityNoteArgs(\n    note_reference=note.name,\n    public_keys=[gcp.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyArgs(\n        id=version.id,\n        pkix_public_key=gcp.binaryauthorization.AttestorAttestationAuthorityNotePublicKeyPkixPublicKeyArgs(\n            public_key_pem=version.public_keys[0].pem,\n            signature_algorithm=version.public_keys[0].algorithm,\n        ),\n    )],\n))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var keyring = new Gcp.Kms.KeyRing(\"keyring\", new()\n    {\n        Location = \"global\",\n    });\n\n    var crypto_key = new Gcp.Kms.CryptoKey(\"crypto-key\", new()\n    {\n        KeyRing = keyring.Id,\n        Purpose = \"ASYMMETRIC_SIGN\",\n        VersionTemplate = new Gcp.Kms.Inputs.CryptoKeyVersionTemplateArgs\n        {\n            Algorithm = \"RSA_SIGN_PKCS1_4096_SHA512\",\n        },\n    });\n\n    var version = Gcp.Kms.GetKMSCryptoKeyVersion.Invoke(new()\n    {\n        CryptoKey = crypto_key.Id,\n    });\n\n    var note = new Gcp.ContainerAnalysis.Note(\"note\", new()\n    {\n        AttestationAuthority = new Gcp.ContainerAnalysis.Inputs.NoteAttestationAuthorityArgs\n        {\n            Hint = new Gcp.ContainerAnalysis.Inputs.NoteAttestationAuthorityHintArgs\n            {\n                HumanReadableName = \"Attestor Note\",\n            },\n        },\n    });\n\n    var attestor = new Gcp.BinaryAuthorization.Attestor(\"attestor\", new()\n    {\n        AttestationAuthorityNote = new Gcp.BinaryAuthorization.Inputs.AttestorAttestationAuthorityNoteArgs\n        {\n            NoteReference = note.Name,\n            PublicKeys = new[]\n            {\n                new Gcp.BinaryAuthorization.Inputs.AttestorAttestationAuthorityNotePublicKeyArgs\n                {\n                    Id = version.Apply(getKMSCryptoKeyVersionResult => getKMSCryptoKeyVersionResult.Id),\n                    PkixPublicKey = new Gcp.BinaryAuthorization.Inputs.AttestorAttestationAuthorityNotePublicKeyPkixPublicKeyArgs\n                    {\n                        PublicKeyPem = version.Apply(getKMSCryptoKeyVersionResult => getKMSCryptoKeyVersionResult.PublicKeys[0]?.Pem),\n                        SignatureAlgorithm = version.Apply(getKMSCryptoKeyVersionResult => getKMSCryptoKeyVersionResult.PublicKeys[0]?.Algorithm),\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/binaryauthorization\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/containeranalysis\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/kms\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkeyring, err := kms.NewKeyRing(ctx, \"keyring\", &kms.KeyRingArgs{\n\t\t\tLocation: pulumi.String(\"global\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = kms.NewCryptoKey(ctx, \"crypto-key\", &kms.CryptoKeyArgs{\n\t\t\tKeyRing: keyring.ID(),\n\t\t\tPurpose: pulumi.String(\"ASYMMETRIC_SIGN\"),\n\t\t\tVersionTemplate: &kms.CryptoKeyVersionTemplateArgs{\n\t\t\t\tAlgorithm: pulumi.String(\"RSA_SIGN_PKCS1_4096_SHA512\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tversion := kms.GetKMSCryptoKeyVersionOutput(ctx, kms.GetKMSCryptoKeyVersionOutputArgs{\n\t\t\tCryptoKey: crypto_key.ID(),\n\t\t}, nil)\n\t\tnote, err := containeranalysis.NewNote(ctx, \"note\", &containeranalysis.NoteArgs{\n\t\t\tAttestationAuthority: &containeranalysis.NoteAttestationAuthorityArgs{\n\t\t\t\tHint: &containeranalysis.NoteAttestationAuthorityHintArgs{\n\t\t\t\t\tHumanReadableName: pulumi.String(\"Attestor Note\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = binaryauthorization.NewAttestor(ctx, \"attestor\", &binaryauthorization.AttestorArgs{\n\t\t\tAttestationAuthorityNote: &binaryauthorization.AttestorAttestationAuthorityNoteArgs{\n\t\t\t\tNoteReference: note.Name,\n\t\t\t\tPublicKeys: binaryauthorization.AttestorAttestationAuthorityNotePublicKeyArray{\n\t\t\t\t\t&binaryauthorization.AttestorAttestationAuthorityNotePublicKeyArgs{\n\t\t\t\t\t\tId: version.ApplyT(func(version kms.GetKMSCryptoKeyVersionResult) (string, error) {\n\t\t\t\t\t\t\treturn version.Id, nil\n\t\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\t\tPkixPublicKey: &binaryauthorization.AttestorAttestationAuthorityNotePublicKeyPkixPublicKeyArgs{\n\t\t\t\t\t\t\tPublicKeyPem: version.ApplyT(func(version kms.GetKMSCryptoKeyVersionResult) (string, error) {\n\t\t\t\t\t\t\t\treturn version.PublicKeys[0].Pem, nil\n\t\t\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\t\t\tSignatureAlgorithm: version.ApplyT(func(version kms.GetKMSCryptoKeyVersionResult) (string, error) {\n\t\t\t\t\t\t\t\treturn version.PublicKeys[0].Algorithm, nil\n\t\t\t\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.kms.KeyRing;\nimport com.pulumi.gcp.kms.KeyRingArgs;\nimport com.pulumi.gcp.kms.CryptoKey;\nimport com.pulumi.gcp.kms.CryptoKeyArgs;\nimport com.pulumi.gcp.kms.inputs.CryptoKeyVersionTemplateArgs;\nimport com.pulumi.gcp.kms.KmsFunctions;\nimport com.pulumi.gcp.kms.inputs.GetKMSCryptoKeyVersionArgs;\nimport com.pulumi.gcp.containeranalysis.Note;\nimport com.pulumi.gcp.containeranalysis.NoteArgs;\nimport com.pulumi.gcp.containeranalysis.inputs.NoteAttestationAuthorityArgs;\nimport com.pulumi.gcp.containeranalysis.inputs.NoteAttestationAuthorityHintArgs;\nimport com.pulumi.gcp.binaryauthorization.Attestor;\nimport com.pulumi.gcp.binaryauthorization.AttestorArgs;\nimport com.pulumi.gcp.binaryauthorization.inputs.AttestorAttestationAuthorityNoteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var keyring = new KeyRing(\"keyring\", KeyRingArgs.builder()        \n            .location(\"global\")\n            .build());\n\n        var crypto_key = new CryptoKey(\"crypto-key\", CryptoKeyArgs.builder()        \n            .keyRing(keyring.id())\n            .purpose(\"ASYMMETRIC_SIGN\")\n            .versionTemplate(CryptoKeyVersionTemplateArgs.builder()\n                .algorithm(\"RSA_SIGN_PKCS1_4096_SHA512\")\n                .build())\n            .build());\n\n        final var version = KmsFunctions.getKMSCryptoKeyVersion(GetKMSCryptoKeyVersionArgs.builder()\n            .cryptoKey(crypto_key.id())\n            .build());\n\n        var note = new Note(\"note\", NoteArgs.builder()        \n            .attestationAuthority(NoteAttestationAuthorityArgs.builder()\n                .hint(NoteAttestationAuthorityHintArgs.builder()\n                    .humanReadableName(\"Attestor Note\")\n                    .build())\n                .build())\n            .build());\n\n        var attestor = new Attestor(\"attestor\", AttestorArgs.builder()        \n            .attestationAuthorityNote(AttestorAttestationAuthorityNoteArgs.builder()\n                .noteReference(note.name())\n                .publicKeys(AttestorAttestationAuthorityNotePublicKeyArgs.builder()\n                    .id(version.applyValue(getKMSCryptoKeyVersionResult -> getKMSCryptoKeyVersionResult).applyValue(version -> version.applyValue(getKMSCryptoKeyVersionResult -> getKMSCryptoKeyVersionResult.id())))\n                    .pkixPublicKey(AttestorAttestationAuthorityNotePublicKeyPkixPublicKeyArgs.builder()\n                        .publicKeyPem(version.applyValue(getKMSCryptoKeyVersionResult -> getKMSCryptoKeyVersionResult).applyValue(version -> version.applyValue(getKMSCryptoKeyVersionResult -> getKMSCryptoKeyVersionResult.publicKeys()[0].pem())))\n                        .signatureAlgorithm(version.applyValue(getKMSCryptoKeyVersionResult -> getKMSCryptoKeyVersionResult).applyValue(version -> version.applyValue(getKMSCryptoKeyVersionResult -> getKMSCryptoKeyVersionResult.publicKeys()[0].algorithm())))\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attestor:\n    type: gcp:binaryauthorization:Attestor\n    properties:\n      attestationAuthorityNote:\n        noteReference: ${note.name}\n        publicKeys:\n          - id: ${version.id}\n            pkixPublicKey:\n              publicKeyPem: ${version.publicKeys[0].pem}\n              signatureAlgorithm: ${version.publicKeys[0].algorithm}\n  note:\n    type: gcp:containeranalysis:Note\n    properties:\n      attestationAuthority:\n        hint:\n          humanReadableName: Attestor Note\n  crypto-key:\n    type: gcp:kms:CryptoKey\n    properties:\n      keyRing: ${keyring.id}\n      purpose: ASYMMETRIC_SIGN\n      versionTemplate:\n        algorithm: RSA_SIGN_PKCS1_4096_SHA512\n  keyring:\n    type: gcp:kms:KeyRing\n    properties:\n      location: global\nvariables:\n  version:\n    Fn::Invoke:\n      Function: gcp:kms:getKMSCryptoKeyVersion\n      Arguments:\n        cryptoKey: ${[\"crypto-key\"].id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAttestor can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:binaryauthorization/attestor:Attestor default projects/{{project}}/attestors/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:binaryauthorization/attestor:Attestor default {{project}}/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:binaryauthorization/attestor:Attestor default {{name}}\n```\n\n ",
      "properties": {
        "attestationAuthorityNote": {
          "$ref": "#/types/gcp:binaryauthorization/AttestorAttestationAuthorityNote:AttestorAttestationAuthorityNote",
          "description": "A Container Analysis ATTESTATION_AUTHORITY Note, created by the user.\nStructure is documented below.\n"
        },
        "description": {
          "type": "string",
          "description": "A descriptive comment. This field may be updated. The field may be\ndisplayed in chooser dialogs.\n"
        },
        "name": {
          "type": "string",
          "description": "The resource name.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n"
        }
      },
      "required": [
        "attestationAuthorityNote",
        "name",
        "project"
      ],
      "inputProperties": {
        "attestationAuthorityNote": {
          "$ref": "#/types/gcp:binaryauthorization/AttestorAttestationAuthorityNote:AttestorAttestationAuthorityNote",
          "description": "A Container Analysis ATTESTATION_AUTHORITY Note, created by the user.\nStructure is documented below.\n"
        },
        "description": {
          "type": "string",
          "description": "A descriptive comment. This field may be updated. The field may be\ndisplayed in chooser dialogs.\n"
        },
        "name": {
          "type": "string",
          "description": "The resource name.\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "attestationAuthorityNote"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Attestor resources.\n",
        "properties": {
          "attestationAuthorityNote": {
            "$ref": "#/types/gcp:binaryauthorization/AttestorAttestationAuthorityNote:AttestorAttestationAuthorityNote",
            "description": "A Container Analysis ATTESTATION_AUTHORITY Note, created by the user.\nStructure is documented below.\n"
          },
          "description": {
            "type": "string",
            "description": "A descriptive comment. This field may be updated. The field may be\ndisplayed in chooser dialogs.\n"
          },
          "name": {
            "type": "string",
            "description": "The resource name.\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:binaryauthorization/policy:Policy": {
      "description": "A policy for container image binary authorization.\n\n\nTo get more information about Policy, see:\n\n* [API documentation](https://cloud.google.com/binary-authorization/docs/reference/rest/)\n* How-to Guides\n    * [Official Documentation](https://cloud.google.com/binary-authorization/)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Binary Authorization Policy Basic\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst note = new gcp.containeranalysis.Note(\"note\", {attestationAuthority: {\n    hint: {\n        humanReadableName: \"My attestor\",\n    },\n}});\nconst attestor = new gcp.binaryauthorization.Attestor(\"attestor\", {attestationAuthorityNote: {\n    noteReference: note.name,\n}});\nconst policy = new gcp.binaryauthorization.Policy(\"policy\", {\n    admissionWhitelistPatterns: [{\n        namePattern: \"gcr.io/google_containers/*\",\n    }],\n    defaultAdmissionRule: {\n        evaluationMode: \"ALWAYS_ALLOW\",\n        enforcementMode: \"ENFORCED_BLOCK_AND_AUDIT_LOG\",\n    },\n    clusterAdmissionRules: [{\n        cluster: \"us-central1-a.prod-cluster\",\n        evaluationMode: \"REQUIRE_ATTESTATION\",\n        enforcementMode: \"ENFORCED_BLOCK_AND_AUDIT_LOG\",\n        requireAttestationsBies: [attestor.name],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nnote = gcp.containeranalysis.Note(\"note\", attestation_authority=gcp.containeranalysis.NoteAttestationAuthorityArgs(\n    hint=gcp.containeranalysis.NoteAttestationAuthorityHintArgs(\n        human_readable_name=\"My attestor\",\n    ),\n))\nattestor = gcp.binaryauthorization.Attestor(\"attestor\", attestation_authority_note=gcp.binaryauthorization.AttestorAttestationAuthorityNoteArgs(\n    note_reference=note.name,\n))\npolicy = gcp.binaryauthorization.Policy(\"policy\",\n    admission_whitelist_patterns=[gcp.binaryauthorization.PolicyAdmissionWhitelistPatternArgs(\n        name_pattern=\"gcr.io/google_containers/*\",\n    )],\n    default_admission_rule=gcp.binaryauthorization.PolicyDefaultAdmissionRuleArgs(\n        evaluation_mode=\"ALWAYS_ALLOW\",\n        enforcement_mode=\"ENFORCED_BLOCK_AND_AUDIT_LOG\",\n    ),\n    cluster_admission_rules=[gcp.binaryauthorization.PolicyClusterAdmissionRuleArgs(\n        cluster=\"us-central1-a.prod-cluster\",\n        evaluation_mode=\"REQUIRE_ATTESTATION\",\n        enforcement_mode=\"ENFORCED_BLOCK_AND_AUDIT_LOG\",\n        require_attestations_bies=[attestor.name],\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var note = new Gcp.ContainerAnalysis.Note(\"note\", new()\n    {\n        AttestationAuthority = new Gcp.ContainerAnalysis.Inputs.NoteAttestationAuthorityArgs\n        {\n            Hint = new Gcp.ContainerAnalysis.Inputs.NoteAttestationAuthorityHintArgs\n            {\n                HumanReadableName = \"My attestor\",\n            },\n        },\n    });\n\n    var attestor = new Gcp.BinaryAuthorization.Attestor(\"attestor\", new()\n    {\n        AttestationAuthorityNote = new Gcp.BinaryAuthorization.Inputs.AttestorAttestationAuthorityNoteArgs\n        {\n            NoteReference = note.Name,\n        },\n    });\n\n    var policy = new Gcp.BinaryAuthorization.Policy(\"policy\", new()\n    {\n        AdmissionWhitelistPatterns = new[]\n        {\n            new Gcp.BinaryAuthorization.Inputs.PolicyAdmissionWhitelistPatternArgs\n            {\n                NamePattern = \"gcr.io/google_containers/*\",\n            },\n        },\n        DefaultAdmissionRule = new Gcp.BinaryAuthorization.Inputs.PolicyDefaultAdmissionRuleArgs\n        {\n            EvaluationMode = \"ALWAYS_ALLOW\",\n            EnforcementMode = \"ENFORCED_BLOCK_AND_AUDIT_LOG\",\n        },\n        ClusterAdmissionRules = new[]\n        {\n            new Gcp.BinaryAuthorization.Inputs.PolicyClusterAdmissionRuleArgs\n            {\n                Cluster = \"us-central1-a.prod-cluster\",\n                EvaluationMode = \"REQUIRE_ATTESTATION\",\n                EnforcementMode = \"ENFORCED_BLOCK_AND_AUDIT_LOG\",\n                RequireAttestationsBies = new[]\n                {\n                    attestor.Name,\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/binaryauthorization\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/containeranalysis\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnote, err := containeranalysis.NewNote(ctx, \"note\", &containeranalysis.NoteArgs{\n\t\t\tAttestationAuthority: &containeranalysis.NoteAttestationAuthorityArgs{\n\t\t\t\tHint: &containeranalysis.NoteAttestationAuthorityHintArgs{\n\t\t\t\t\tHumanReadableName: pulumi.String(\"My attestor\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tattestor, err := binaryauthorization.NewAttestor(ctx, \"attestor\", &binaryauthorization.AttestorArgs{\n\t\t\tAttestationAuthorityNote: &binaryauthorization.AttestorAttestationAuthorityNoteArgs{\n\t\t\t\tNoteReference: note.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = binaryauthorization.NewPolicy(ctx, \"policy\", &binaryauthorization.PolicyArgs{\n\t\t\tAdmissionWhitelistPatterns: binaryauthorization.PolicyAdmissionWhitelistPatternArray{\n\t\t\t\t&binaryauthorization.PolicyAdmissionWhitelistPatternArgs{\n\t\t\t\t\tNamePattern: pulumi.String(\"gcr.io/google_containers/*\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDefaultAdmissionRule: &binaryauthorization.PolicyDefaultAdmissionRuleArgs{\n\t\t\t\tEvaluationMode:  pulumi.String(\"ALWAYS_ALLOW\"),\n\t\t\t\tEnforcementMode: pulumi.String(\"ENFORCED_BLOCK_AND_AUDIT_LOG\"),\n\t\t\t},\n\t\t\tClusterAdmissionRules: binaryauthorization.PolicyClusterAdmissionRuleArray{\n\t\t\t\t&binaryauthorization.PolicyClusterAdmissionRuleArgs{\n\t\t\t\t\tCluster:         pulumi.String(\"us-central1-a.prod-cluster\"),\n\t\t\t\t\tEvaluationMode:  pulumi.String(\"REQUIRE_ATTESTATION\"),\n\t\t\t\t\tEnforcementMode: pulumi.String(\"ENFORCED_BLOCK_AND_AUDIT_LOG\"),\n\t\t\t\t\tRequireAttestationsBies: pulumi.StringArray{\n\t\t\t\t\t\tattestor.Name,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.containeranalysis.Note;\nimport com.pulumi.gcp.containeranalysis.NoteArgs;\nimport com.pulumi.gcp.containeranalysis.inputs.NoteAttestationAuthorityArgs;\nimport com.pulumi.gcp.containeranalysis.inputs.NoteAttestationAuthorityHintArgs;\nimport com.pulumi.gcp.binaryauthorization.Attestor;\nimport com.pulumi.gcp.binaryauthorization.AttestorArgs;\nimport com.pulumi.gcp.binaryauthorization.inputs.AttestorAttestationAuthorityNoteArgs;\nimport com.pulumi.gcp.binaryauthorization.Policy;\nimport com.pulumi.gcp.binaryauthorization.PolicyArgs;\nimport com.pulumi.gcp.binaryauthorization.inputs.PolicyAdmissionWhitelistPatternArgs;\nimport com.pulumi.gcp.binaryauthorization.inputs.PolicyDefaultAdmissionRuleArgs;\nimport com.pulumi.gcp.binaryauthorization.inputs.PolicyClusterAdmissionRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var note = new Note(\"note\", NoteArgs.builder()        \n            .attestationAuthority(NoteAttestationAuthorityArgs.builder()\n                .hint(NoteAttestationAuthorityHintArgs.builder()\n                    .humanReadableName(\"My attestor\")\n                    .build())\n                .build())\n            .build());\n\n        var attestor = new Attestor(\"attestor\", AttestorArgs.builder()        \n            .attestationAuthorityNote(AttestorAttestationAuthorityNoteArgs.builder()\n                .noteReference(note.name())\n                .build())\n            .build());\n\n        var policy = new Policy(\"policy\", PolicyArgs.builder()        \n            .admissionWhitelistPatterns(PolicyAdmissionWhitelistPatternArgs.builder()\n                .namePattern(\"gcr.io/google_containers/*\")\n                .build())\n            .defaultAdmissionRule(PolicyDefaultAdmissionRuleArgs.builder()\n                .evaluationMode(\"ALWAYS_ALLOW\")\n                .enforcementMode(\"ENFORCED_BLOCK_AND_AUDIT_LOG\")\n                .build())\n            .clusterAdmissionRules(PolicyClusterAdmissionRuleArgs.builder()\n                .cluster(\"us-central1-a.prod-cluster\")\n                .evaluationMode(\"REQUIRE_ATTESTATION\")\n                .enforcementMode(\"ENFORCED_BLOCK_AND_AUDIT_LOG\")\n                .requireAttestationsBies(attestor.name())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  policy:\n    type: gcp:binaryauthorization:Policy\n    properties:\n      admissionWhitelistPatterns:\n        - namePattern: gcr.io/google_containers/*\n      defaultAdmissionRule:\n        evaluationMode: ALWAYS_ALLOW\n        enforcementMode: ENFORCED_BLOCK_AND_AUDIT_LOG\n      clusterAdmissionRules:\n        - cluster: us-central1-a.prod-cluster\n          evaluationMode: REQUIRE_ATTESTATION\n          enforcementMode: ENFORCED_BLOCK_AND_AUDIT_LOG\n          requireAttestationsBies:\n            - ${attestor.name}\n  note:\n    type: gcp:containeranalysis:Note\n    properties:\n      attestationAuthority:\n        hint:\n          humanReadableName: My attestor\n  attestor:\n    type: gcp:binaryauthorization:Attestor\n    properties:\n      attestationAuthorityNote:\n        noteReference: ${note.name}\n```\n{{% /example %}}\n{{% example %}}\n### Binary Authorization Policy Global Evaluation\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst note = new gcp.containeranalysis.Note(\"note\", {attestationAuthority: {\n    hint: {\n        humanReadableName: \"My attestor\",\n    },\n}});\nconst attestor = new gcp.binaryauthorization.Attestor(\"attestor\", {attestationAuthorityNote: {\n    noteReference: note.name,\n}});\nconst policy = new gcp.binaryauthorization.Policy(\"policy\", {\n    defaultAdmissionRule: {\n        evaluationMode: \"REQUIRE_ATTESTATION\",\n        enforcementMode: \"ENFORCED_BLOCK_AND_AUDIT_LOG\",\n        requireAttestationsBies: [attestor.name],\n    },\n    globalPolicyEvaluationMode: \"ENABLE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nnote = gcp.containeranalysis.Note(\"note\", attestation_authority=gcp.containeranalysis.NoteAttestationAuthorityArgs(\n    hint=gcp.containeranalysis.NoteAttestationAuthorityHintArgs(\n        human_readable_name=\"My attestor\",\n    ),\n))\nattestor = gcp.binaryauthorization.Attestor(\"attestor\", attestation_authority_note=gcp.binaryauthorization.AttestorAttestationAuthorityNoteArgs(\n    note_reference=note.name,\n))\npolicy = gcp.binaryauthorization.Policy(\"policy\",\n    default_admission_rule=gcp.binaryauthorization.PolicyDefaultAdmissionRuleArgs(\n        evaluation_mode=\"REQUIRE_ATTESTATION\",\n        enforcement_mode=\"ENFORCED_BLOCK_AND_AUDIT_LOG\",\n        require_attestations_bies=[attestor.name],\n    ),\n    global_policy_evaluation_mode=\"ENABLE\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var note = new Gcp.ContainerAnalysis.Note(\"note\", new()\n    {\n        AttestationAuthority = new Gcp.ContainerAnalysis.Inputs.NoteAttestationAuthorityArgs\n        {\n            Hint = new Gcp.ContainerAnalysis.Inputs.NoteAttestationAuthorityHintArgs\n            {\n                HumanReadableName = \"My attestor\",\n            },\n        },\n    });\n\n    var attestor = new Gcp.BinaryAuthorization.Attestor(\"attestor\", new()\n    {\n        AttestationAuthorityNote = new Gcp.BinaryAuthorization.Inputs.AttestorAttestationAuthorityNoteArgs\n        {\n            NoteReference = note.Name,\n        },\n    });\n\n    var policy = new Gcp.BinaryAuthorization.Policy(\"policy\", new()\n    {\n        DefaultAdmissionRule = new Gcp.BinaryAuthorization.Inputs.PolicyDefaultAdmissionRuleArgs\n        {\n            EvaluationMode = \"REQUIRE_ATTESTATION\",\n            EnforcementMode = \"ENFORCED_BLOCK_AND_AUDIT_LOG\",\n            RequireAttestationsBies = new[]\n            {\n                attestor.Name,\n            },\n        },\n        GlobalPolicyEvaluationMode = \"ENABLE\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/binaryauthorization\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/containeranalysis\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnote, err := containeranalysis.NewNote(ctx, \"note\", &containeranalysis.NoteArgs{\n\t\t\tAttestationAuthority: &containeranalysis.NoteAttestationAuthorityArgs{\n\t\t\t\tHint: &containeranalysis.NoteAttestationAuthorityHintArgs{\n\t\t\t\t\tHumanReadableName: pulumi.String(\"My attestor\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tattestor, err := binaryauthorization.NewAttestor(ctx, \"attestor\", &binaryauthorization.AttestorArgs{\n\t\t\tAttestationAuthorityNote: &binaryauthorization.AttestorAttestationAuthorityNoteArgs{\n\t\t\t\tNoteReference: note.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = binaryauthorization.NewPolicy(ctx, \"policy\", &binaryauthorization.PolicyArgs{\n\t\t\tDefaultAdmissionRule: &binaryauthorization.PolicyDefaultAdmissionRuleArgs{\n\t\t\t\tEvaluationMode:  pulumi.String(\"REQUIRE_ATTESTATION\"),\n\t\t\t\tEnforcementMode: pulumi.String(\"ENFORCED_BLOCK_AND_AUDIT_LOG\"),\n\t\t\t\tRequireAttestationsBies: pulumi.StringArray{\n\t\t\t\t\tattestor.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t\tGlobalPolicyEvaluationMode: pulumi.String(\"ENABLE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.containeranalysis.Note;\nimport com.pulumi.gcp.containeranalysis.NoteArgs;\nimport com.pulumi.gcp.containeranalysis.inputs.NoteAttestationAuthorityArgs;\nimport com.pulumi.gcp.containeranalysis.inputs.NoteAttestationAuthorityHintArgs;\nimport com.pulumi.gcp.binaryauthorization.Attestor;\nimport com.pulumi.gcp.binaryauthorization.AttestorArgs;\nimport com.pulumi.gcp.binaryauthorization.inputs.AttestorAttestationAuthorityNoteArgs;\nimport com.pulumi.gcp.binaryauthorization.Policy;\nimport com.pulumi.gcp.binaryauthorization.PolicyArgs;\nimport com.pulumi.gcp.binaryauthorization.inputs.PolicyDefaultAdmissionRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var note = new Note(\"note\", NoteArgs.builder()        \n            .attestationAuthority(NoteAttestationAuthorityArgs.builder()\n                .hint(NoteAttestationAuthorityHintArgs.builder()\n                    .humanReadableName(\"My attestor\")\n                    .build())\n                .build())\n            .build());\n\n        var attestor = new Attestor(\"attestor\", AttestorArgs.builder()        \n            .attestationAuthorityNote(AttestorAttestationAuthorityNoteArgs.builder()\n                .noteReference(note.name())\n                .build())\n            .build());\n\n        var policy = new Policy(\"policy\", PolicyArgs.builder()        \n            .defaultAdmissionRule(PolicyDefaultAdmissionRuleArgs.builder()\n                .evaluationMode(\"REQUIRE_ATTESTATION\")\n                .enforcementMode(\"ENFORCED_BLOCK_AND_AUDIT_LOG\")\n                .requireAttestationsBies(attestor.name())\n                .build())\n            .globalPolicyEvaluationMode(\"ENABLE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  policy:\n    type: gcp:binaryauthorization:Policy\n    properties:\n      defaultAdmissionRule:\n        evaluationMode: REQUIRE_ATTESTATION\n        enforcementMode: ENFORCED_BLOCK_AND_AUDIT_LOG\n        requireAttestationsBies:\n          - ${attestor.name}\n      globalPolicyEvaluationMode: ENABLE\n  note:\n    type: gcp:containeranalysis:Note\n    properties:\n      attestationAuthority:\n        hint:\n          humanReadableName: My attestor\n  attestor:\n    type: gcp:binaryauthorization:Attestor\n    properties:\n      attestationAuthorityNote:\n        noteReference: ${note.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPolicy can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:binaryauthorization/policy:Policy default projects/{{project}}\n```\n\n\n\n```sh\n $ pulumi import gcp:binaryauthorization/policy:Policy default {{project}}\n```\n\n ",
      "properties": {
        "admissionWhitelistPatterns": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:binaryauthorization/PolicyAdmissionWhitelistPattern:PolicyAdmissionWhitelistPattern"
          },
          "description": "A whitelist of image patterns to exclude from admission rules. If an\nimage's name matches a whitelist pattern, the image's admission\nrequests will always be permitted regardless of your admission rules.\nStructure is documented below.\n"
        },
        "clusterAdmissionRules": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:binaryauthorization/PolicyClusterAdmissionRule:PolicyClusterAdmissionRule"
          },
          "description": "Per-cluster admission rules. An admission rule specifies either that\nall container images used in a pod creation request must be attested\nto by one or more attestors, that all pod creations will be allowed,\nor that all pod creations will be denied. There can be at most one\nadmission rule per cluster spec.\n"
        },
        "defaultAdmissionRule": {
          "$ref": "#/types/gcp:binaryauthorization/PolicyDefaultAdmissionRule:PolicyDefaultAdmissionRule",
          "description": "Default admission rule for a cluster without a per-cluster admission\nrule.\nStructure is documented below.\n"
        },
        "description": {
          "type": "string",
          "description": "A descriptive comment.\n"
        },
        "globalPolicyEvaluationMode": {
          "type": "string",
          "description": "Controls the evaluation of a Google-maintained global admission policy\nfor common system-level images. Images not covered by the global\npolicy will be subject to the project admission policy.\nPossible values are `ENABLE` and `DISABLE`.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n"
        }
      },
      "required": [
        "defaultAdmissionRule",
        "globalPolicyEvaluationMode",
        "project"
      ],
      "inputProperties": {
        "admissionWhitelistPatterns": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:binaryauthorization/PolicyAdmissionWhitelistPattern:PolicyAdmissionWhitelistPattern"
          },
          "description": "A whitelist of image patterns to exclude from admission rules. If an\nimage's name matches a whitelist pattern, the image's admission\nrequests will always be permitted regardless of your admission rules.\nStructure is documented below.\n"
        },
        "clusterAdmissionRules": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:binaryauthorization/PolicyClusterAdmissionRule:PolicyClusterAdmissionRule"
          },
          "description": "Per-cluster admission rules. An admission rule specifies either that\nall container images used in a pod creation request must be attested\nto by one or more attestors, that all pod creations will be allowed,\nor that all pod creations will be denied. There can be at most one\nadmission rule per cluster spec.\n"
        },
        "defaultAdmissionRule": {
          "$ref": "#/types/gcp:binaryauthorization/PolicyDefaultAdmissionRule:PolicyDefaultAdmissionRule",
          "description": "Default admission rule for a cluster without a per-cluster admission\nrule.\nStructure is documented below.\n"
        },
        "description": {
          "type": "string",
          "description": "A descriptive comment.\n"
        },
        "globalPolicyEvaluationMode": {
          "type": "string",
          "description": "Controls the evaluation of a Google-maintained global admission policy\nfor common system-level images. Images not covered by the global\npolicy will be subject to the project admission policy.\nPossible values are `ENABLE` and `DISABLE`.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "defaultAdmissionRule"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Policy resources.\n",
        "properties": {
          "admissionWhitelistPatterns": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:binaryauthorization/PolicyAdmissionWhitelistPattern:PolicyAdmissionWhitelistPattern"
            },
            "description": "A whitelist of image patterns to exclude from admission rules. If an\nimage's name matches a whitelist pattern, the image's admission\nrequests will always be permitted regardless of your admission rules.\nStructure is documented below.\n"
          },
          "clusterAdmissionRules": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:binaryauthorization/PolicyClusterAdmissionRule:PolicyClusterAdmissionRule"
            },
            "description": "Per-cluster admission rules. An admission rule specifies either that\nall container images used in a pod creation request must be attested\nto by one or more attestors, that all pod creations will be allowed,\nor that all pod creations will be denied. There can be at most one\nadmission rule per cluster spec.\n"
          },
          "defaultAdmissionRule": {
            "$ref": "#/types/gcp:binaryauthorization/PolicyDefaultAdmissionRule:PolicyDefaultAdmissionRule",
            "description": "Default admission rule for a cluster without a per-cluster admission\nrule.\nStructure is documented below.\n"
          },
          "description": {
            "type": "string",
            "description": "A descriptive comment.\n"
          },
          "globalPolicyEvaluationMode": {
            "type": "string",
            "description": "Controls the evaluation of a Google-maintained global admission policy\nfor common system-level images. Images not covered by the global\npolicy will be subject to the project admission policy.\nPossible values are `ENABLE` and `DISABLE`.\n"
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:certificatemanager/certificate:Certificate": {
      "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Certificate Manager Certificate Basic\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst instance = new gcp.certificatemanager.DnsAuthorization(\"instance\", {\n    description: \"The default dnss\",\n    domain: \"subdomain.hashicorptest.com\",\n});\nconst instance2 = new gcp.certificatemanager.DnsAuthorization(\"instance2\", {\n    description: \"The default dnss\",\n    domain: \"subdomain2.hashicorptest.com\",\n});\nconst _default = new gcp.certificatemanager.Certificate(\"default\", {\n    description: \"The default cert\",\n    scope: \"EDGE_CACHE\",\n    managed: {\n        domains: [\n            instance.domain,\n            instance2.domain,\n        ],\n        dnsAuthorizations: [\n            instance.id,\n            instance2.id,\n        ],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\ninstance = gcp.certificatemanager.DnsAuthorization(\"instance\",\n    description=\"The default dnss\",\n    domain=\"subdomain.hashicorptest.com\")\ninstance2 = gcp.certificatemanager.DnsAuthorization(\"instance2\",\n    description=\"The default dnss\",\n    domain=\"subdomain2.hashicorptest.com\")\ndefault = gcp.certificatemanager.Certificate(\"default\",\n    description=\"The default cert\",\n    scope=\"EDGE_CACHE\",\n    managed=gcp.certificatemanager.CertificateManagedArgs(\n        domains=[\n            instance.domain,\n            instance2.domain,\n        ],\n        dns_authorizations=[\n            instance.id,\n            instance2.id,\n        ],\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var instance = new Gcp.CertificateManager.DnsAuthorization(\"instance\", new()\n    {\n        Description = \"The default dnss\",\n        Domain = \"subdomain.hashicorptest.com\",\n    });\n\n    var instance2 = new Gcp.CertificateManager.DnsAuthorization(\"instance2\", new()\n    {\n        Description = \"The default dnss\",\n        Domain = \"subdomain2.hashicorptest.com\",\n    });\n\n    var @default = new Gcp.CertificateManager.Certificate(\"default\", new()\n    {\n        Description = \"The default cert\",\n        Scope = \"EDGE_CACHE\",\n        Managed = new Gcp.CertificateManager.Inputs.CertificateManagedArgs\n        {\n            Domains = new[]\n            {\n                instance.Domain,\n                instance2.Domain,\n            },\n            DnsAuthorizations = new[]\n            {\n                instance.Id,\n                instance2.Id,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/certificatemanager\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinstance, err := certificatemanager.NewDnsAuthorization(ctx, \"instance\", &certificatemanager.DnsAuthorizationArgs{\n\t\t\tDescription: pulumi.String(\"The default dnss\"),\n\t\t\tDomain:      pulumi.String(\"subdomain.hashicorptest.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinstance2, err := certificatemanager.NewDnsAuthorization(ctx, \"instance2\", &certificatemanager.DnsAuthorizationArgs{\n\t\t\tDescription: pulumi.String(\"The default dnss\"),\n\t\t\tDomain:      pulumi.String(\"subdomain2.hashicorptest.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = certificatemanager.NewCertificate(ctx, \"default\", &certificatemanager.CertificateArgs{\n\t\t\tDescription: pulumi.String(\"The default cert\"),\n\t\t\tScope:       pulumi.String(\"EDGE_CACHE\"),\n\t\t\tManaged: &certificatemanager.CertificateManagedArgs{\n\t\t\t\tDomains: pulumi.StringArray{\n\t\t\t\t\tinstance.Domain,\n\t\t\t\t\tinstance2.Domain,\n\t\t\t\t},\n\t\t\t\tDnsAuthorizations: pulumi.StringArray{\n\t\t\t\t\tinstance.ID(),\n\t\t\t\t\tinstance2.ID(),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.certificatemanager.DnsAuthorization;\nimport com.pulumi.gcp.certificatemanager.DnsAuthorizationArgs;\nimport com.pulumi.gcp.certificatemanager.Certificate;\nimport com.pulumi.gcp.certificatemanager.CertificateArgs;\nimport com.pulumi.gcp.certificatemanager.inputs.CertificateManagedArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var instance = new DnsAuthorization(\"instance\", DnsAuthorizationArgs.builder()        \n            .description(\"The default dnss\")\n            .domain(\"subdomain.hashicorptest.com\")\n            .build());\n\n        var instance2 = new DnsAuthorization(\"instance2\", DnsAuthorizationArgs.builder()        \n            .description(\"The default dnss\")\n            .domain(\"subdomain2.hashicorptest.com\")\n            .build());\n\n        var default_ = new Certificate(\"default\", CertificateArgs.builder()        \n            .description(\"The default cert\")\n            .scope(\"EDGE_CACHE\")\n            .managed(CertificateManagedArgs.builder()\n                .domains(                \n                    instance.domain(),\n                    instance2.domain())\n                .dnsAuthorizations(                \n                    instance.id(),\n                    instance2.id())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  default:\n    type: gcp:certificatemanager:Certificate\n    properties:\n      description: The default cert\n      scope: EDGE_CACHE\n      managed:\n        domains:\n          - ${instance.domain}\n          - ${instance2.domain}\n        dnsAuthorizations:\n          - ${instance.id}\n          - ${instance2.id}\n  instance:\n    type: gcp:certificatemanager:DnsAuthorization\n    properties:\n      description: The default dnss\n      domain: subdomain.hashicorptest.com\n  instance2:\n    type: gcp:certificatemanager:DnsAuthorization\n    properties:\n      description: The default dnss\n      domain: subdomain2.hashicorptest.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCertificate can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:certificatemanager/certificate:Certificate default projects/{{project}}/locations/global/certificates/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:certificatemanager/certificate:Certificate default {{project}}/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:certificatemanager/certificate:Certificate default {{name}}\n```\n\n ",
      "properties": {
        "description": {
          "type": "string",
          "description": "A human-readable description of the resource.\n"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Set of label tags associated with the Certificate resource.\n"
        },
        "managed": {
          "$ref": "#/types/gcp:certificatemanager/CertificateManaged:CertificateManaged",
          "description": "Configuration and state of a Managed Certificate.\nCertificate Manager provisions and renews Managed Certificates\nautomatically, for as long as it's authorized to do so.\nStructure is documented below.\n"
        },
        "name": {
          "type": "string",
          "description": "A user-defined name of the certificate. Certificate names must be unique\nThe name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,\nand all following characters must be a dash, underscore, letter or digit.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n"
        },
        "scope": {
          "type": "string",
          "description": "The scope of the certificate.\nDEFAULT: Certificates with default scope are served from core Google data centers.\nIf unsure, choose this option.\nEDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates,\nserved from non-core Google data centers.\nCurrently allowed only for managed certificates.\n"
        },
        "selfManaged": {
          "$ref": "#/types/gcp:certificatemanager/CertificateSelfManaged:CertificateSelfManaged",
          "description": "Certificate data for a SelfManaged Certificate.\nSelfManaged Certificates are uploaded by the user. Updating such\ncertificates before they expire remains the user's responsibility.\nStructure is documented below.\n"
        }
      },
      "required": [
        "name",
        "project"
      ],
      "inputProperties": {
        "description": {
          "type": "string",
          "description": "A human-readable description of the resource.\n"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Set of label tags associated with the Certificate resource.\n"
        },
        "managed": {
          "$ref": "#/types/gcp:certificatemanager/CertificateManaged:CertificateManaged",
          "willReplaceOnChanges": true,
          "description": "Configuration and state of a Managed Certificate.\nCertificate Manager provisions and renews Managed Certificates\nautomatically, for as long as it's authorized to do so.\nStructure is documented below.\n"
        },
        "name": {
          "type": "string",
          "description": "A user-defined name of the certificate. Certificate names must be unique\nThe name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,\nand all following characters must be a dash, underscore, letter or digit.\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        },
        "scope": {
          "type": "string",
          "description": "The scope of the certificate.\nDEFAULT: Certificates with default scope are served from core Google data centers.\nIf unsure, choose this option.\nEDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates,\nserved from non-core Google data centers.\nCurrently allowed only for managed certificates.\n",
          "willReplaceOnChanges": true
        },
        "selfManaged": {
          "$ref": "#/types/gcp:certificatemanager/CertificateSelfManaged:CertificateSelfManaged",
          "willReplaceOnChanges": true,
          "description": "Certificate data for a SelfManaged Certificate.\nSelfManaged Certificates are uploaded by the user. Updating such\ncertificates before they expire remains the user's responsibility.\nStructure is documented below.\n"
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Certificate resources.\n",
        "properties": {
          "description": {
            "type": "string",
            "description": "A human-readable description of the resource.\n"
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Set of label tags associated with the Certificate resource.\n"
          },
          "managed": {
            "$ref": "#/types/gcp:certificatemanager/CertificateManaged:CertificateManaged",
            "description": "Configuration and state of a Managed Certificate.\nCertificate Manager provisions and renews Managed Certificates\nautomatically, for as long as it's authorized to do so.\nStructure is documented below.\n",
            "willReplaceOnChanges": true
          },
          "name": {
            "type": "string",
            "description": "A user-defined name of the certificate. Certificate names must be unique\nThe name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,\nand all following characters must be a dash, underscore, letter or digit.\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          },
          "scope": {
            "type": "string",
            "description": "The scope of the certificate.\nDEFAULT: Certificates with default scope are served from core Google data centers.\nIf unsure, choose this option.\nEDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates,\nserved from non-core Google data centers.\nCurrently allowed only for managed certificates.\n",
            "willReplaceOnChanges": true
          },
          "selfManaged": {
            "$ref": "#/types/gcp:certificatemanager/CertificateSelfManaged:CertificateSelfManaged",
            "description": "Certificate data for a SelfManaged Certificate.\nSelfManaged Certificates are uploaded by the user. Updating such\ncertificates before they expire remains the user's responsibility.\nStructure is documented below.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:cloudasset/folderFeed:FolderFeed": {
      "description": "Describes a Cloud Asset Inventory feed used to to listen to asset updates.\n\n\nTo get more information about FolderFeed, see:\n\n* [API documentation](https://cloud.google.com/asset-inventory/docs/reference/rest/)\n* How-to Guides\n    * [Official Documentation](https://cloud.google.com/asset-inventory/docs)\n\n{{% examples %}}\n## Example Usage\n{{% /examples %}}\n\n## Import\n\nFolderFeed can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:cloudasset/folderFeed:FolderFeed default folders/{{folder_id}}/feeds/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:cloudasset/folderFeed:FolderFeed default {{folder_id}}/{{name}}\n```\n\n ",
      "properties": {
        "assetNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of the full names of the assets to receive updates. You must specify either or both of\nassetNames and assetTypes. Only asset updates matching specified assetNames and assetTypes are\nexported to the feed. For example: //compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1.\nSee https://cloud.google.com/apis/design/resourceNames#fullResourceName for more info.\n"
        },
        "assetTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of types of the assets to receive updates. You must specify either or both of assetNames\nand assetTypes. Only asset updates matching specified assetNames and assetTypes are exported to\nthe feed. For example: \"compute.googleapis.com/Disk\"\nSee https://cloud.google.com/asset-inventory/docs/supported-asset-types for a list of all\nsupported asset types.\n"
        },
        "billingProject": {
          "type": "string",
          "description": "The project whose identity will be used when sending messages to the\ndestination pubsub topic. It also specifies the project for API\nenablement check, quota, and billing.\n"
        },
        "condition": {
          "$ref": "#/types/gcp:cloudasset/FolderFeedCondition:FolderFeedCondition",
          "description": "A condition which determines whether an asset update should be published. If specified, an asset\nwill be returned only when the expression evaluates to true. When set, expression field\nmust be a valid CEL expression on a TemporalAsset with name temporal_asset. Example: a Feed with\nexpression \"temporal_asset.deleted == true\" will only publish Asset deletions. Other fields of\ncondition are optional.\nStructure is documented below.\n"
        },
        "contentType": {
          "type": "string",
          "description": "Asset content type. If not specified, no content but the asset name and type will be returned.\nPossible values are `CONTENT_TYPE_UNSPECIFIED`, `RESOURCE`, `IAM_POLICY`, `ORG_POLICY`, and `ACCESS_POLICY`.\n"
        },
        "feedId": {
          "type": "string",
          "description": "This is the client-assigned asset feed identifier and it needs to be unique under a specific parent.\n"
        },
        "feedOutputConfig": {
          "$ref": "#/types/gcp:cloudasset/FolderFeedFeedOutputConfig:FolderFeedFeedOutputConfig",
          "description": "Output configuration for asset feed destination.\nStructure is documented below.\n"
        },
        "folder": {
          "type": "string",
          "description": "The folder this feed should be created in.\n"
        },
        "folderId": {
          "type": "string",
          "description": "The ID of the folder where this feed has been created. Both [FOLDER_NUMBER] and folders/[FOLDER_NUMBER] are accepted.\n"
        },
        "name": {
          "type": "string",
          "description": "The format will be folders/{folder_number}/feeds/{client-assigned_feed_identifier}.\n"
        }
      },
      "required": [
        "billingProject",
        "feedId",
        "feedOutputConfig",
        "folder",
        "folderId",
        "name"
      ],
      "inputProperties": {
        "assetNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of the full names of the assets to receive updates. You must specify either or both of\nassetNames and assetTypes. Only asset updates matching specified assetNames and assetTypes are\nexported to the feed. For example: //compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1.\nSee https://cloud.google.com/apis/design/resourceNames#fullResourceName for more info.\n"
        },
        "assetTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of types of the assets to receive updates. You must specify either or both of assetNames\nand assetTypes. Only asset updates matching specified assetNames and assetTypes are exported to\nthe feed. For example: \"compute.googleapis.com/Disk\"\nSee https://cloud.google.com/asset-inventory/docs/supported-asset-types for a list of all\nsupported asset types.\n"
        },
        "billingProject": {
          "type": "string",
          "description": "The project whose identity will be used when sending messages to the\ndestination pubsub topic. It also specifies the project for API\nenablement check, quota, and billing.\n",
          "willReplaceOnChanges": true
        },
        "condition": {
          "$ref": "#/types/gcp:cloudasset/FolderFeedCondition:FolderFeedCondition",
          "description": "A condition which determines whether an asset update should be published. If specified, an asset\nwill be returned only when the expression evaluates to true. When set, expression field\nmust be a valid CEL expression on a TemporalAsset with name temporal_asset. Example: a Feed with\nexpression \"temporal_asset.deleted == true\" will only publish Asset deletions. Other fields of\ncondition are optional.\nStructure is documented below.\n"
        },
        "contentType": {
          "type": "string",
          "description": "Asset content type. If not specified, no content but the asset name and type will be returned.\nPossible values are `CONTENT_TYPE_UNSPECIFIED`, `RESOURCE`, `IAM_POLICY`, `ORG_POLICY`, and `ACCESS_POLICY`.\n"
        },
        "feedId": {
          "type": "string",
          "description": "This is the client-assigned asset feed identifier and it needs to be unique under a specific parent.\n",
          "willReplaceOnChanges": true
        },
        "feedOutputConfig": {
          "$ref": "#/types/gcp:cloudasset/FolderFeedFeedOutputConfig:FolderFeedFeedOutputConfig",
          "description": "Output configuration for asset feed destination.\nStructure is documented below.\n"
        },
        "folder": {
          "type": "string",
          "description": "The folder this feed should be created in.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "billingProject",
        "feedId",
        "feedOutputConfig",
        "folder"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering FolderFeed resources.\n",
        "properties": {
          "assetNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of the full names of the assets to receive updates. You must specify either or both of\nassetNames and assetTypes. Only asset updates matching specified assetNames and assetTypes are\nexported to the feed. For example: //compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1.\nSee https://cloud.google.com/apis/design/resourceNames#fullResourceName for more info.\n"
          },
          "assetTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of types of the assets to receive updates. You must specify either or both of assetNames\nand assetTypes. Only asset updates matching specified assetNames and assetTypes are exported to\nthe feed. For example: \"compute.googleapis.com/Disk\"\nSee https://cloud.google.com/asset-inventory/docs/supported-asset-types for a list of all\nsupported asset types.\n"
          },
          "billingProject": {
            "type": "string",
            "description": "The project whose identity will be used when sending messages to the\ndestination pubsub topic. It also specifies the project for API\nenablement check, quota, and billing.\n",
            "willReplaceOnChanges": true
          },
          "condition": {
            "$ref": "#/types/gcp:cloudasset/FolderFeedCondition:FolderFeedCondition",
            "description": "A condition which determines whether an asset update should be published. If specified, an asset\nwill be returned only when the expression evaluates to true. When set, expression field\nmust be a valid CEL expression on a TemporalAsset with name temporal_asset. Example: a Feed with\nexpression \"temporal_asset.deleted == true\" will only publish Asset deletions. Other fields of\ncondition are optional.\nStructure is documented below.\n"
          },
          "contentType": {
            "type": "string",
            "description": "Asset content type. If not specified, no content but the asset name and type will be returned.\nPossible values are `CONTENT_TYPE_UNSPECIFIED`, `RESOURCE`, `IAM_POLICY`, `ORG_POLICY`, and `ACCESS_POLICY`.\n"
          },
          "feedId": {
            "type": "string",
            "description": "This is the client-assigned asset feed identifier and it needs to be unique under a specific parent.\n",
            "willReplaceOnChanges": true
          },
          "feedOutputConfig": {
            "$ref": "#/types/gcp:cloudasset/FolderFeedFeedOutputConfig:FolderFeedFeedOutputConfig",
            "description": "Output configuration for asset feed destination.\nStructure is documented below.\n"
          },
          "folder": {
            "type": "string",
            "description": "The folder this feed should be created in.\n",
            "willReplaceOnChanges": true
          },
          "folderId": {
            "type": "string",
            "description": "The ID of the folder where this feed has been created. Both [FOLDER_NUMBER] and folders/[FOLDER_NUMBER] are accepted.\n"
          },
          "name": {
            "type": "string",
            "description": "The format will be folders/{folder_number}/feeds/{client-assigned_feed_identifier}.\n"
          }
        },
        "type": "object"
      }
    },
    "gcp:cloudasset/organizationFeed:OrganizationFeed": {
      "description": "Describes a Cloud Asset Inventory feed used to to listen to asset updates.\n\n\nTo get more information about OrganizationFeed, see:\n\n* [API documentation](https://cloud.google.com/asset-inventory/docs/reference/rest/)\n* How-to Guides\n    * [Official Documentation](https://cloud.google.com/asset-inventory/docs)\n\n{{% examples %}}\n## Example Usage\n{{% /examples %}}\n\n## Import\n\nOrganizationFeed can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:cloudasset/organizationFeed:OrganizationFeed default organizations/{{org_id}}/feeds/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:cloudasset/organizationFeed:OrganizationFeed default {{org_id}}/{{name}}\n```\n\n ",
      "properties": {
        "assetNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of the full names of the assets to receive updates. You must specify either or both of\nassetNames and assetTypes. Only asset updates matching specified assetNames and assetTypes are\nexported to the feed. For example: //compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1.\nSee https://cloud.google.com/apis/design/resourceNames#fullResourceName for more info.\n"
        },
        "assetTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of types of the assets to receive updates. You must specify either or both of assetNames\nand assetTypes. Only asset updates matching specified assetNames and assetTypes are exported to\nthe feed. For example: \"compute.googleapis.com/Disk\"\nSee https://cloud.google.com/asset-inventory/docs/supported-asset-types for a list of all\nsupported asset types.\n"
        },
        "billingProject": {
          "type": "string",
          "description": "The project whose identity will be used when sending messages to the\ndestination pubsub topic. It also specifies the project for API\nenablement check, quota, and billing.\n"
        },
        "condition": {
          "$ref": "#/types/gcp:cloudasset/OrganizationFeedCondition:OrganizationFeedCondition",
          "description": "A condition which determines whether an asset update should be published. If specified, an asset\nwill be returned only when the expression evaluates to true. When set, expression field\nmust be a valid CEL expression on a TemporalAsset with name temporal_asset. Example: a Feed with\nexpression \"temporal_asset.deleted == true\" will only publish Asset deletions. Other fields of\ncondition are optional.\nStructure is documented below.\n"
        },
        "contentType": {
          "type": "string",
          "description": "Asset content type. If not specified, no content but the asset name and type will be returned.\nPossible values are `CONTENT_TYPE_UNSPECIFIED`, `RESOURCE`, `IAM_POLICY`, `ORG_POLICY`, and `ACCESS_POLICY`.\n"
        },
        "feedId": {
          "type": "string",
          "description": "This is the client-assigned asset feed identifier and it needs to be unique under a specific parent.\n"
        },
        "feedOutputConfig": {
          "$ref": "#/types/gcp:cloudasset/OrganizationFeedFeedOutputConfig:OrganizationFeedFeedOutputConfig",
          "description": "Output configuration for asset feed destination.\nStructure is documented below.\n"
        },
        "name": {
          "type": "string",
          "description": "The format will be organizations/{organization_number}/feeds/{client-assigned_feed_identifier}.\n"
        },
        "orgId": {
          "type": "string",
          "description": "The organization this feed should be created in.\n"
        }
      },
      "required": [
        "billingProject",
        "feedId",
        "feedOutputConfig",
        "name",
        "orgId"
      ],
      "inputProperties": {
        "assetNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of the full names of the assets to receive updates. You must specify either or both of\nassetNames and assetTypes. Only asset updates matching specified assetNames and assetTypes are\nexported to the feed. For example: //compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1.\nSee https://cloud.google.com/apis/design/resourceNames#fullResourceName for more info.\n"
        },
        "assetTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of types of the assets to receive updates. You must specify either or both of assetNames\nand assetTypes. Only asset updates matching specified assetNames and assetTypes are exported to\nthe feed. For example: \"compute.googleapis.com/Disk\"\nSee https://cloud.google.com/asset-inventory/docs/supported-asset-types for a list of all\nsupported asset types.\n"
        },
        "billingProject": {
          "type": "string",
          "description": "The project whose identity will be used when sending messages to the\ndestination pubsub topic. It also specifies the project for API\nenablement check, quota, and billing.\n",
          "willReplaceOnChanges": true
        },
        "condition": {
          "$ref": "#/types/gcp:cloudasset/OrganizationFeedCondition:OrganizationFeedCondition",
          "description": "A condition which determines whether an asset update should be published. If specified, an asset\nwill be returned only when the expression evaluates to true. When set, expression field\nmust be a valid CEL expression on a TemporalAsset with name temporal_asset. Example: a Feed with\nexpression \"temporal_asset.deleted == true\" will only publish Asset deletions. Other fields of\ncondition are optional.\nStructure is documented below.\n"
        },
        "contentType": {
          "type": "string",
          "description": "Asset content type. If not specified, no content but the asset name and type will be returned.\nPossible values are `CONTENT_TYPE_UNSPECIFIED`, `RESOURCE`, `IAM_POLICY`, `ORG_POLICY`, and `ACCESS_POLICY`.\n"
        },
        "feedId": {
          "type": "string",
          "description": "This is the client-assigned asset feed identifier and it needs to be unique under a specific parent.\n",
          "willReplaceOnChanges": true
        },
        "feedOutputConfig": {
          "$ref": "#/types/gcp:cloudasset/OrganizationFeedFeedOutputConfig:OrganizationFeedFeedOutputConfig",
          "description": "Output configuration for asset feed destination.\nStructure is documented below.\n"
        },
        "orgId": {
          "type": "string",
          "description": "The organization this feed should be created in.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "billingProject",
        "feedId",
        "feedOutputConfig",
        "orgId"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering OrganizationFeed resources.\n",
        "properties": {
          "assetNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of the full names of the assets to receive updates. You must specify either or both of\nassetNames and assetTypes. Only asset updates matching specified assetNames and assetTypes are\nexported to the feed. For example: //compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1.\nSee https://cloud.google.com/apis/design/resourceNames#fullResourceName for more info.\n"
          },
          "assetTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of types of the assets to receive updates. You must specify either or both of assetNames\nand assetTypes. Only asset updates matching specified assetNames and assetTypes are exported to\nthe feed. For example: \"compute.googleapis.com/Disk\"\nSee https://cloud.google.com/asset-inventory/docs/supported-asset-types for a list of all\nsupported asset types.\n"
          },
          "billingProject": {
            "type": "string",
            "description": "The project whose identity will be used when sending messages to the\ndestination pubsub topic. It also specifies the project for API\nenablement check, quota, and billing.\n",
            "willReplaceOnChanges": true
          },
          "condition": {
            "$ref": "#/types/gcp:cloudasset/OrganizationFeedCondition:OrganizationFeedCondition",
            "description": "A condition which determines whether an asset update should be published. If specified, an asset\nwill be returned only when the expression evaluates to true. When set, expression field\nmust be a valid CEL expression on a TemporalAsset with name temporal_asset. Example: a Feed with\nexpression \"temporal_asset.deleted == true\" will only publish Asset deletions. Other fields of\ncondition are optional.\nStructure is documented below.\n"
          },
          "contentType": {
            "type": "string",
            "description": "Asset content type. If not specified, no content but the asset name and type will be returned.\nPossible values are `CONTENT_TYPE_UNSPECIFIED`, `RESOURCE`, `IAM_POLICY`, `ORG_POLICY`, and `ACCESS_POLICY`.\n"
          },
          "feedId": {
            "type": "string",
            "description": "This is the client-assigned asset feed identifier and it needs to be unique under a specific parent.\n",
            "willReplaceOnChanges": true
          },
          "feedOutputConfig": {
            "$ref": "#/types/gcp:cloudasset/OrganizationFeedFeedOutputConfig:OrganizationFeedFeedOutputConfig",
            "description": "Output configuration for asset feed destination.\nStructure is documented below.\n"
          },
          "name": {
            "type": "string",
            "description": "The format will be organizations/{organization_number}/feeds/{client-assigned_feed_identifier}.\n"
          },
          "orgId": {
            "type": "string",
            "description": "The organization this feed should be created in.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:cloudasset/projectFeed:ProjectFeed": {
      "description": "Describes a Cloud Asset Inventory feed used to to listen to asset updates.\n\n\nTo get more information about ProjectFeed, see:\n\n* [API documentation](https://cloud.google.com/asset-inventory/docs/reference/rest/)\n* How-to Guides\n    * [Official Documentation](https://cloud.google.com/asset-inventory/docs)\n\n{{% examples %}}\n## Example Usage\n{{% /examples %}}\n\n## Import\n\nProjectFeed can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:cloudasset/projectFeed:ProjectFeed default projects/{{project}}/feeds/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:cloudasset/projectFeed:ProjectFeed default {{project}}/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:cloudasset/projectFeed:ProjectFeed default {{name}}\n```\n\n ",
      "properties": {
        "assetNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of the full names of the assets to receive updates. You must specify either or both of\nassetNames and assetTypes. Only asset updates matching specified assetNames and assetTypes are\nexported to the feed. For example: //compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1.\nSee https://cloud.google.com/apis/design/resourceNames#fullResourceName for more info.\n"
        },
        "assetTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of types of the assets to receive updates. You must specify either or both of assetNames\nand assetTypes. Only asset updates matching specified assetNames and assetTypes are exported to\nthe feed. For example: \"compute.googleapis.com/Disk\"\nSee https://cloud.google.com/asset-inventory/docs/supported-asset-types for a list of all\nsupported asset types.\n"
        },
        "billingProject": {
          "type": "string",
          "description": "The project whose identity will be used when sending messages to the\ndestination pubsub topic. It also specifies the project for API\nenablement check, quota, and billing. If not specified, the resource's\nproject will be used.\n"
        },
        "condition": {
          "$ref": "#/types/gcp:cloudasset/ProjectFeedCondition:ProjectFeedCondition",
          "description": "A condition which determines whether an asset update should be published. If specified, an asset\nwill be returned only when the expression evaluates to true. When set, expression field\nmust be a valid CEL expression on a TemporalAsset with name temporal_asset. Example: a Feed with\nexpression \"temporal_asset.deleted == true\" will only publish Asset deletions. Other fields of\ncondition are optional.\nStructure is documented below.\n"
        },
        "contentType": {
          "type": "string",
          "description": "Asset content type. If not specified, no content but the asset name and type will be returned.\nPossible values are `CONTENT_TYPE_UNSPECIFIED`, `RESOURCE`, `IAM_POLICY`, `ORG_POLICY`, and `ACCESS_POLICY`.\n"
        },
        "feedId": {
          "type": "string",
          "description": "This is the client-assigned asset feed identifier and it needs to be unique under a specific parent.\n"
        },
        "feedOutputConfig": {
          "$ref": "#/types/gcp:cloudasset/ProjectFeedFeedOutputConfig:ProjectFeedFeedOutputConfig",
          "description": "Output configuration for asset feed destination.\nStructure is documented below.\n"
        },
        "name": {
          "type": "string",
          "description": "The format will be projects/{projectNumber}/feeds/{client-assigned_feed_identifier}.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n"
        }
      },
      "required": [
        "feedId",
        "feedOutputConfig",
        "name",
        "project"
      ],
      "inputProperties": {
        "assetNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of the full names of the assets to receive updates. You must specify either or both of\nassetNames and assetTypes. Only asset updates matching specified assetNames and assetTypes are\nexported to the feed. For example: //compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1.\nSee https://cloud.google.com/apis/design/resourceNames#fullResourceName for more info.\n"
        },
        "assetTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of types of the assets to receive updates. You must specify either or both of assetNames\nand assetTypes. Only asset updates matching specified assetNames and assetTypes are exported to\nthe feed. For example: \"compute.googleapis.com/Disk\"\nSee https://cloud.google.com/asset-inventory/docs/supported-asset-types for a list of all\nsupported asset types.\n"
        },
        "billingProject": {
          "type": "string",
          "description": "The project whose identity will be used when sending messages to the\ndestination pubsub topic. It also specifies the project for API\nenablement check, quota, and billing. If not specified, the resource's\nproject will be used.\n",
          "willReplaceOnChanges": true
        },
        "condition": {
          "$ref": "#/types/gcp:cloudasset/ProjectFeedCondition:ProjectFeedCondition",
          "description": "A condition which determines whether an asset update should be published. If specified, an asset\nwill be returned only when the expression evaluates to true. When set, expression field\nmust be a valid CEL expression on a TemporalAsset with name temporal_asset. Example: a Feed with\nexpression \"temporal_asset.deleted == true\" will only publish Asset deletions. Other fields of\ncondition are optional.\nStructure is documented below.\n"
        },
        "contentType": {
          "type": "string",
          "description": "Asset content type. If not specified, no content but the asset name and type will be returned.\nPossible values are `CONTENT_TYPE_UNSPECIFIED`, `RESOURCE`, `IAM_POLICY`, `ORG_POLICY`, and `ACCESS_POLICY`.\n"
        },
        "feedId": {
          "type": "string",
          "description": "This is the client-assigned asset feed identifier and it needs to be unique under a specific parent.\n",
          "willReplaceOnChanges": true
        },
        "feedOutputConfig": {
          "$ref": "#/types/gcp:cloudasset/ProjectFeedFeedOutputConfig:ProjectFeedFeedOutputConfig",
          "description": "Output configuration for asset feed destination.\nStructure is documented below.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "feedId",
        "feedOutputConfig"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering ProjectFeed resources.\n",
        "properties": {
          "assetNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of the full names of the assets to receive updates. You must specify either or both of\nassetNames and assetTypes. Only asset updates matching specified assetNames and assetTypes are\nexported to the feed. For example: //compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1.\nSee https://cloud.google.com/apis/design/resourceNames#fullResourceName for more info.\n"
          },
          "assetTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of types of the assets to receive updates. You must specify either or both of assetNames\nand assetTypes. Only asset updates matching specified assetNames and assetTypes are exported to\nthe feed. For example: \"compute.googleapis.com/Disk\"\nSee https://cloud.google.com/asset-inventory/docs/supported-asset-types for a list of all\nsupported asset types.\n"
          },
          "billingProject": {
            "type": "string",
            "description": "The project whose identity will be used when sending messages to the\ndestination pubsub topic. It also specifies the project for API\nenablement check, quota, and billing. If not specified, the resource's\nproject will be used.\n",
            "willReplaceOnChanges": true
          },
          "condition": {
            "$ref": "#/types/gcp:cloudasset/ProjectFeedCondition:ProjectFeedCondition",
            "description": "A condition which determines whether an asset update should be published. If specified, an asset\nwill be returned only when the expression evaluates to true. When set, expression field\nmust be a valid CEL expression on a TemporalAsset with name temporal_asset. Example: a Feed with\nexpression \"temporal_asset.deleted == true\" will only publish Asset deletions. Other fields of\ncondition are optional.\nStructure is documented below.\n"
          },
          "contentType": {
            "type": "string",
            "description": "Asset content type. If not specified, no content but the asset name and type will be returned.\nPossible values are `CONTENT_TYPE_UNSPECIFIED`, `RESOURCE`, `IAM_POLICY`, `ORG_POLICY`, and `ACCESS_POLICY`.\n"
          },
          "feedId": {
            "type": "string",
            "description": "This is the client-assigned asset feed identifier and it needs to be unique under a specific parent.\n",
            "willReplaceOnChanges": true
          },
          "feedOutputConfig": {
            "$ref": "#/types/gcp:cloudasset/ProjectFeedFeedOutputConfig:ProjectFeedFeedOutputConfig",
            "description": "Output configuration for asset feed destination.\nStructure is documented below.\n"
          },
          "name": {
            "type": "string",
            "description": "The format will be projects/{projectNumber}/feeds/{client-assigned_feed_identifier}.\n"
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          }
        },
        "type": "object"
      }
    },
    "gcp:clouddeploy/deliveryPipeline:DeliveryPipeline": {
      "description": "The Cloud Deploy `DeliveryPipeline` resource\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Delivery_pipeline\nCreates a basic Cloud Deploy delivery pipeline\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst primary = new gcp.clouddeploy.DeliveryPipeline(\"primary\", {\n    annotations: {\n        my_first_annotation: \"example-annotation-1\",\n        my_second_annotation: \"example-annotation-2\",\n    },\n    description: \"basic description\",\n    labels: {\n        my_first_label: \"example-label-1\",\n        my_second_label: \"example-label-2\",\n    },\n    location: \"us-west1\",\n    project: \"my-project-name\",\n    serialPipeline: {\n        stages: [\n            {\n                profiles: [\n                    \"example-profile-one\",\n                    \"example-profile-two\",\n                ],\n                targetId: \"example-target-one\",\n            },\n            {\n                profiles: [],\n                targetId: \"example-target-two\",\n            },\n        ],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nprimary = gcp.clouddeploy.DeliveryPipeline(\"primary\",\n    annotations={\n        \"my_first_annotation\": \"example-annotation-1\",\n        \"my_second_annotation\": \"example-annotation-2\",\n    },\n    description=\"basic description\",\n    labels={\n        \"my_first_label\": \"example-label-1\",\n        \"my_second_label\": \"example-label-2\",\n    },\n    location=\"us-west1\",\n    project=\"my-project-name\",\n    serial_pipeline=gcp.clouddeploy.DeliveryPipelineSerialPipelineArgs(\n        stages=[\n            gcp.clouddeploy.DeliveryPipelineSerialPipelineStageArgs(\n                profiles=[\n                    \"example-profile-one\",\n                    \"example-profile-two\",\n                ],\n                target_id=\"example-target-one\",\n            ),\n            gcp.clouddeploy.DeliveryPipelineSerialPipelineStageArgs(\n                profiles=[],\n                target_id=\"example-target-two\",\n            ),\n        ],\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var primary = new Gcp.CloudDeploy.DeliveryPipeline(\"primary\", new()\n    {\n        Annotations = \n        {\n            { \"my_first_annotation\", \"example-annotation-1\" },\n            { \"my_second_annotation\", \"example-annotation-2\" },\n        },\n        Description = \"basic description\",\n        Labels = \n        {\n            { \"my_first_label\", \"example-label-1\" },\n            { \"my_second_label\", \"example-label-2\" },\n        },\n        Location = \"us-west1\",\n        Project = \"my-project-name\",\n        SerialPipeline = new Gcp.CloudDeploy.Inputs.DeliveryPipelineSerialPipelineArgs\n        {\n            Stages = new[]\n            {\n                new Gcp.CloudDeploy.Inputs.DeliveryPipelineSerialPipelineStageArgs\n                {\n                    Profiles = new[]\n                    {\n                        \"example-profile-one\",\n                        \"example-profile-two\",\n                    },\n                    TargetId = \"example-target-one\",\n                },\n                new Gcp.CloudDeploy.Inputs.DeliveryPipelineSerialPipelineStageArgs\n                {\n                    Profiles = new[] {},\n                    TargetId = \"example-target-two\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/clouddeploy\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := clouddeploy.NewDeliveryPipeline(ctx, \"primary\", &clouddeploy.DeliveryPipelineArgs{\n\t\t\tAnnotations: pulumi.StringMap{\n\t\t\t\t\"my_first_annotation\":  pulumi.String(\"example-annotation-1\"),\n\t\t\t\t\"my_second_annotation\": pulumi.String(\"example-annotation-2\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"basic description\"),\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"my_first_label\":  pulumi.String(\"example-label-1\"),\n\t\t\t\t\"my_second_label\": pulumi.String(\"example-label-2\"),\n\t\t\t},\n\t\t\tLocation: pulumi.String(\"us-west1\"),\n\t\t\tProject:  pulumi.String(\"my-project-name\"),\n\t\t\tSerialPipeline: &clouddeploy.DeliveryPipelineSerialPipelineArgs{\n\t\t\t\tStages: clouddeploy.DeliveryPipelineSerialPipelineStageArray{\n\t\t\t\t\t&clouddeploy.DeliveryPipelineSerialPipelineStageArgs{\n\t\t\t\t\t\tProfiles: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"example-profile-one\"),\n\t\t\t\t\t\t\tpulumi.String(\"example-profile-two\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTargetId: pulumi.String(\"example-target-one\"),\n\t\t\t\t\t},\n\t\t\t\t\t&clouddeploy.DeliveryPipelineSerialPipelineStageArgs{\n\t\t\t\t\t\tProfiles: pulumi.StringArray{},\n\t\t\t\t\t\tTargetId: pulumi.String(\"example-target-two\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.clouddeploy.DeliveryPipeline;\nimport com.pulumi.gcp.clouddeploy.DeliveryPipelineArgs;\nimport com.pulumi.gcp.clouddeploy.inputs.DeliveryPipelineSerialPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var primary = new DeliveryPipeline(\"primary\", DeliveryPipelineArgs.builder()        \n            .annotations(Map.ofEntries(\n                Map.entry(\"my_first_annotation\", \"example-annotation-1\"),\n                Map.entry(\"my_second_annotation\", \"example-annotation-2\")\n            ))\n            .description(\"basic description\")\n            .labels(Map.ofEntries(\n                Map.entry(\"my_first_label\", \"example-label-1\"),\n                Map.entry(\"my_second_label\", \"example-label-2\")\n            ))\n            .location(\"us-west1\")\n            .project(\"my-project-name\")\n            .serialPipeline(DeliveryPipelineSerialPipelineArgs.builder()\n                .stages(                \n                    DeliveryPipelineSerialPipelineStageArgs.builder()\n                        .profiles(                        \n                            \"example-profile-one\",\n                            \"example-profile-two\")\n                        .targetId(\"example-target-one\")\n                        .build(),\n                    DeliveryPipelineSerialPipelineStageArgs.builder()\n                        .profiles()\n                        .targetId(\"example-target-two\")\n                        .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  primary:\n    type: gcp:clouddeploy:DeliveryPipeline\n    properties:\n      annotations:\n        my_first_annotation: example-annotation-1\n        my_second_annotation: example-annotation-2\n      description: basic description\n      labels:\n        my_first_label: example-label-1\n        my_second_label: example-label-2\n      location: us-west1\n      project: my-project-name\n      serialPipeline:\n        stages:\n          - profiles:\n              - example-profile-one\n              - example-profile-two\n            targetId: example-target-one\n          - profiles: []\n            targetId: example-target-two\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDeliveryPipeline can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:clouddeploy/deliveryPipeline:DeliveryPipeline default projects/{{project}}/locations/{{location}}/deliveryPipelines/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:clouddeploy/deliveryPipeline:DeliveryPipeline default {{project}}/{{location}}/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:clouddeploy/deliveryPipeline:DeliveryPipeline default {{location}}/{{name}}\n```\n\n ",
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "User annotations. These attributes can only be set and used by the user, and not by Google Cloud Deploy. See https://google.aip.dev/128#annotations for more details such as format and size limitations.\n"
        },
        "conditions": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:clouddeploy/DeliveryPipelineCondition:DeliveryPipelineCondition"
          },
          "description": "Output only. Information around the state of the Delivery Pipeline.\n"
        },
        "createTime": {
          "type": "string",
          "description": "Output only. Time at which the pipeline was created.\n"
        },
        "description": {
          "type": "string",
          "description": "Description of the `DeliveryPipeline`. Max length is 255 characters.\n"
        },
        "etag": {
          "type": "string",
          "description": "This checksum is computed by the server based on the value of other fields, and may be sent on update and delete\nrequests to ensure the client has an up-to-date value before proceeding.\n"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels are attributes that can be set and used by both the user and by Google Cloud Deploy. Labels must meet the following constraints: * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. * All characters must use UTF-8 encoding, and international characters are allowed. * Keys must start with a lowercase letter or international character. * Each resource is limited to a maximum of 64 labels. Both keys and values are additionally constrained to be <= 128 bytes.\n"
        },
        "location": {
          "type": "string",
          "description": "The location for the resource\n"
        },
        "name": {
          "type": "string",
          "description": "Name of the `DeliveryPipeline`. Format is [a-z][a-z0-9\\-]{0,62}.\n"
        },
        "project": {
          "type": "string",
          "description": "The project for the resource\n"
        },
        "serialPipeline": {
          "$ref": "#/types/gcp:clouddeploy/DeliveryPipelineSerialPipeline:DeliveryPipelineSerialPipeline",
          "description": "SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.\n"
        },
        "suspended": {
          "type": "boolean",
          "description": "When suspended, no new releases or rollouts can be created, but in-progress ones will complete.\n"
        },
        "uid": {
          "type": "string",
          "description": "Output only. Unique identifier of the `DeliveryPipeline`.\n"
        },
        "updateTime": {
          "type": "string",
          "description": "Output only. Most recent time at which the pipeline was updated.\n"
        }
      },
      "required": [
        "conditions",
        "createTime",
        "etag",
        "location",
        "name",
        "project",
        "uid",
        "updateTime"
      ],
      "inputProperties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "User annotations. These attributes can only be set and used by the user, and not by Google Cloud Deploy. See https://google.aip.dev/128#annotations for more details such as format and size limitations.\n"
        },
        "description": {
          "type": "string",
          "description": "Description of the `DeliveryPipeline`. Max length is 255 characters.\n"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels are attributes that can be set and used by both the user and by Google Cloud Deploy. Labels must meet the following constraints: * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. * All characters must use UTF-8 encoding, and international characters are allowed. * Keys must start with a lowercase letter or international character. * Each resource is limited to a maximum of 64 labels. Both keys and values are additionally constrained to be <= 128 bytes.\n"
        },
        "location": {
          "type": "string",
          "description": "The location for the resource\n",
          "willReplaceOnChanges": true
        },
        "name": {
          "type": "string",
          "description": "Name of the `DeliveryPipeline`. Format is [a-z][a-z0-9\\-]{0,62}.\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The project for the resource\n",
          "willReplaceOnChanges": true
        },
        "serialPipeline": {
          "$ref": "#/types/gcp:clouddeploy/DeliveryPipelineSerialPipeline:DeliveryPipelineSerialPipeline",
          "description": "SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.\n"
        },
        "suspended": {
          "type": "boolean",
          "description": "When suspended, no new releases or rollouts can be created, but in-progress ones will complete.\n"
        }
      },
      "requiredInputs": [
        "location"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering DeliveryPipeline resources.\n",
        "properties": {
          "annotations": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "User annotations. These attributes can only be set and used by the user, and not by Google Cloud Deploy. See https://google.aip.dev/128#annotations for more details such as format and size limitations.\n"
          },
          "conditions": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:clouddeploy/DeliveryPipelineCondition:DeliveryPipelineCondition"
            },
            "description": "Output only. Information around the state of the Delivery Pipeline.\n"
          },
          "createTime": {
            "type": "string",
            "description": "Output only. Time at which the pipeline was created.\n"
          },
          "description": {
            "type": "string",
            "description": "Description of the `DeliveryPipeline`. Max length is 255 characters.\n"
          },
          "etag": {
            "type": "string",
            "description": "This checksum is computed by the server based on the value of other fields, and may be sent on update and delete\nrequests to ensure the client has an up-to-date value before proceeding.\n"
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Labels are attributes that can be set and used by both the user and by Google Cloud Deploy. Labels must meet the following constraints: * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. * All characters must use UTF-8 encoding, and international characters are allowed. * Keys must start with a lowercase letter or international character. * Each resource is limited to a maximum of 64 labels. Both keys and values are additionally constrained to be <= 128 bytes.\n"
          },
          "location": {
            "type": "string",
            "description": "The location for the resource\n",
            "willReplaceOnChanges": true
          },
          "name": {
            "type": "string",
            "description": "Name of the `DeliveryPipeline`. Format is [a-z][a-z0-9\\-]{0,62}.\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The project for the resource\n",
            "willReplaceOnChanges": true
          },
          "serialPipeline": {
            "$ref": "#/types/gcp:clouddeploy/DeliveryPipelineSerialPipeline:DeliveryPipelineSerialPipeline",
            "description": "SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.\n"
          },
          "suspended": {
            "type": "boolean",
            "description": "When suspended, no new releases or rollouts can be created, but in-progress ones will complete.\n"
          },
          "uid": {
            "type": "string",
            "description": "Output only. Unique identifier of the `DeliveryPipeline`.\n"
          },
          "updateTime": {
            "type": "string",
            "description": "Output only. Most recent time at which the pipeline was updated.\n"
          }
        },
        "type": "object"
      }
    },
    "gcp:clouddeploy/target:Target": {
      "description": "The Cloud Deploy `Target` resource\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Target\nCreates a basic Cloud Deploy target\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst primary = new gcp.clouddeploy.Target(\"primary\", {\n    annotations: {\n        my_first_annotation: \"example-annotation-1\",\n        my_second_annotation: \"example-annotation-2\",\n    },\n    description: \"basic description\",\n    gke: {\n        cluster: \"projects/my-project-name/locations/us-west1/clusters/example-cluster-name\",\n    },\n    labels: {\n        my_first_label: \"example-label-1\",\n        my_second_label: \"example-label-2\",\n    },\n    location: \"us-west1\",\n    project: \"my-project-name\",\n    requireApproval: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nprimary = gcp.clouddeploy.Target(\"primary\",\n    annotations={\n        \"my_first_annotation\": \"example-annotation-1\",\n        \"my_second_annotation\": \"example-annotation-2\",\n    },\n    description=\"basic description\",\n    gke=gcp.clouddeploy.TargetGkeArgs(\n        cluster=\"projects/my-project-name/locations/us-west1/clusters/example-cluster-name\",\n    ),\n    labels={\n        \"my_first_label\": \"example-label-1\",\n        \"my_second_label\": \"example-label-2\",\n    },\n    location=\"us-west1\",\n    project=\"my-project-name\",\n    require_approval=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var primary = new Gcp.CloudDeploy.Target(\"primary\", new()\n    {\n        Annotations = \n        {\n            { \"my_first_annotation\", \"example-annotation-1\" },\n            { \"my_second_annotation\", \"example-annotation-2\" },\n        },\n        Description = \"basic description\",\n        Gke = new Gcp.CloudDeploy.Inputs.TargetGkeArgs\n        {\n            Cluster = \"projects/my-project-name/locations/us-west1/clusters/example-cluster-name\",\n        },\n        Labels = \n        {\n            { \"my_first_label\", \"example-label-1\" },\n            { \"my_second_label\", \"example-label-2\" },\n        },\n        Location = \"us-west1\",\n        Project = \"my-project-name\",\n        RequireApproval = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/clouddeploy\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := clouddeploy.NewTarget(ctx, \"primary\", &clouddeploy.TargetArgs{\n\t\t\tAnnotations: pulumi.StringMap{\n\t\t\t\t\"my_first_annotation\":  pulumi.String(\"example-annotation-1\"),\n\t\t\t\t\"my_second_annotation\": pulumi.String(\"example-annotation-2\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"basic description\"),\n\t\t\tGke: &clouddeploy.TargetGkeArgs{\n\t\t\t\tCluster: pulumi.String(\"projects/my-project-name/locations/us-west1/clusters/example-cluster-name\"),\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"my_first_label\":  pulumi.String(\"example-label-1\"),\n\t\t\t\t\"my_second_label\": pulumi.String(\"example-label-2\"),\n\t\t\t},\n\t\t\tLocation:        pulumi.String(\"us-west1\"),\n\t\t\tProject:         pulumi.String(\"my-project-name\"),\n\t\t\tRequireApproval: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.clouddeploy.Target;\nimport com.pulumi.gcp.clouddeploy.TargetArgs;\nimport com.pulumi.gcp.clouddeploy.inputs.TargetGkeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var primary = new Target(\"primary\", TargetArgs.builder()        \n            .annotations(Map.ofEntries(\n                Map.entry(\"my_first_annotation\", \"example-annotation-1\"),\n                Map.entry(\"my_second_annotation\", \"example-annotation-2\")\n            ))\n            .description(\"basic description\")\n            .gke(TargetGkeArgs.builder()\n                .cluster(\"projects/my-project-name/locations/us-west1/clusters/example-cluster-name\")\n                .build())\n            .labels(Map.ofEntries(\n                Map.entry(\"my_first_label\", \"example-label-1\"),\n                Map.entry(\"my_second_label\", \"example-label-2\")\n            ))\n            .location(\"us-west1\")\n            .project(\"my-project-name\")\n            .requireApproval(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  primary:\n    type: gcp:clouddeploy:Target\n    properties:\n      annotations:\n        my_first_annotation: example-annotation-1\n        my_second_annotation: example-annotation-2\n      description: basic description\n      gke:\n        cluster: projects/my-project-name/locations/us-west1/clusters/example-cluster-name\n      labels:\n        my_first_label: example-label-1\n        my_second_label: example-label-2\n      location: us-west1\n      project: my-project-name\n      requireApproval: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTarget can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:clouddeploy/target:Target default projects/{{project}}/locations/{{location}}/targets/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:clouddeploy/target:Target default {{project}}/{{location}}/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:clouddeploy/target:Target default {{location}}/{{name}}\n```\n\n ",
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. User annotations. These attributes can only be set and used by the user, and not by Google Cloud Deploy. See https://google.aip.dev/128#annotations for more details such as format and size limitations.\n"
        },
        "anthosCluster": {
          "$ref": "#/types/gcp:clouddeploy/TargetAnthosCluster:TargetAnthosCluster",
          "description": "Information specifying an Anthos Cluster.\n"
        },
        "createTime": {
          "type": "string",
          "description": "Output only. Time at which the `Target` was created.\n"
        },
        "description": {
          "type": "string",
          "description": "Optional. Description of the `Target`. Max length is 255 characters.\n"
        },
        "etag": {
          "type": "string",
          "description": "Optional. This checksum is computed by the server based on the value of other fields, and may be sent on update and\ndelete requests to ensure the client has an up-to-date value before proceeding.\n"
        },
        "executionConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:clouddeploy/TargetExecutionConfig:TargetExecutionConfig"
          },
          "description": "Configurations for all execution that relates to this `Target`. Each `ExecutionEnvironmentUsage` value may only be used in a single configuration; using the same value multiple times is an error. When one or more configurations are specified, they must include the `RENDER` and `DEPLOY` `ExecutionEnvironmentUsage` values. When no configurations are specified, execution will use the default specified in `DefaultPool`.\n"
        },
        "gke": {
          "$ref": "#/types/gcp:clouddeploy/TargetGke:TargetGke",
          "description": "Information specifying a GKE Cluster.\n"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. Labels are attributes that can be set and used by both the user and by Google Cloud Deploy. Labels must meet the following constraints: * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. * All characters must use UTF-8 encoding, and international characters are allowed. * Keys must start with a lowercase letter or international character. * Each resource is limited to a maximum of 64 labels. Both keys and values are additionally constrained to be <= 128 bytes.\n"
        },
        "location": {
          "type": "string",
          "description": "The location for the resource\n"
        },
        "name": {
          "type": "string",
          "description": "Name of the `Target`. Format is [a-z][a-z0-9\\-]{0,62}.\n"
        },
        "project": {
          "type": "string",
          "description": "The project for the resource\n"
        },
        "requireApproval": {
          "type": "boolean",
          "description": "Optional. Whether or not the `Target` requires approval.\n"
        },
        "targetId": {
          "type": "string",
          "description": "Output only. Resource id of the `Target`.\n"
        },
        "uid": {
          "type": "string",
          "description": "Output only. Unique identifier of the `Target`.\n"
        },
        "updateTime": {
          "type": "string",
          "description": "Output only. Most recent time at which the `Target` was updated.\n"
        }
      },
      "required": [
        "createTime",
        "etag",
        "executionConfigs",
        "location",
        "name",
        "project",
        "targetId",
        "uid",
        "updateTime"
      ],
      "inputProperties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. User annotations. These attributes can only be set and used by the user, and not by Google Cloud Deploy. See https://google.aip.dev/128#annotations for more details such as format and size limitations.\n"
        },
        "anthosCluster": {
          "$ref": "#/types/gcp:clouddeploy/TargetAnthosCluster:TargetAnthosCluster",
          "description": "Information specifying an Anthos Cluster.\n"
        },
        "description": {
          "type": "string",
          "description": "Optional. Description of the `Target`. Max length is 255 characters.\n"
        },
        "executionConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:clouddeploy/TargetExecutionConfig:TargetExecutionConfig"
          },
          "description": "Configurations for all execution that relates to this `Target`. Each `ExecutionEnvironmentUsage` value may only be used in a single configuration; using the same value multiple times is an error. When one or more configurations are specified, they must include the `RENDER` and `DEPLOY` `ExecutionEnvironmentUsage` values. When no configurations are specified, execution will use the default specified in `DefaultPool`.\n"
        },
        "gke": {
          "$ref": "#/types/gcp:clouddeploy/TargetGke:TargetGke",
          "description": "Information specifying a GKE Cluster.\n"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. Labels are attributes that can be set and used by both the user and by Google Cloud Deploy. Labels must meet the following constraints: * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. * All characters must use UTF-8 encoding, and international characters are allowed. * Keys must start with a lowercase letter or international character. * Each resource is limited to a maximum of 64 labels. Both keys and values are additionally constrained to be <= 128 bytes.\n"
        },
        "location": {
          "type": "string",
          "description": "The location for the resource\n",
          "willReplaceOnChanges": true
        },
        "name": {
          "type": "string",
          "description": "Name of the `Target`. Format is [a-z][a-z0-9\\-]{0,62}.\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The project for the resource\n",
          "willReplaceOnChanges": true
        },
        "requireApproval": {
          "type": "boolean",
          "description": "Optional. Whether or not the `Target` requires approval.\n"
        }
      },
      "requiredInputs": [
        "location"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering Target resources.\n",
        "properties": {
          "annotations": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Optional. User annotations. These attributes can only be set and used by the user, and not by Google Cloud Deploy. See https://google.aip.dev/128#annotations for more details such as format and size limitations.\n"
          },
          "anthosCluster": {
            "$ref": "#/types/gcp:clouddeploy/TargetAnthosCluster:TargetAnthosCluster",
            "description": "Information specifying an Anthos Cluster.\n"
          },
          "createTime": {
            "type": "string",
            "description": "Output only. Time at which the `Target` was created.\n"
          },
          "description": {
            "type": "string",
            "description": "Optional. Description of the `Target`. Max length is 255 characters.\n"
          },
          "etag": {
            "type": "string",
            "description": "Optional. This checksum is computed by the server based on the value of other fields, and may be sent on update and\ndelete requests to ensure the client has an up-to-date value before proceeding.\n"
          },
          "executionConfigs": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:clouddeploy/TargetExecutionConfig:TargetExecutionConfig"
            },
            "description": "Configurations for all execution that relates to this `Target`. Each `ExecutionEnvironmentUsage` value may only be used in a single configuration; using the same value multiple times is an error. When one or more configurations are specified, they must include the `RENDER` and `DEPLOY` `ExecutionEnvironmentUsage` values. When no configurations are specified, execution will use the default specified in `DefaultPool`.\n"
          },
          "gke": {
            "$ref": "#/types/gcp:clouddeploy/TargetGke:TargetGke",
            "description": "Information specifying a GKE Cluster.\n"
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Optional. Labels are attributes that can be set and used by both the user and by Google Cloud Deploy. Labels must meet the following constraints: * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. * All characters must use UTF-8 encoding, and international characters are allowed. * Keys must start with a lowercase letter or international character. * Each resource is limited to a maximum of 64 labels. Both keys and values are additionally constrained to be <= 128 bytes.\n"
          },
          "location": {
            "type": "string",
            "description": "The location for the resource\n",
            "willReplaceOnChanges": true
          },
          "name": {
            "type": "string",
            "description": "Name of the `Target`. Format is [a-z][a-z0-9\\-]{0,62}.\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The project for the resource\n",
            "willReplaceOnChanges": true
          },
          "requireApproval": {
            "type": "boolean",
            "description": "Optional. Whether or not the `Target` requires approval.\n"
          },
          "targetId": {
            "type": "string",
            "description": "Output only. Resource id of the `Target`.\n"
          },
          "uid": {
            "type": "string",
            "description": "Output only. Unique identifier of the `Target`.\n"
          },
          "updateTime": {
            "type": "string",
            "description": "Output only. Most recent time at which the `Target` was updated.\n"
          }
        },
        "type": "object"
      }
    },
    "gcp:cloudidentity/groupMembership:GroupMembership": {
      "description": "A Membership defines a relationship between a Group and an entity belonging to that Group, referred to as a \"member\".\n\n\nTo get more information about GroupMembership, see:\n\n* [API documentation](https://cloud.google.com/identity/docs/reference/rest/v1/groups.memberships)\n* How-to Guides\n    * [Official Documentation](https://cloud.google.com/identity/docs/how-to/memberships-google-groups)\n\n> **Warning:** If you are using User ADCs (Application Default Credentials) with this resource,\nyou must specify a `billing_project` and set `user_project_override` to true\nin the provider configuration. Otherwise the Cloud Identity API will return a 403 error.\nYour account must have the `serviceusage.services.use` permission on the\n`billing_project` you defined.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Cloud Identity Group Membership\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst group = new gcp.cloudidentity.Group(\"group\", {\n    displayName: \"my-identity-group\",\n    parent: \"customers/A01b123xz\",\n    groupKey: {\n        id: \"my-identity-group@example.com\",\n    },\n    labels: {\n        \"cloudidentity.googleapis.com/groups.discussion_forum\": \"\",\n    },\n});\nconst child_group = new gcp.cloudidentity.Group(\"child-group\", {\n    displayName: \"my-identity-group-child\",\n    parent: \"customers/A01b123xz\",\n    groupKey: {\n        id: \"my-identity-group-child@example.com\",\n    },\n    labels: {\n        \"cloudidentity.googleapis.com/groups.discussion_forum\": \"\",\n    },\n});\nconst cloudIdentityGroupMembershipBasic = new gcp.cloudidentity.GroupMembership(\"cloudIdentityGroupMembershipBasic\", {\n    group: group.id,\n    preferredMemberKey: {\n        id: child_group.groupKey.apply(groupKey => groupKey.id),\n    },\n    roles: [{\n        name: \"MEMBER\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\ngroup = gcp.cloudidentity.Group(\"group\",\n    display_name=\"my-identity-group\",\n    parent=\"customers/A01b123xz\",\n    group_key=gcp.cloudidentity.GroupGroupKeyArgs(\n        id=\"my-identity-group@example.com\",\n    ),\n    labels={\n        \"cloudidentity.googleapis.com/groups.discussion_forum\": \"\",\n    })\nchild_group = gcp.cloudidentity.Group(\"child-group\",\n    display_name=\"my-identity-group-child\",\n    parent=\"customers/A01b123xz\",\n    group_key=gcp.cloudidentity.GroupGroupKeyArgs(\n        id=\"my-identity-group-child@example.com\",\n    ),\n    labels={\n        \"cloudidentity.googleapis.com/groups.discussion_forum\": \"\",\n    })\ncloud_identity_group_membership_basic = gcp.cloudidentity.GroupMembership(\"cloudIdentityGroupMembershipBasic\",\n    group=group.id,\n    preferred_member_key=gcp.cloudidentity.GroupMembershipPreferredMemberKeyArgs(\n        id=child_group.group_key.id,\n    ),\n    roles=[gcp.cloudidentity.GroupMembershipRoleArgs(\n        name=\"MEMBER\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var @group = new Gcp.CloudIdentity.Group(\"group\", new()\n    {\n        DisplayName = \"my-identity-group\",\n        Parent = \"customers/A01b123xz\",\n        GroupKey = new Gcp.CloudIdentity.Inputs.GroupGroupKeyArgs\n        {\n            Id = \"my-identity-group@example.com\",\n        },\n        Labels = \n        {\n            { \"cloudidentity.googleapis.com/groups.discussion_forum\", \"\" },\n        },\n    });\n\n    var child_group = new Gcp.CloudIdentity.Group(\"child-group\", new()\n    {\n        DisplayName = \"my-identity-group-child\",\n        Parent = \"customers/A01b123xz\",\n        GroupKey = new Gcp.CloudIdentity.Inputs.GroupGroupKeyArgs\n        {\n            Id = \"my-identity-group-child@example.com\",\n        },\n        Labels = \n        {\n            { \"cloudidentity.googleapis.com/groups.discussion_forum\", \"\" },\n        },\n    });\n\n    var cloudIdentityGroupMembershipBasic = new Gcp.CloudIdentity.GroupMembership(\"cloudIdentityGroupMembershipBasic\", new()\n    {\n        Group = @group.Id,\n        PreferredMemberKey = new Gcp.CloudIdentity.Inputs.GroupMembershipPreferredMemberKeyArgs\n        {\n            Id = child_group.GroupKey.Apply(groupKey => groupKey.Id),\n        },\n        Roles = new[]\n        {\n            new Gcp.CloudIdentity.Inputs.GroupMembershipRoleArgs\n            {\n                Name = \"MEMBER\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/cloudidentity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroup, err := cloudidentity.NewGroup(ctx, \"group\", &cloudidentity.GroupArgs{\n\t\t\tDisplayName: pulumi.String(\"my-identity-group\"),\n\t\t\tParent:      pulumi.String(\"customers/A01b123xz\"),\n\t\t\tGroupKey: &cloudidentity.GroupGroupKeyArgs{\n\t\t\t\tId: pulumi.String(\"my-identity-group@example.com\"),\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"cloudidentity.googleapis.com/groups.discussion_forum\": pulumi.String(\"\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudidentity.NewGroup(ctx, \"child-group\", &cloudidentity.GroupArgs{\n\t\t\tDisplayName: pulumi.String(\"my-identity-group-child\"),\n\t\t\tParent:      pulumi.String(\"customers/A01b123xz\"),\n\t\t\tGroupKey: &cloudidentity.GroupGroupKeyArgs{\n\t\t\t\tId: pulumi.String(\"my-identity-group-child@example.com\"),\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"cloudidentity.googleapis.com/groups.discussion_forum\": pulumi.String(\"\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudidentity.NewGroupMembership(ctx, \"cloudIdentityGroupMembershipBasic\", &cloudidentity.GroupMembershipArgs{\n\t\t\tGroup: group.ID(),\n\t\t\tPreferredMemberKey: &cloudidentity.GroupMembershipPreferredMemberKeyArgs{\n\t\t\t\tId: child_group.GroupKey.ApplyT(func(groupKey cloudidentity.GroupGroupKey) (string, error) {\n\t\t\t\t\treturn groupKey.Id, nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t\tRoles: cloudidentity.GroupMembershipRoleArray{\n\t\t\t\t&cloudidentity.GroupMembershipRoleArgs{\n\t\t\t\t\tName: pulumi.String(\"MEMBER\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.cloudidentity.Group;\nimport com.pulumi.gcp.cloudidentity.GroupArgs;\nimport com.pulumi.gcp.cloudidentity.inputs.GroupGroupKeyArgs;\nimport com.pulumi.gcp.cloudidentity.GroupMembership;\nimport com.pulumi.gcp.cloudidentity.GroupMembershipArgs;\nimport com.pulumi.gcp.cloudidentity.inputs.GroupMembershipPreferredMemberKeyArgs;\nimport com.pulumi.gcp.cloudidentity.inputs.GroupMembershipRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var group = new Group(\"group\", GroupArgs.builder()        \n            .displayName(\"my-identity-group\")\n            .parent(\"customers/A01b123xz\")\n            .groupKey(GroupGroupKeyArgs.builder()\n                .id(\"my-identity-group@example.com\")\n                .build())\n            .labels(Map.of(\"cloudidentity.googleapis.com/groups.discussion_forum\", \"\"))\n            .build());\n\n        var child_group = new Group(\"child-group\", GroupArgs.builder()        \n            .displayName(\"my-identity-group-child\")\n            .parent(\"customers/A01b123xz\")\n            .groupKey(GroupGroupKeyArgs.builder()\n                .id(\"my-identity-group-child@example.com\")\n                .build())\n            .labels(Map.of(\"cloudidentity.googleapis.com/groups.discussion_forum\", \"\"))\n            .build());\n\n        var cloudIdentityGroupMembershipBasic = new GroupMembership(\"cloudIdentityGroupMembershipBasic\", GroupMembershipArgs.builder()        \n            .group(group.id())\n            .preferredMemberKey(GroupMembershipPreferredMemberKeyArgs.builder()\n                .id(child_group.groupKey().applyValue(groupKey -> groupKey.id()))\n                .build())\n            .roles(GroupMembershipRoleArgs.builder()\n                .name(\"MEMBER\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  group:\n    type: gcp:cloudidentity:Group\n    properties:\n      displayName: my-identity-group\n      parent: customers/A01b123xz\n      groupKey:\n        id: my-identity-group@example.com\n      labels:\n        cloudidentity.googleapis.com/groups.discussion_forum:\n  child-group:\n    type: gcp:cloudidentity:Group\n    properties:\n      displayName: my-identity-group-child\n      parent: customers/A01b123xz\n      groupKey:\n        id: my-identity-group-child@example.com\n      labels:\n        cloudidentity.googleapis.com/groups.discussion_forum:\n  cloudIdentityGroupMembershipBasic:\n    type: gcp:cloudidentity:GroupMembership\n    properties:\n      group: ${group.id}\n      preferredMemberKey:\n        id: ${[\"child-group\"].groupKey.id}\n      roles:\n        - name: MEMBER\n```\n{{% /example %}}\n{{% example %}}\n### Cloud Identity Group Membership User\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst group = new gcp.cloudidentity.Group(\"group\", {\n    displayName: \"my-identity-group\",\n    parent: \"customers/A01b123xz\",\n    groupKey: {\n        id: \"my-identity-group@example.com\",\n    },\n    labels: {\n        \"cloudidentity.googleapis.com/groups.discussion_forum\": \"\",\n    },\n});\nconst cloudIdentityGroupMembershipBasic = new gcp.cloudidentity.GroupMembership(\"cloudIdentityGroupMembershipBasic\", {\n    group: group.id,\n    preferredMemberKey: {\n        id: \"cloud_identity_user@example.com\",\n    },\n    roles: [\n        {\n            name: \"MEMBER\",\n        },\n        {\n            name: \"MANAGER\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\ngroup = gcp.cloudidentity.Group(\"group\",\n    display_name=\"my-identity-group\",\n    parent=\"customers/A01b123xz\",\n    group_key=gcp.cloudidentity.GroupGroupKeyArgs(\n        id=\"my-identity-group@example.com\",\n    ),\n    labels={\n        \"cloudidentity.googleapis.com/groups.discussion_forum\": \"\",\n    })\ncloud_identity_group_membership_basic = gcp.cloudidentity.GroupMembership(\"cloudIdentityGroupMembershipBasic\",\n    group=group.id,\n    preferred_member_key=gcp.cloudidentity.GroupMembershipPreferredMemberKeyArgs(\n        id=\"cloud_identity_user@example.com\",\n    ),\n    roles=[\n        gcp.cloudidentity.GroupMembershipRoleArgs(\n            name=\"MEMBER\",\n        ),\n        gcp.cloudidentity.GroupMembershipRoleArgs(\n            name=\"MANAGER\",\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var @group = new Gcp.CloudIdentity.Group(\"group\", new()\n    {\n        DisplayName = \"my-identity-group\",\n        Parent = \"customers/A01b123xz\",\n        GroupKey = new Gcp.CloudIdentity.Inputs.GroupGroupKeyArgs\n        {\n            Id = \"my-identity-group@example.com\",\n        },\n        Labels = \n        {\n            { \"cloudidentity.googleapis.com/groups.discussion_forum\", \"\" },\n        },\n    });\n\n    var cloudIdentityGroupMembershipBasic = new Gcp.CloudIdentity.GroupMembership(\"cloudIdentityGroupMembershipBasic\", new()\n    {\n        Group = @group.Id,\n        PreferredMemberKey = new Gcp.CloudIdentity.Inputs.GroupMembershipPreferredMemberKeyArgs\n        {\n            Id = \"cloud_identity_user@example.com\",\n        },\n        Roles = new[]\n        {\n            new Gcp.CloudIdentity.Inputs.GroupMembershipRoleArgs\n            {\n                Name = \"MEMBER\",\n            },\n            new Gcp.CloudIdentity.Inputs.GroupMembershipRoleArgs\n            {\n                Name = \"MANAGER\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/cloudidentity\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tgroup, err := cloudidentity.NewGroup(ctx, \"group\", &cloudidentity.GroupArgs{\n\t\t\tDisplayName: pulumi.String(\"my-identity-group\"),\n\t\t\tParent:      pulumi.String(\"customers/A01b123xz\"),\n\t\t\tGroupKey: &cloudidentity.GroupGroupKeyArgs{\n\t\t\t\tId: pulumi.String(\"my-identity-group@example.com\"),\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"cloudidentity.googleapis.com/groups.discussion_forum\": pulumi.String(\"\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = cloudidentity.NewGroupMembership(ctx, \"cloudIdentityGroupMembershipBasic\", &cloudidentity.GroupMembershipArgs{\n\t\t\tGroup: group.ID(),\n\t\t\tPreferredMemberKey: &cloudidentity.GroupMembershipPreferredMemberKeyArgs{\n\t\t\t\tId: pulumi.String(\"cloud_identity_user@example.com\"),\n\t\t\t},\n\t\t\tRoles: cloudidentity.GroupMembershipRoleArray{\n\t\t\t\t&cloudidentity.GroupMembershipRoleArgs{\n\t\t\t\t\tName: pulumi.String(\"MEMBER\"),\n\t\t\t\t},\n\t\t\t\t&cloudidentity.GroupMembershipRoleArgs{\n\t\t\t\t\tName: pulumi.String(\"MANAGER\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.cloudidentity.Group;\nimport com.pulumi.gcp.cloudidentity.GroupArgs;\nimport com.pulumi.gcp.cloudidentity.inputs.GroupGroupKeyArgs;\nimport com.pulumi.gcp.cloudidentity.GroupMembership;\nimport com.pulumi.gcp.cloudidentity.GroupMembershipArgs;\nimport com.pulumi.gcp.cloudidentity.inputs.GroupMembershipPreferredMemberKeyArgs;\nimport com.pulumi.gcp.cloudidentity.inputs.GroupMembershipRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var group = new Group(\"group\", GroupArgs.builder()        \n            .displayName(\"my-identity-group\")\n            .parent(\"customers/A01b123xz\")\n            .groupKey(GroupGroupKeyArgs.builder()\n                .id(\"my-identity-group@example.com\")\n                .build())\n            .labels(Map.of(\"cloudidentity.googleapis.com/groups.discussion_forum\", \"\"))\n            .build());\n\n        var cloudIdentityGroupMembershipBasic = new GroupMembership(\"cloudIdentityGroupMembershipBasic\", GroupMembershipArgs.builder()        \n            .group(group.id())\n            .preferredMemberKey(GroupMembershipPreferredMemberKeyArgs.builder()\n                .id(\"cloud_identity_user@example.com\")\n                .build())\n            .roles(            \n                GroupMembershipRoleArgs.builder()\n                    .name(\"MEMBER\")\n                    .build(),\n                GroupMembershipRoleArgs.builder()\n                    .name(\"MANAGER\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  group:\n    type: gcp:cloudidentity:Group\n    properties:\n      displayName: my-identity-group\n      parent: customers/A01b123xz\n      groupKey:\n        id: my-identity-group@example.com\n      labels:\n        cloudidentity.googleapis.com/groups.discussion_forum:\n  cloudIdentityGroupMembershipBasic:\n    type: gcp:cloudidentity:GroupMembership\n    properties:\n      group: ${group.id}\n      preferredMemberKey:\n        id: cloud_identity_user@example.com\n      roles:\n        - name: MEMBER\n        - name: MANAGER\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGroupMembership can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:cloudidentity/groupMembership:GroupMembership default {{name}}\n```\n\n ",
      "properties": {
        "createTime": {
          "type": "string",
          "description": "The time when the Membership was created.\n"
        },
        "group": {
          "type": "string",
          "description": "The name of the Group to create this membership in.\n"
        },
        "memberKey": {
          "$ref": "#/types/gcp:cloudidentity/GroupMembershipMemberKey:GroupMembershipMemberKey",
          "description": "EntityKey of the member.\nStructure is documented below.\n"
        },
        "name": {
          "type": "string",
          "description": "The name of the MembershipRole. Must be one of OWNER, MANAGER, MEMBER.\nPossible values are `OWNER`, `MANAGER`, and `MEMBER`.\n"
        },
        "preferredMemberKey": {
          "$ref": "#/types/gcp:cloudidentity/GroupMembershipPreferredMemberKey:GroupMembershipPreferredMemberKey",
          "description": "EntityKey of the member.\nStructure is documented below.\n"
        },
        "roles": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:cloudidentity/GroupMembershipRole:GroupMembershipRole"
          },
          "description": "The MembershipRoles that apply to the Membership.\nMust not contain duplicate MembershipRoles with the same name.\nStructure is documented below.\n"
        },
        "type": {
          "type": "string",
          "description": "The type of the membership.\n"
        },
        "updateTime": {
          "type": "string",
          "description": "The time when the Membership was last updated.\n"
        }
      },
      "required": [
        "createTime",
        "group",
        "memberKey",
        "name",
        "preferredMemberKey",
        "roles",
        "type",
        "updateTime"
      ],
      "inputProperties": {
        "group": {
          "type": "string",
          "description": "The name of the Group to create this membership in.\n",
          "willReplaceOnChanges": true
        },
        "memberKey": {
          "$ref": "#/types/gcp:cloudidentity/GroupMembershipMemberKey:GroupMembershipMemberKey",
          "willReplaceOnChanges": true,
          "description": "EntityKey of the member.\nStructure is documented below.\n"
        },
        "preferredMemberKey": {
          "$ref": "#/types/gcp:cloudidentity/GroupMembershipPreferredMemberKey:GroupMembershipPreferredMemberKey",
          "willReplaceOnChanges": true,
          "description": "EntityKey of the member.\nStructure is documented below.\n"
        },
        "roles": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:cloudidentity/GroupMembershipRole:GroupMembershipRole"
          },
          "description": "The MembershipRoles that apply to the Membership.\nMust not contain duplicate MembershipRoles with the same name.\nStructure is documented below.\n"
        }
      },
      "requiredInputs": [
        "group",
        "roles"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering GroupMembership resources.\n",
        "properties": {
          "createTime": {
            "type": "string",
            "description": "The time when the Membership was created.\n"
          },
          "group": {
            "type": "string",
            "description": "The name of the Group to create this membership in.\n",
            "willReplaceOnChanges": true
          },
          "memberKey": {
            "$ref": "#/types/gcp:cloudidentity/GroupMembershipMemberKey:GroupMembershipMemberKey",
            "description": "EntityKey of the member.\nStructure is documented below.\n",
            "willReplaceOnChanges": true
          },
          "name": {
            "type": "string",
            "description": "The name of the MembershipRole. Must be one of OWNER, MANAGER, MEMBER.\nPossible values are `OWNER`, `MANAGER`, and `MEMBER`.\n"
          },
          "preferredMemberKey": {
            "$ref": "#/types/gcp:cloudidentity/GroupMembershipPreferredMemberKey:GroupMembershipPreferredMemberKey",
            "description": "EntityKey of the member.\nStructure is documented below.\n",
            "willReplaceOnChanges": true
          },
          "roles": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:cloudidentity/GroupMembershipRole:GroupMembershipRole"
            },
            "description": "The MembershipRoles that apply to the Membership.\nMust not contain duplicate MembershipRoles with the same name.\nStructure is documented below.\n"
          },
          "type": {
            "type": "string",
            "description": "The type of the membership.\n"
          },
          "updateTime": {
            "type": "string",
            "description": "The time when the Membership was last updated.\n"
          }
        },
        "type": "object"
      }
    },
    "gcp:compute/backendBucket:BackendBucket": {
      "description": "Backend buckets allow you to use Google Cloud Storage buckets with HTTP(S)\nload balancing.\n\nAn HTTP(S) load balancer can direct traffic to specified URLs to a\nbackend bucket rather than a backend service. It can send requests for\nstatic content to a Cloud Storage bucket and requests for dynamic content\nto a virtual machine instance.\n\n\nTo get more information about BackendBucket, see:\n\n* [API documentation](https://cloud.google.com/compute/docs/reference/v1/backendBuckets)\n* How-to Guides\n    * [Using a Cloud Storage bucket as a load balancer backend](https://cloud.google.com/compute/docs/load-balancing/http/backend-bucket)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Backend Bucket Basic\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst imageBucket = new gcp.storage.Bucket(\"imageBucket\", {location: \"EU\"});\nconst imageBackend = new gcp.compute.BackendBucket(\"imageBackend\", {\n    description: \"Contains beautiful images\",\n    bucketName: imageBucket.name,\n    enableCdn: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nimage_bucket = gcp.storage.Bucket(\"imageBucket\", location=\"EU\")\nimage_backend = gcp.compute.BackendBucket(\"imageBackend\",\n    description=\"Contains beautiful images\",\n    bucket_name=image_bucket.name,\n    enable_cdn=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var imageBucket = new Gcp.Storage.Bucket(\"imageBucket\", new()\n    {\n        Location = \"EU\",\n    });\n\n    var imageBackend = new Gcp.Compute.BackendBucket(\"imageBackend\", new()\n    {\n        Description = \"Contains beautiful images\",\n        BucketName = imageBucket.Name,\n        EnableCdn = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/storage\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\timageBucket, err := storage.NewBucket(ctx, \"imageBucket\", &storage.BucketArgs{\n\t\t\tLocation: pulumi.String(\"EU\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewBackendBucket(ctx, \"imageBackend\", &compute.BackendBucketArgs{\n\t\t\tDescription: pulumi.String(\"Contains beautiful images\"),\n\t\t\tBucketName:  imageBucket.Name,\n\t\t\tEnableCdn:   pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.storage.Bucket;\nimport com.pulumi.gcp.storage.BucketArgs;\nimport com.pulumi.gcp.compute.BackendBucket;\nimport com.pulumi.gcp.compute.BackendBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var imageBucket = new Bucket(\"imageBucket\", BucketArgs.builder()        \n            .location(\"EU\")\n            .build());\n\n        var imageBackend = new BackendBucket(\"imageBackend\", BackendBucketArgs.builder()        \n            .description(\"Contains beautiful images\")\n            .bucketName(imageBucket.name())\n            .enableCdn(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  imageBackend:\n    type: gcp:compute:BackendBucket\n    properties:\n      description: Contains beautiful images\n      bucketName: ${imageBucket.name}\n      enableCdn: true\n  imageBucket:\n    type: gcp:storage:Bucket\n    properties:\n      location: EU\n```\n{{% /example %}}\n{{% example %}}\n### Backend Bucket Security Policy\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst imageBackendBucket = new gcp.storage.Bucket(\"imageBackendBucket\", {location: \"EU\"});\nconst policy = new gcp.compute.SecurityPolicy(\"policy\", {\n    description: \"basic security policy\",\n    type: \"CLOUD_ARMOR_EDGE\",\n});\nconst imageBackendBackendBucket = new gcp.compute.BackendBucket(\"imageBackendBackendBucket\", {\n    description: \"Contains beautiful images\",\n    bucketName: imageBackendBucket.name,\n    enableCdn: true,\n    edgeSecurityPolicy: policy.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nimage_backend_bucket = gcp.storage.Bucket(\"imageBackendBucket\", location=\"EU\")\npolicy = gcp.compute.SecurityPolicy(\"policy\",\n    description=\"basic security policy\",\n    type=\"CLOUD_ARMOR_EDGE\")\nimage_backend_backend_bucket = gcp.compute.BackendBucket(\"imageBackendBackendBucket\",\n    description=\"Contains beautiful images\",\n    bucket_name=image_backend_bucket.name,\n    enable_cdn=True,\n    edge_security_policy=policy.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var imageBackendBucket = new Gcp.Storage.Bucket(\"imageBackendBucket\", new()\n    {\n        Location = \"EU\",\n    });\n\n    var policy = new Gcp.Compute.SecurityPolicy(\"policy\", new()\n    {\n        Description = \"basic security policy\",\n        Type = \"CLOUD_ARMOR_EDGE\",\n    });\n\n    var imageBackendBackendBucket = new Gcp.Compute.BackendBucket(\"imageBackendBackendBucket\", new()\n    {\n        Description = \"Contains beautiful images\",\n        BucketName = imageBackendBucket.Name,\n        EnableCdn = true,\n        EdgeSecurityPolicy = policy.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/storage\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\timageBackendBucket, err := storage.NewBucket(ctx, \"imageBackendBucket\", &storage.BucketArgs{\n\t\t\tLocation: pulumi.String(\"EU\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpolicy, err := compute.NewSecurityPolicy(ctx, \"policy\", &compute.SecurityPolicyArgs{\n\t\t\tDescription: pulumi.String(\"basic security policy\"),\n\t\t\tType:        pulumi.String(\"CLOUD_ARMOR_EDGE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewBackendBucket(ctx, \"imageBackendBackendBucket\", &compute.BackendBucketArgs{\n\t\t\tDescription:        pulumi.String(\"Contains beautiful images\"),\n\t\t\tBucketName:         imageBackendBucket.Name,\n\t\t\tEnableCdn:          pulumi.Bool(true),\n\t\t\tEdgeSecurityPolicy: policy.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.storage.Bucket;\nimport com.pulumi.gcp.storage.BucketArgs;\nimport com.pulumi.gcp.compute.SecurityPolicy;\nimport com.pulumi.gcp.compute.SecurityPolicyArgs;\nimport com.pulumi.gcp.compute.BackendBucket;\nimport com.pulumi.gcp.compute.BackendBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var imageBackendBucket = new Bucket(\"imageBackendBucket\", BucketArgs.builder()        \n            .location(\"EU\")\n            .build());\n\n        var policy = new SecurityPolicy(\"policy\", SecurityPolicyArgs.builder()        \n            .description(\"basic security policy\")\n            .type(\"CLOUD_ARMOR_EDGE\")\n            .build());\n\n        var imageBackendBackendBucket = new BackendBucket(\"imageBackendBackendBucket\", BackendBucketArgs.builder()        \n            .description(\"Contains beautiful images\")\n            .bucketName(imageBackendBucket.name())\n            .enableCdn(true)\n            .edgeSecurityPolicy(policy.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  imageBackendBackendBucket:\n    type: gcp:compute:BackendBucket\n    properties:\n      description: Contains beautiful images\n      bucketName: ${imageBackendBucket.name}\n      enableCdn: true\n      edgeSecurityPolicy: ${policy.id}\n  imageBackendBucket:\n    type: gcp:storage:Bucket\n    properties:\n      location: EU\n  policy:\n    type: gcp:compute:SecurityPolicy\n    properties:\n      description: basic security policy\n      type: CLOUD_ARMOR_EDGE\n```\n{{% /example %}}\n{{% example %}}\n### Backend Bucket Query String Whitelist\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst imageBucket = new gcp.storage.Bucket(\"imageBucket\", {location: \"EU\"});\nconst imageBackend = new gcp.compute.BackendBucket(\"imageBackend\", {\n    description: \"Contains beautiful images\",\n    bucketName: imageBucket.name,\n    enableCdn: true,\n    cdnPolicy: {\n        cacheKeyPolicy: {\n            queryStringWhitelists: [\"image-version\"],\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nimage_bucket = gcp.storage.Bucket(\"imageBucket\", location=\"EU\")\nimage_backend = gcp.compute.BackendBucket(\"imageBackend\",\n    description=\"Contains beautiful images\",\n    bucket_name=image_bucket.name,\n    enable_cdn=True,\n    cdn_policy=gcp.compute.BackendBucketCdnPolicyArgs(\n        cache_key_policy=gcp.compute.BackendBucketCdnPolicyCacheKeyPolicyArgs(\n            query_string_whitelists=[\"image-version\"],\n        ),\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var imageBucket = new Gcp.Storage.Bucket(\"imageBucket\", new()\n    {\n        Location = \"EU\",\n    });\n\n    var imageBackend = new Gcp.Compute.BackendBucket(\"imageBackend\", new()\n    {\n        Description = \"Contains beautiful images\",\n        BucketName = imageBucket.Name,\n        EnableCdn = true,\n        CdnPolicy = new Gcp.Compute.Inputs.BackendBucketCdnPolicyArgs\n        {\n            CacheKeyPolicy = new Gcp.Compute.Inputs.BackendBucketCdnPolicyCacheKeyPolicyArgs\n            {\n                QueryStringWhitelists = new[]\n                {\n                    \"image-version\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/storage\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\timageBucket, err := storage.NewBucket(ctx, \"imageBucket\", &storage.BucketArgs{\n\t\t\tLocation: pulumi.String(\"EU\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewBackendBucket(ctx, \"imageBackend\", &compute.BackendBucketArgs{\n\t\t\tDescription: pulumi.String(\"Contains beautiful images\"),\n\t\t\tBucketName:  imageBucket.Name,\n\t\t\tEnableCdn:   pulumi.Bool(true),\n\t\t\tCdnPolicy: &compute.BackendBucketCdnPolicyArgs{\n\t\t\t\tCacheKeyPolicy: &compute.BackendBucketCdnPolicyCacheKeyPolicyArgs{\n\t\t\t\t\tQueryStringWhitelists: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"image-version\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.storage.Bucket;\nimport com.pulumi.gcp.storage.BucketArgs;\nimport com.pulumi.gcp.compute.BackendBucket;\nimport com.pulumi.gcp.compute.BackendBucketArgs;\nimport com.pulumi.gcp.compute.inputs.BackendBucketCdnPolicyArgs;\nimport com.pulumi.gcp.compute.inputs.BackendBucketCdnPolicyCacheKeyPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var imageBucket = new Bucket(\"imageBucket\", BucketArgs.builder()        \n            .location(\"EU\")\n            .build());\n\n        var imageBackend = new BackendBucket(\"imageBackend\", BackendBucketArgs.builder()        \n            .description(\"Contains beautiful images\")\n            .bucketName(imageBucket.name())\n            .enableCdn(true)\n            .cdnPolicy(BackendBucketCdnPolicyArgs.builder()\n                .cacheKeyPolicy(BackendBucketCdnPolicyCacheKeyPolicyArgs.builder()\n                    .queryStringWhitelists(\"image-version\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  imageBackend:\n    type: gcp:compute:BackendBucket\n    properties:\n      description: Contains beautiful images\n      bucketName: ${imageBucket.name}\n      enableCdn: true\n      cdnPolicy:\n        cacheKeyPolicy:\n          queryStringWhitelists:\n            - image-version\n  imageBucket:\n    type: gcp:storage:Bucket\n    properties:\n      location: EU\n```\n{{% /example %}}\n{{% example %}}\n### Backend Bucket Include Http Headers\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst imageBucket = new gcp.storage.Bucket(\"imageBucket\", {location: \"EU\"});\nconst imageBackend = new gcp.compute.BackendBucket(\"imageBackend\", {\n    description: \"Contains beautiful images\",\n    bucketName: imageBucket.name,\n    enableCdn: true,\n    cdnPolicy: {\n        cacheKeyPolicy: {\n            includeHttpHeaders: [\"X-My-Header-Field\"],\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nimage_bucket = gcp.storage.Bucket(\"imageBucket\", location=\"EU\")\nimage_backend = gcp.compute.BackendBucket(\"imageBackend\",\n    description=\"Contains beautiful images\",\n    bucket_name=image_bucket.name,\n    enable_cdn=True,\n    cdn_policy=gcp.compute.BackendBucketCdnPolicyArgs(\n        cache_key_policy=gcp.compute.BackendBucketCdnPolicyCacheKeyPolicyArgs(\n            include_http_headers=[\"X-My-Header-Field\"],\n        ),\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var imageBucket = new Gcp.Storage.Bucket(\"imageBucket\", new()\n    {\n        Location = \"EU\",\n    });\n\n    var imageBackend = new Gcp.Compute.BackendBucket(\"imageBackend\", new()\n    {\n        Description = \"Contains beautiful images\",\n        BucketName = imageBucket.Name,\n        EnableCdn = true,\n        CdnPolicy = new Gcp.Compute.Inputs.BackendBucketCdnPolicyArgs\n        {\n            CacheKeyPolicy = new Gcp.Compute.Inputs.BackendBucketCdnPolicyCacheKeyPolicyArgs\n            {\n                IncludeHttpHeaders = new[]\n                {\n                    \"X-My-Header-Field\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute\"\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/storage\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\timageBucket, err := storage.NewBucket(ctx, \"imageBucket\", &storage.BucketArgs{\n\t\t\tLocation: pulumi.String(\"EU\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewBackendBucket(ctx, \"imageBackend\", &compute.BackendBucketArgs{\n\t\t\tDescription: pulumi.String(\"Contains beautiful images\"),\n\t\t\tBucketName:  imageBucket.Name,\n\t\t\tEnableCdn:   pulumi.Bool(true),\n\t\t\tCdnPolicy: &compute.BackendBucketCdnPolicyArgs{\n\t\t\t\tCacheKeyPolicy: &compute.BackendBucketCdnPolicyCacheKeyPolicyArgs{\n\t\t\t\t\tIncludeHttpHeaders: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"X-My-Header-Field\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.storage.Bucket;\nimport com.pulumi.gcp.storage.BucketArgs;\nimport com.pulumi.gcp.compute.BackendBucket;\nimport com.pulumi.gcp.compute.BackendBucketArgs;\nimport com.pulumi.gcp.compute.inputs.BackendBucketCdnPolicyArgs;\nimport com.pulumi.gcp.compute.inputs.BackendBucketCdnPolicyCacheKeyPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var imageBucket = new Bucket(\"imageBucket\", BucketArgs.builder()        \n            .location(\"EU\")\n            .build());\n\n        var imageBackend = new BackendBucket(\"imageBackend\", BackendBucketArgs.builder()        \n            .description(\"Contains beautiful images\")\n            .bucketName(imageBucket.name())\n            .enableCdn(true)\n            .cdnPolicy(BackendBucketCdnPolicyArgs.builder()\n                .cacheKeyPolicy(BackendBucketCdnPolicyCacheKeyPolicyArgs.builder()\n                    .includeHttpHeaders(\"X-My-Header-Field\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  imageBackend:\n    type: gcp:compute:BackendBucket\n    properties:\n      description: Contains beautiful images\n      bucketName: ${imageBucket.name}\n      enableCdn: true\n      cdnPolicy:\n        cacheKeyPolicy:\n          includeHttpHeaders:\n            - X-My-Header-Field\n  imageBucket:\n    type: gcp:storage:Bucket\n    properties:\n      location: EU\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nBackendBucket can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:compute/backendBucket:BackendBucket default projects/{{project}}/global/backendBuckets/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:compute/backendBucket:BackendBucket default {{project}}/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:compute/backendBucket:BackendBucket default {{name}}\n```\n\n ",
      "properties": {
        "bucketName": {
          "type": "string",
          "description": "Cloud Storage bucket name.\n"
        },
        "cdnPolicy": {
          "$ref": "#/types/gcp:compute/BackendBucketCdnPolicy:BackendBucketCdnPolicy",
          "description": "Cloud CDN configuration for this Backend Bucket.\nStructure is documented below.\n"
        },
        "creationTimestamp": {
          "type": "string",
          "description": "Creation timestamp in RFC3339 text format.\n"
        },
        "customResponseHeaders": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Headers that the HTTP/S load balancer should add to proxied responses.\n"
        },
        "description": {
          "type": "string",
          "description": "An optional textual description of the resource; provided by the\nclient when the resource is created.\n"
        },
        "edgeSecurityPolicy": {
          "type": "string",
          "description": "The security policy associated with this backend bucket.\n"
        },
        "enableCdn": {
          "type": "boolean",
          "description": "If true, enable Cloud CDN for this BackendBucket.\n"
        },
        "name": {
          "type": "string",
          "description": "Name of the resource. Provided by the client when the resource is\ncreated. The name must be 1-63 characters long, and comply with\nRFC1035.  Specifically, the name must be 1-63 characters long and\nmatch the regular expression `a-z?` which means\nthe first character must be a lowercase letter, and all following\ncharacters must be a dash, lowercase letter, or digit, except the\nlast character, which cannot be a dash.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n"
        },
        "selfLink": {
          "type": "string",
          "description": "The URI of the created resource.\n"
        }
      },
      "required": [
        "bucketName",
        "cdnPolicy",
        "creationTimestamp",
        "name",
        "project",
        "selfLink"
      ],
      "inputProperties": {
        "bucketName": {
          "type": "string",
          "description": "Cloud Storage bucket name.\n"
        },
        "cdnPolicy": {
          "$ref": "#/types/gcp:compute/BackendBucketCdnPolicy:BackendBucketCdnPolicy",
          "description": "Cloud CDN configuration for this Backend Bucket.\nStructure is documented below.\n"
        },
        "customResponseHeaders": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Headers that the HTTP/S load balancer should add to proxied responses.\n"
        },
        "description": {
          "type": "string",
          "description": "An optional textual description of the resource; provided by the\nclient when the resource is created.\n"
        },
        "edgeSecurityPolicy": {
          "type": "string",
          "description": "The security policy associated with this backend bucket.\n"
        },
        "enableCdn": {
          "type": "boolean",
          "description": "If true, enable Cloud CDN for this BackendBucket.\n"
        },
        "name": {
          "type": "string",
          "description": "Name of the resource. Provided by the client when the resource is\ncreated. The name must be 1-63 characters long, and comply with\nRFC1035.  Specifically, the name must be 1-63 characters long and\nmatch the regular expression `a-z?` which means\nthe first character must be a lowercase letter, and all following\ncharacters must be a dash, lowercase letter, or digit, except the\nlast character, which cannot be a dash.\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        }
      },
      "requiredInputs": [
        "bucketName"
      ],
      "stateInputs": {
        "description": "Input properties used for looking up and filtering BackendBucket resources.\n",
        "properties": {
          "bucketName": {
            "type": "string",
            "description": "Cloud Storage bucket name.\n"
          },
          "cdnPolicy": {
            "$ref": "#/types/gcp:compute/BackendBucketCdnPolicy:BackendBucketCdnPolicy",
            "description": "Cloud CDN configuration for this Backend Bucket.\nStructure is documented below.\n"
          },
          "creationTimestamp": {
            "type": "string",
            "description": "Creation timestamp in RFC3339 text format.\n"
          },
          "customResponseHeaders": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Headers that the HTTP/S load balancer should add to proxied responses.\n"
          },
          "description": {
            "type": "string",
            "description": "An optional textual description of the resource; provided by the\nclient when the resource is created.\n"
          },
          "edgeSecurityPolicy": {
            "type": "string",
            "description": "The security policy associated with this backend bucket.\n"
          },
          "enableCdn": {
            "type": "boolean",
            "description": "If true, enable Cloud CDN for this BackendBucket.\n"
          },
          "name": {
            "type": "string",
            "description": "Name of the resource. Provided by the client when the resource is\ncreated. The name must be 1-63 characters long, and comply with\nRFC1035.  Specifically, the name must be 1-63 characters long and\nmatch the regular expression `a-z?` which means\nthe first character must be a lowercase letter, and all following\ncharacters must be a dash, lowercase letter, or digit, except the\nlast character, which cannot be a dash.\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          },
          "selfLink": {
            "type": "string",
            "description": "The URI of the created resource.\n"
          }
        },
        "type": "object"
      }
    },
    "gcp:compute/externalVpnGateway:ExternalVpnGateway": {
      "description": "Represents a VPN gateway managed outside of GCP.\n\nTo get more information about ExternalVpnGateway, see:\n\n* [API documentation](https://cloud.google.com/compute/docs/reference/rest/v1/externalVpnGateways)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### External Vpn Gateway\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst network = new gcp.compute.Network(\"network\", {\n    routingMode: \"GLOBAL\",\n    autoCreateSubnetworks: false,\n});\nconst haGateway = new gcp.compute.HaVpnGateway(\"haGateway\", {\n    region: \"us-central1\",\n    network: network.id,\n});\nconst externalGateway = new gcp.compute.ExternalVpnGateway(\"externalGateway\", {\n    redundancyType: \"SINGLE_IP_INTERNALLY_REDUNDANT\",\n    description: \"An externally managed VPN gateway\",\n    interfaces: [{\n        id: 0,\n        ipAddress: \"8.8.8.8\",\n    }],\n});\nconst networkSubnet1 = new gcp.compute.Subnetwork(\"networkSubnet1\", {\n    ipCidrRange: \"10.0.1.0/24\",\n    region: \"us-central1\",\n    network: network.id,\n});\nconst networkSubnet2 = new gcp.compute.Subnetwork(\"networkSubnet2\", {\n    ipCidrRange: \"10.0.2.0/24\",\n    region: \"us-west1\",\n    network: network.id,\n});\nconst router1 = new gcp.compute.Router(\"router1\", {\n    network: network.name,\n    bgp: {\n        asn: 64514,\n    },\n});\nconst tunnel1 = new gcp.compute.VPNTunnel(\"tunnel1\", {\n    region: \"us-central1\",\n    vpnGateway: haGateway.id,\n    peerExternalGateway: externalGateway.id,\n    peerExternalGatewayInterface: 0,\n    sharedSecret: \"a secret message\",\n    router: router1.id,\n    vpnGatewayInterface: 0,\n});\nconst tunnel2 = new gcp.compute.VPNTunnel(\"tunnel2\", {\n    region: \"us-central1\",\n    vpnGateway: haGateway.id,\n    peerExternalGateway: externalGateway.id,\n    peerExternalGatewayInterface: 0,\n    sharedSecret: \"a secret message\",\n    router: pulumi.interpolate` ${router1.id}`,\n    vpnGatewayInterface: 1,\n});\nconst router1Interface1 = new gcp.compute.RouterInterface(\"router1Interface1\", {\n    router: router1.name,\n    region: \"us-central1\",\n    ipRange: \"169.254.0.1/30\",\n    vpnTunnel: tunnel1.name,\n});\nconst router1Peer1 = new gcp.compute.RouterPeer(\"router1Peer1\", {\n    router: router1.name,\n    region: \"us-central1\",\n    peerIpAddress: \"169.254.0.2\",\n    peerAsn: 64515,\n    advertisedRoutePriority: 100,\n    \"interface\": router1Interface1.name,\n});\nconst router1Interface2 = new gcp.compute.RouterInterface(\"router1Interface2\", {\n    router: router1.name,\n    region: \"us-central1\",\n    ipRange: \"169.254.1.1/30\",\n    vpnTunnel: tunnel2.name,\n});\nconst router1Peer2 = new gcp.compute.RouterPeer(\"router1Peer2\", {\n    router: router1.name,\n    region: \"us-central1\",\n    peerIpAddress: \"169.254.1.2\",\n    peerAsn: 64515,\n    advertisedRoutePriority: 100,\n    \"interface\": router1Interface2.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nnetwork = gcp.compute.Network(\"network\",\n    routing_mode=\"GLOBAL\",\n    auto_create_subnetworks=False)\nha_gateway = gcp.compute.HaVpnGateway(\"haGateway\",\n    region=\"us-central1\",\n    network=network.id)\nexternal_gateway = gcp.compute.ExternalVpnGateway(\"externalGateway\",\n    redundancy_type=\"SINGLE_IP_INTERNALLY_REDUNDANT\",\n    description=\"An externally managed VPN gateway\",\n    interfaces=[gcp.compute.ExternalVpnGatewayInterfaceArgs(\n        id=0,\n        ip_address=\"8.8.8.8\",\n    )])\nnetwork_subnet1 = gcp.compute.Subnetwork(\"networkSubnet1\",\n    ip_cidr_range=\"10.0.1.0/24\",\n    region=\"us-central1\",\n    network=network.id)\nnetwork_subnet2 = gcp.compute.Subnetwork(\"networkSubnet2\",\n    ip_cidr_range=\"10.0.2.0/24\",\n    region=\"us-west1\",\n    network=network.id)\nrouter1 = gcp.compute.Router(\"router1\",\n    network=network.name,\n    bgp=gcp.compute.RouterBgpArgs(\n        asn=64514,\n    ))\ntunnel1 = gcp.compute.VPNTunnel(\"tunnel1\",\n    region=\"us-central1\",\n    vpn_gateway=ha_gateway.id,\n    peer_external_gateway=external_gateway.id,\n    peer_external_gateway_interface=0,\n    shared_secret=\"a secret message\",\n    router=router1.id,\n    vpn_gateway_interface=0)\ntunnel2 = gcp.compute.VPNTunnel(\"tunnel2\",\n    region=\"us-central1\",\n    vpn_gateway=ha_gateway.id,\n    peer_external_gateway=external_gateway.id,\n    peer_external_gateway_interface=0,\n    shared_secret=\"a secret message\",\n    router=router1.id.apply(lambda id: f\" {id}\"),\n    vpn_gateway_interface=1)\nrouter1_interface1 = gcp.compute.RouterInterface(\"router1Interface1\",\n    router=router1.name,\n    region=\"us-central1\",\n    ip_range=\"169.254.0.1/30\",\n    vpn_tunnel=tunnel1.name)\nrouter1_peer1 = gcp.compute.RouterPeer(\"router1Peer1\",\n    router=router1.name,\n    region=\"us-central1\",\n    peer_ip_address=\"169.254.0.2\",\n    peer_asn=64515,\n    advertised_route_priority=100,\n    interface=router1_interface1.name)\nrouter1_interface2 = gcp.compute.RouterInterface(\"router1Interface2\",\n    router=router1.name,\n    region=\"us-central1\",\n    ip_range=\"169.254.1.1/30\",\n    vpn_tunnel=tunnel2.name)\nrouter1_peer2 = gcp.compute.RouterPeer(\"router1Peer2\",\n    router=router1.name,\n    region=\"us-central1\",\n    peer_ip_address=\"169.254.1.2\",\n    peer_asn=64515,\n    advertised_route_priority=100,\n    interface=router1_interface2.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var network = new Gcp.Compute.Network(\"network\", new()\n    {\n        RoutingMode = \"GLOBAL\",\n        AutoCreateSubnetworks = false,\n    });\n\n    var haGateway = new Gcp.Compute.HaVpnGateway(\"haGateway\", new()\n    {\n        Region = \"us-central1\",\n        Network = network.Id,\n    });\n\n    var externalGateway = new Gcp.Compute.ExternalVpnGateway(\"externalGateway\", new()\n    {\n        RedundancyType = \"SINGLE_IP_INTERNALLY_REDUNDANT\",\n        Description = \"An externally managed VPN gateway\",\n        Interfaces = new[]\n        {\n            new Gcp.Compute.Inputs.ExternalVpnGatewayInterfaceArgs\n            {\n                Id = 0,\n                IpAddress = \"8.8.8.8\",\n            },\n        },\n    });\n\n    var networkSubnet1 = new Gcp.Compute.Subnetwork(\"networkSubnet1\", new()\n    {\n        IpCidrRange = \"10.0.1.0/24\",\n        Region = \"us-central1\",\n        Network = network.Id,\n    });\n\n    var networkSubnet2 = new Gcp.Compute.Subnetwork(\"networkSubnet2\", new()\n    {\n        IpCidrRange = \"10.0.2.0/24\",\n        Region = \"us-west1\",\n        Network = network.Id,\n    });\n\n    var router1 = new Gcp.Compute.Router(\"router1\", new()\n    {\n        Network = network.Name,\n        Bgp = new Gcp.Compute.Inputs.RouterBgpArgs\n        {\n            Asn = 64514,\n        },\n    });\n\n    var tunnel1 = new Gcp.Compute.VPNTunnel(\"tunnel1\", new()\n    {\n        Region = \"us-central1\",\n        VpnGateway = haGateway.Id,\n        PeerExternalGateway = externalGateway.Id,\n        PeerExternalGatewayInterface = 0,\n        SharedSecret = \"a secret message\",\n        Router = router1.Id,\n        VpnGatewayInterface = 0,\n    });\n\n    var tunnel2 = new Gcp.Compute.VPNTunnel(\"tunnel2\", new()\n    {\n        Region = \"us-central1\",\n        VpnGateway = haGateway.Id,\n        PeerExternalGateway = externalGateway.Id,\n        PeerExternalGatewayInterface = 0,\n        SharedSecret = \"a secret message\",\n        Router = router1.Id.Apply(id => $\" {id}\"),\n        VpnGatewayInterface = 1,\n    });\n\n    var router1Interface1 = new Gcp.Compute.RouterInterface(\"router1Interface1\", new()\n    {\n        Router = router1.Name,\n        Region = \"us-central1\",\n        IpRange = \"169.254.0.1/30\",\n        VpnTunnel = tunnel1.Name,\n    });\n\n    var router1Peer1 = new Gcp.Compute.RouterPeer(\"router1Peer1\", new()\n    {\n        Router = router1.Name,\n        Region = \"us-central1\",\n        PeerIpAddress = \"169.254.0.2\",\n        PeerAsn = 64515,\n        AdvertisedRoutePriority = 100,\n        Interface = router1Interface1.Name,\n    });\n\n    var router1Interface2 = new Gcp.Compute.RouterInterface(\"router1Interface2\", new()\n    {\n        Router = router1.Name,\n        Region = \"us-central1\",\n        IpRange = \"169.254.1.1/30\",\n        VpnTunnel = tunnel2.Name,\n    });\n\n    var router1Peer2 = new Gcp.Compute.RouterPeer(\"router1Peer2\", new()\n    {\n        Router = router1.Name,\n        Region = \"us-central1\",\n        PeerIpAddress = \"169.254.1.2\",\n        PeerAsn = 64515,\n        AdvertisedRoutePriority = 100,\n        Interface = router1Interface2.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/compute\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnetwork, err := compute.NewNetwork(ctx, \"network\", &compute.NetworkArgs{\n\t\t\tRoutingMode:           pulumi.String(\"GLOBAL\"),\n\t\t\tAutoCreateSubnetworks: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thaGateway, err := compute.NewHaVpnGateway(ctx, \"haGateway\", &compute.HaVpnGatewayArgs{\n\t\t\tRegion:  pulumi.String(\"us-central1\"),\n\t\t\tNetwork: network.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texternalGateway, err := compute.NewExternalVpnGateway(ctx, \"externalGateway\", &compute.ExternalVpnGatewayArgs{\n\t\t\tRedundancyType: pulumi.String(\"SINGLE_IP_INTERNALLY_REDUNDANT\"),\n\t\t\tDescription:    pulumi.String(\"An externally managed VPN gateway\"),\n\t\t\tInterfaces: compute.ExternalVpnGatewayInterfaceArray{\n\t\t\t\t&compute.ExternalVpnGatewayInterfaceArgs{\n\t\t\t\t\tId:        pulumi.Int(0),\n\t\t\t\t\tIpAddress: pulumi.String(\"8.8.8.8\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewSubnetwork(ctx, \"networkSubnet1\", &compute.SubnetworkArgs{\n\t\t\tIpCidrRange: pulumi.String(\"10.0.1.0/24\"),\n\t\t\tRegion:      pulumi.String(\"us-central1\"),\n\t\t\tNetwork:     network.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewSubnetwork(ctx, \"networkSubnet2\", &compute.SubnetworkArgs{\n\t\t\tIpCidrRange: pulumi.String(\"10.0.2.0/24\"),\n\t\t\tRegion:      pulumi.String(\"us-west1\"),\n\t\t\tNetwork:     network.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trouter1, err := compute.NewRouter(ctx, \"router1\", &compute.RouterArgs{\n\t\t\tNetwork: network.Name,\n\t\t\tBgp: &compute.RouterBgpArgs{\n\t\t\t\tAsn: pulumi.Int(64514),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttunnel1, err := compute.NewVPNTunnel(ctx, \"tunnel1\", &compute.VPNTunnelArgs{\n\t\t\tRegion:                       pulumi.String(\"us-central1\"),\n\t\t\tVpnGateway:                   haGateway.ID(),\n\t\t\tPeerExternalGateway:          externalGateway.ID(),\n\t\t\tPeerExternalGatewayInterface: pulumi.Int(0),\n\t\t\tSharedSecret:                 pulumi.String(\"a secret message\"),\n\t\t\tRouter:                       router1.ID(),\n\t\t\tVpnGatewayInterface:          pulumi.Int(0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttunnel2, err := compute.NewVPNTunnel(ctx, \"tunnel2\", &compute.VPNTunnelArgs{\n\t\t\tRegion:                       pulumi.String(\"us-central1\"),\n\t\t\tVpnGateway:                   haGateway.ID(),\n\t\t\tPeerExternalGateway:          externalGateway.ID(),\n\t\t\tPeerExternalGatewayInterface: pulumi.Int(0),\n\t\t\tSharedSecret:                 pulumi.String(\"a secret message\"),\n\t\t\tRouter: router1.ID().ApplyT(func(id string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\" %v\", id), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tVpnGatewayInterface: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trouter1Interface1, err := compute.NewRouterInterface(ctx, \"router1Interface1\", &compute.RouterInterfaceArgs{\n\t\t\tRouter:    router1.Name,\n\t\t\tRegion:    pulumi.String(\"us-central1\"),\n\t\t\tIpRange:   pulumi.String(\"169.254.0.1/30\"),\n\t\t\tVpnTunnel: tunnel1.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewRouterPeer(ctx, \"router1Peer1\", &compute.RouterPeerArgs{\n\t\t\tRouter:                  router1.Name,\n\t\t\tRegion:                  pulumi.String(\"us-central1\"),\n\t\t\tPeerIpAddress:           pulumi.String(\"169.254.0.2\"),\n\t\t\tPeerAsn:                 pulumi.Int(64515),\n\t\t\tAdvertisedRoutePriority: pulumi.Int(100),\n\t\t\tInterface:               router1Interface1.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trouter1Interface2, err := compute.NewRouterInterface(ctx, \"router1Interface2\", &compute.RouterInterfaceArgs{\n\t\t\tRouter:    router1.Name,\n\t\t\tRegion:    pulumi.String(\"us-central1\"),\n\t\t\tIpRange:   pulumi.String(\"169.254.1.1/30\"),\n\t\t\tVpnTunnel: tunnel2.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewRouterPeer(ctx, \"router1Peer2\", &compute.RouterPeerArgs{\n\t\t\tRouter:                  router1.Name,\n\t\t\tRegion:                  pulumi.String(\"us-central1\"),\n\t\t\tPeerIpAddress:           pulumi.String(\"169.254.1.2\"),\n\t\t\tPeerAsn:                 pulumi.Int(64515),\n\t\t\tAdvertisedRoutePriority: pulumi.Int(100),\n\t\t\tInterface:               router1Interface2.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.compute.Network;\nimport com.pulumi.gcp.compute.NetworkArgs;\nimport com.pulumi.gcp.compute.HaVpnGateway;\nimport com.pulumi.gcp.compute.HaVpnGatewayArgs;\nimport com.pulumi.gcp.compute.ExternalVpnGateway;\nimport com.pulumi.gcp.compute.ExternalVpnGatewayArgs;\nimport com.pulumi.gcp.compute.inputs.ExternalVpnGatewayInterfaceArgs;\nimport com.pulumi.gcp.compute.Subnetwork;\nimport com.pulumi.gcp.compute.SubnetworkArgs;\nimport com.pulumi.gcp.compute.Router;\nimport com.pulumi.gcp.compute.RouterArgs;\nimport com.pulumi.gcp.compute.inputs.RouterBgpArgs;\nimport com.pulumi.gcp.compute.VPNTunnel;\nimport com.pulumi.gcp.compute.VPNTunnelArgs;\nimport com.pulumi.gcp.compute.RouterInterface;\nimport com.pulumi.gcp.compute.RouterInterfaceArgs;\nimport com.pulumi.gcp.compute.RouterPeer;\nimport com.pulumi.gcp.compute.RouterPeerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var network = new Network(\"network\", NetworkArgs.builder()        \n            .routingMode(\"GLOBAL\")\n            .autoCreateSubnetworks(false)\n            .build());\n\n        var haGateway = new HaVpnGateway(\"haGateway\", HaVpnGatewayArgs.builder()        \n            .region(\"us-central1\")\n            .network(network.id())\n            .build());\n\n        var externalGateway = new ExternalVpnGateway(\"externalGateway\", ExternalVpnGatewayArgs.builder()        \n            .redundancyType(\"SINGLE_IP_INTERNALLY_REDUNDANT\")\n            .description(\"An externally managed VPN gateway\")\n            .interfaces(ExternalVpnGatewayInterfaceArgs.builder()\n                .id(0)\n                .ipAddress(\"8.8.8.8\")\n                .build())\n            .build());\n\n        var networkSubnet1 = new Subnetwork(\"networkSubnet1\", SubnetworkArgs.builder()        \n            .ipCidrRange(\"10.0.1.0/24\")\n            .region(\"us-central1\")\n            .network(network.id())\n            .build());\n\n        var networkSubnet2 = new Subnetwork(\"networkSubnet2\", SubnetworkArgs.builder()        \n            .ipCidrRange(\"10.0.2.0/24\")\n            .region(\"us-west1\")\n            .network(network.id())\n            .build());\n\n        var router1 = new Router(\"router1\", RouterArgs.builder()        \n            .network(network.name())\n            .bgp(RouterBgpArgs.builder()\n                .asn(64514)\n                .build())\n            .build());\n\n        var tunnel1 = new VPNTunnel(\"tunnel1\", VPNTunnelArgs.builder()        \n            .region(\"us-central1\")\n            .vpnGateway(haGateway.id())\n            .peerExternalGateway(externalGateway.id())\n            .peerExternalGatewayInterface(0)\n            .sharedSecret(\"a secret message\")\n            .router(router1.id())\n            .vpnGatewayInterface(0)\n            .build());\n\n        var tunnel2 = new VPNTunnel(\"tunnel2\", VPNTunnelArgs.builder()        \n            .region(\"us-central1\")\n            .vpnGateway(haGateway.id())\n            .peerExternalGateway(externalGateway.id())\n            .peerExternalGatewayInterface(0)\n            .sharedSecret(\"a secret message\")\n            .router(router1.id().applyValue(id -> String.format(\" %s\", id)))\n            .vpnGatewayInterface(1)\n            .build());\n\n        var router1Interface1 = new RouterInterface(\"router1Interface1\", RouterInterfaceArgs.builder()        \n            .router(router1.name())\n            .region(\"us-central1\")\n            .ipRange(\"169.254.0.1/30\")\n            .vpnTunnel(tunnel1.name())\n            .build());\n\n        var router1Peer1 = new RouterPeer(\"router1Peer1\", RouterPeerArgs.builder()        \n            .router(router1.name())\n            .region(\"us-central1\")\n            .peerIpAddress(\"169.254.0.2\")\n            .peerAsn(64515)\n            .advertisedRoutePriority(100)\n            .interface_(router1Interface1.name())\n            .build());\n\n        var router1Interface2 = new RouterInterface(\"router1Interface2\", RouterInterfaceArgs.builder()        \n            .router(router1.name())\n            .region(\"us-central1\")\n            .ipRange(\"169.254.1.1/30\")\n            .vpnTunnel(tunnel2.name())\n            .build());\n\n        var router1Peer2 = new RouterPeer(\"router1Peer2\", RouterPeerArgs.builder()        \n            .router(router1.name())\n            .region(\"us-central1\")\n            .peerIpAddress(\"169.254.1.2\")\n            .peerAsn(64515)\n            .advertisedRoutePriority(100)\n            .interface_(router1Interface2.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  haGateway:\n    type: gcp:compute:HaVpnGateway\n    properties:\n      region: us-central1\n      network: ${network.id}\n  externalGateway:\n    type: gcp:compute:ExternalVpnGateway\n    properties:\n      redundancyType: SINGLE_IP_INTERNALLY_REDUNDANT\n      description: An externally managed VPN gateway\n      interfaces:\n        - id: 0\n          ipAddress: 8.8.8.8\n  network:\n    type: gcp:compute:Network\n    properties:\n      routingMode: GLOBAL\n      autoCreateSubnetworks: false\n  networkSubnet1:\n    type: gcp:compute:Subnetwork\n    properties:\n      ipCidrRange: 10.0.1.0/24\n      region: us-central1\n      network: ${network.id}\n  networkSubnet2:\n    type: gcp:compute:Subnetwork\n    properties:\n      ipCidrRange: 10.0.2.0/24\n      region: us-west1\n      network: ${network.id}\n  router1:\n    type: gcp:compute:Router\n    properties:\n      network: ${network.name}\n      bgp:\n        asn: 64514\n  tunnel1:\n    type: gcp:compute:VPNTunnel\n    properties:\n      region: us-central1\n      vpnGateway: ${haGateway.id}\n      peerExternalGateway: ${externalGateway.id}\n      peerExternalGatewayInterface: 0\n      sharedSecret: a secret message\n      router: ${router1.id}\n      vpnGatewayInterface: 0\n  tunnel2:\n    type: gcp:compute:VPNTunnel\n    properties:\n      region: us-central1\n      vpnGateway: ${haGateway.id}\n      peerExternalGateway: ${externalGateway.id}\n      peerExternalGatewayInterface: 0\n      sharedSecret: a secret message\n      router: ' ${router1.id}'\n      vpnGatewayInterface: 1\n  router1Interface1:\n    type: gcp:compute:RouterInterface\n    properties:\n      router: ${router1.name}\n      region: us-central1\n      ipRange: 169.254.0.1/30\n      vpnTunnel: ${tunnel1.name}\n  router1Peer1:\n    type: gcp:compute:RouterPeer\n    properties:\n      router: ${router1.name}\n      region: us-central1\n      peerIpAddress: 169.254.0.2\n      peerAsn: 64515\n      advertisedRoutePriority: 100\n      interface: ${router1Interface1.name}\n  router1Interface2:\n    type: gcp:compute:RouterInterface\n    properties:\n      router: ${router1.name}\n      region: us-central1\n      ipRange: 169.254.1.1/30\n      vpnTunnel: ${tunnel2.name}\n  router1Peer2:\n    type: gcp:compute:RouterPeer\n    properties:\n      router: ${router1.name}\n      region: us-central1\n      peerIpAddress: 169.254.1.2\n      peerAsn: 64515\n      advertisedRoutePriority: 100\n      interface: ${router1Interface2.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nExternalVpnGateway can be imported using any of these accepted formats\n\n```sh\n $ pulumi import gcp:compute/externalVpnGateway:ExternalVpnGateway default projects/{{project}}/global/externalVpnGateways/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:compute/externalVpnGateway:ExternalVpnGateway default {{project}}/{{name}}\n```\n\n\n\n```sh\n $ pulumi import gcp:compute/externalVpnGateway:ExternalVpnGateway default {{name}}\n```\n\n ",
      "properties": {
        "description": {
          "type": "string",
          "description": "An optional description of this resource.\n"
        },
        "interfaces": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/ExternalVpnGatewayInterface:ExternalVpnGatewayInterface"
          },
          "description": "A list of interfaces on this external VPN gateway.\nStructure is documented below.\n"
        },
        "name": {
          "type": "string",
          "description": "Name of the resource. Provided by the client when the resource is\ncreated. The name must be 1-63 characters long, and comply with\nRFC1035.  Specifically, the name must be 1-63 characters long and\nmatch the regular expression `a-z?` which means\nthe first character must be a lowercase letter, and all following\ncharacters must be a dash, lowercase letter, or digit, except the last\ncharacter, which cannot be a dash.\n"
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n"
        },
        "redundancyType": {
          "type": "string",
          "description": "Indicates the redundancy type of this external VPN gateway\nPossible values are `FOUR_IPS_REDUNDANCY`, `SINGLE_IP_INTERNALLY_REDUNDANT`, and `TWO_IPS_REDUNDANCY`.\n"
        },
        "selfLink": {
          "type": "string",
          "description": "The URI of the created resource.\n"
        }
      },
      "required": [
        "name",
        "project",
        "selfLink"
      ],
      "inputProperties": {
        "description": {
          "type": "string",
          "description": "An optional description of this resource.\n",
          "willReplaceOnChanges": true
        },
        "interfaces": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/ExternalVpnGatewayInterface:ExternalVpnGatewayInterface"
          },
          "willReplaceOnChanges": true,
          "description": "A list of interfaces on this external VPN gateway.\nStructure is documented below.\n"
        },
        "name": {
          "type": "string",
          "description": "Name of the resource. Provided by the client when the resource is\ncreated. The name must be 1-63 characters long, and comply with\nRFC1035.  Specifically, the name must be 1-63 characters long and\nmatch the regular expression `a-z?` which means\nthe first character must be a lowercase letter, and all following\ncharacters must be a dash, lowercase letter, or digit, except the last\ncharacter, which cannot be a dash.\n",
          "willReplaceOnChanges": true
        },
        "project": {
          "type": "string",
          "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
          "willReplaceOnChanges": true
        },
        "redundancyType": {
          "type": "string",
          "description": "Indicates the redundancy type of this external VPN gateway\nPossible values are `FOUR_IPS_REDUNDANCY`, `SINGLE_IP_INTERNALLY_REDUNDANT`, and `TWO_IPS_REDUNDANCY`.\n",
          "willReplaceOnChanges": true
        }
      },
      "stateInputs": {
        "description": "Input properties used for looking up and filtering ExternalVpnGateway resources.\n",
        "properties": {
          "description": {
            "type": "string",
            "description": "An optional description of this resource.\n",
            "willReplaceOnChanges": true
          },
          "interfaces": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:compute/ExternalVpnGatewayInterface:ExternalVpnGatewayInterface"
            },
            "description": "A list of interfaces on this external VPN gateway.\nStructure is documented below.\n",
            "willReplaceOnChanges": true
          },
          "name": {
            "type": "string",
            "description": "Name of the resource. Provided by the client when the resource is\ncreated. The name must be 1-63 characters long, and comply with\nRFC1035.  Specifically, the name must be 1-63 characters long and\nmatch the regular expression `a-z?` which means\nthe first character must be a lowercase letter, and all following\ncharacters must be a dash, lowercase letter, or digit, except the last\ncharacter, which cannot be a dash.\n",
            "willReplaceOnChanges": true
          },
          "project": {
            "type": "string",
            "description": "The ID of the project in which the resource belongs.\nIf it is not provided, the provider project is used.\n",
            "willReplaceOnChanges": true
          },
          "redundancyType": {
            "type": "string",
            "description": "Indicates the redundancy type of this external VPN gateway\nPossible values are `FOUR_IPS_REDUNDANCY`, `SINGLE_IP_INTERNALLY_REDUNDANT`, and `TWO_IPS_REDUNDANCY`.\n",
            "willReplaceOnChanges": true
          },
          "selfLink": {
            "type": "string",
            "description": "The URI of the created resource.\n"
          }
        },
        "type": "object"
      }
    }
  },
  "functions": {
    "gcp:organizations/getIAMPolicy:getIAMPolicy": {
      "inputs": {
        "properties": {
          "auditConfigs": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:organizations/getIAMPolicyAuditConfig:getIAMPolicyAuditConfig"
            },
            "description": "A nested configuration block that defines logging additional configuration for your project. This field is only supported on `gcp.projects.IAMPolicy`, `gcp.folder.IAMPolicy` and `gcp.organizations.IAMPolicy`.\n"
          },
          "bindings": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:organizations/getIAMPolicyBinding:getIAMPolicyBinding"
            },
            "description": "A nested configuration block (described below)\ndefining a binding to be included in the policy document. Multiple\n`binding` arguments are supported.\n"
          }
        },
        "description": "A collection of arguments for invoking getIAMPolicy.\n"
      },
      "outputs": {
        "properties": {
          "auditConfigs": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:organizations/getIAMPolicyAuditConfig:getIAMPolicyAuditConfig"
            }
          },
          "bindings": {
            "type": "array",
            "items": {
              "$ref": "#/types/gcp:organizations/getIAMPolicyBinding:getIAMPolicyBinding"
            }
          },
          "id": {
            "type": "string",
            "description": "The provider-assigned unique ID for this managed resource.\n"
          },
          "policyData": {
            "type": "string",
            "description": "The above bindings serialized in a format suitable for\nreferencing from a resource that supports IAM.\n"
          }
        },
        "required": [
          "policyData",
          "id"
        ],
        "description": "A collection of values returned by getIAMPolicy.\n"
      },
      "description": "Generates an IAM policy document that may be referenced by and applied to\nother Google Cloud Platform IAM resources, such as the `gcp.projects.IAMPolicy` resource.\n\n**Note:** Please review the documentation of the resource that you will be using the datasource with. Some resources such as `gcp.projects.IAMPolicy` and others have limitations in their API methods which are noted on their respective page.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\n\nconst admin = pulumi.output(gcp.organizations.getIAMPolicy({\n    auditConfigs: [{\n        auditLogConfigs: [\n            {\n                exemptedMembers: [\"user:you@domain.com\"],\n                logType: \"DATA_READ\",\n            },\n            {\n                logType: \"DATA_WRITE\",\n            },\n            {\n                logType: \"ADMIN_READ\",\n            },\n        ],\n        service: \"cloudkms.googleapis.com\",\n    }],\n    bindings: [\n        {\n            members: [\"serviceAccount:your-custom-sa@your-project.iam.gserviceaccount.com\"],\n            role: \"roles/compute.instanceAdmin\",\n        },\n        {\n            members: [\"user:alice@gmail.com\"],\n            role: \"roles/storage.objectViewer\",\n        },\n    ],\n}));\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\n\nadmin = gcp.organizations.get_iam_policy(audit_configs=[gcp.organizations.GetIAMPolicyAuditConfigArgs(\n        audit_log_configs=[\n            gcp.organizations.GetIAMPolicyAuditConfigAuditLogConfigArgs(\n                exempted_members=[\"user:you@domain.com\"],\n                log_type=\"DATA_READ\",\n            ),\n            gcp.organizations.GetIAMPolicyAuditConfigAuditLogConfigArgs(\n                log_type=\"DATA_WRITE\",\n            ),\n            gcp.organizations.GetIAMPolicyAuditConfigAuditLogConfigArgs(\n                log_type=\"ADMIN_READ\",\n            ),\n        ],\n        service=\"cloudkms.googleapis.com\",\n    )],\n    bindings=[\n        gcp.organizations.GetIAMPolicyBindingArgs(\n            members=[\"serviceAccount:your-custom-sa@your-project.iam.gserviceaccount.com\"],\n            role=\"roles/compute.instanceAdmin\",\n        ),\n        gcp.organizations.GetIAMPolicyBindingArgs(\n            members=[\"user:alice@gmail.com\"],\n            role=\"roles/storage.objectViewer\",\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\n\nreturn await Deployment.RunAsync(() => \n{\n    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()\n    {\n        AuditConfigs = new[]\n        {\n            new Gcp.Organizations.Inputs.GetIAMPolicyAuditConfigInputArgs\n            {\n                AuditLogConfigs = new[]\n                {\n                    new Gcp.Organizations.Inputs.GetIAMPolicyAuditConfigAuditLogConfigInputArgs\n                    {\n                        ExemptedMembers = new[]\n                        {\n                            \"user:you@domain.com\",\n                        },\n                        LogType = \"DATA_READ\",\n                    },\n                    new Gcp.Organizations.Inputs.GetIAMPolicyAuditConfigAuditLogConfigInputArgs\n                    {\n                        LogType = \"DATA_WRITE\",\n                    },\n                    new Gcp.Organizations.Inputs.GetIAMPolicyAuditConfigAuditLogConfigInputArgs\n                    {\n                        LogType = \"ADMIN_READ\",\n                    },\n                },\n                Service = \"cloudkms.googleapis.com\",\n            },\n        },\n        Bindings = new[]\n        {\n            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs\n            {\n                Members = new[]\n                {\n                    \"serviceAccount:your-custom-sa@your-project.iam.gserviceaccount.com\",\n                },\n                Role = \"roles/compute.instanceAdmin\",\n            },\n            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs\n            {\n                Members = new[]\n                {\n                    \"user:alice@gmail.com\",\n                },\n                Role = \"roles/storage.objectViewer\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/organizations\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{\n\t\t\tAuditConfigs: []organizations.GetIAMPolicyAuditConfig{\n\t\t\t\torganizations.GetIAMPolicyAuditConfig{\n\t\t\t\t\tAuditLogConfigs: []organizations.GetIAMPolicyAuditConfigAuditLogConfig{\n\t\t\t\t\t\torganizations.GetIAMPolicyAuditConfigAuditLogConfig{\n\t\t\t\t\t\t\tExemptedMembers: []string{\n\t\t\t\t\t\t\t\t\"user:you@domain.com\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tLogType: \"DATA_READ\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\torganizations.GetIAMPolicyAuditConfigAuditLogConfig{\n\t\t\t\t\t\t\tLogType: \"DATA_WRITE\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\torganizations.GetIAMPolicyAuditConfigAuditLogConfig{\n\t\t\t\t\t\t\tLogType: \"ADMIN_READ\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tService: \"cloudkms.googleapis.com\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tBindings: []organizations.GetIAMPolicyBinding{\n\t\t\t\torganizations.GetIAMPolicyBinding{\n\t\t\t\t\tMembers: []string{\n\t\t\t\t\t\t\"serviceAccount:your-custom-sa@your-project.iam.gserviceaccount.com\",\n\t\t\t\t\t},\n\t\t\t\t\tRole: \"roles/compute.instanceAdmin\",\n\t\t\t\t},\n\t\t\t\torganizations.GetIAMPolicyBinding{\n\t\t\t\t\tMembers: []string{\n\t\t\t\t\t\t\"user:alice@gmail.com\",\n\t\t\t\t\t},\n\t\t\t\t\tRole: \"roles/storage.objectViewer\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gcp.organizations.OrganizationsFunctions;\nimport com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()\n            .auditConfigs(GetIAMPolicyAuditConfigArgs.builder()\n                .auditLogConfigs(                \n                    GetIAMPolicyAuditConfigAuditLogConfigArgs.builder()\n                        .exemptedMembers(\"user:you@domain.com\")\n                        .logType(\"DATA_READ\")\n                        .build(),\n                    GetIAMPolicyAuditConfigAuditLogConfigArgs.builder()\n                        .logType(\"DATA_WRITE\")\n                        .build(),\n                    GetIAMPolicyAuditConfigAuditLogConfigArgs.builder()\n                        .logType(\"ADMIN_READ\")\n                        .build())\n                .service(\"cloudkms.googleapis.com\")\n                .build())\n            .bindings(            \n                GetIAMPolicyBindingArgs.builder()\n                    .members(\"serviceAccount:your-custom-sa@your-project.iam.gserviceaccount.com\")\n                    .role(\"roles/compute.instanceAdmin\")\n                    .build(),\n                GetIAMPolicyBindingArgs.builder()\n                    .members(\"user:alice@gmail.com\")\n                    .role(\"roles/storage.objectViewer\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  admin:\n    Fn::Invoke:\n      Function: gcp:organizations:getIAMPolicy\n      Arguments:\n        auditConfigs:\n          - auditLogConfigs:\n              - exemptedMembers:\n                  - user:you@domain.com\n                logType: DATA_READ\n              - logType: DATA_WRITE\n              - logType: ADMIN_READ\n            service: cloudkms.googleapis.com\n        bindings:\n          - members:\n              - serviceAccount:your-custom-sa@your-project.iam.gserviceaccount.com\n            role: roles/compute.instanceAdmin\n          - members:\n              - user:alice@gmail.com\n            role: roles/storage.objectViewer\n```\n\nThis data source is used to define IAM policies to apply to other resources.\nCurrently, defining a policy through a datasource and referencing that policy\nfrom another resource is the only way to apply an IAM policy to a resource.\n"
    }
  },
  "types": {
    "gcp:accesscontextmanager/AccessLevelConditionDevicePolicy:AccessLevelConditionDevicePolicy": {
      "properties": {
        "allowedDeviceManagementLevels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "willReplaceOnChanges": true,
          "description": "A list of allowed device management levels.\nAn empty list allows all management levels.\nEach value may be one of `MANAGEMENT_UNSPECIFIED`, `NONE`, `BASIC`, and `COMPLETE`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "allowedEncryptionStatuses": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "willReplaceOnChanges": true,
          "description": "A list of allowed encryptions statuses.\nAn empty list allows all statuses.\nEach value may be one of `ENCRYPTION_UNSPECIFIED`, `ENCRYPTION_UNSUPPORTED`, `UNENCRYPTED`, and `ENCRYPTED`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "osConstraints": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:accesscontextmanager/AccessLevelConditionDevicePolicyOsConstraint:AccessLevelConditionDevicePolicyOsConstraint"
          },
          "willReplaceOnChanges": true,
          "description": "A list of allowed OS versions.\nAn empty list allows all types and all versions.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "requireAdminApproval": {
          "type": "boolean",
          "description": "Whether the device needs to be approved by the customer admin.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "requireCorpOwned": {
          "type": "boolean",
          "description": "Whether the device needs to be corp owned.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "requireScreenLock": {
          "type": "boolean",
          "description": "Whether or not screenlock is required for the DevicePolicy\nto be true. Defaults to false.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:accesscontextmanager/AccessLevelConditionDevicePolicyOsConstraint:AccessLevelConditionDevicePolicyOsConstraint": {
      "properties": {
        "minimumVersion": {
          "type": "string",
          "description": "The minimum allowed OS version. If not set, any version\nof this OS satisfies the constraint.\nFormat: \"major.minor.patch\" such as \"10.5.301\", \"9.2.1\".\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "osType": {
          "type": "string",
          "description": "The operating system type of the device.\nPossible values are `OS_UNSPECIFIED`, `DESKTOP_MAC`, `DESKTOP_WINDOWS`, `DESKTOP_LINUX`, `DESKTOP_CHROME_OS`, `ANDROID`, and `IOS`.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "osType"
      ]
    },
    "gcp:appengine/ApplicationUrlDispatchRulesDispatchRule:ApplicationUrlDispatchRulesDispatchRule": {
      "properties": {
        "domain": {
          "type": "string",
          "description": "Domain name to match against. The wildcard \"*\" is supported if specified before a period: \"*.\".\nDefaults to matching all domains: \"*\".\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "path": {
          "type": "string",
          "description": "Pathname within the host. Must start with a \"/\". A single \"*\" can be included at the end of the path.\nThe sum of the lengths of the domain and path may not exceed 100 characters.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "service": {
          "type": "string",
          "description": "Pathname within the host. Must start with a \"/\". A single \"*\" can be included at the end of the path.\nThe sum of the lengths of the domain and path may not exceed 100 characters.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "path",
        "service"
      ]
    },
    "gcp:assuredworkloads/WorkloadKmsSettings:WorkloadKmsSettings": {
      "properties": {
        "nextRotationTime": {
          "type": "string",
          "description": "Required. Input only. Immutable. The time at which the Key Management Service will automatically create a new version of the crypto key and mark it as the primary.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "rotationPeriod": {
          "type": "string",
          "description": "Required. Input only. Immutable. will be advanced by this period when the Key Management Service automatically rotates a key. Must be at least 24 hours and at most 876,000 hours.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "nextRotationTime",
        "rotationPeriod"
      ]
    },
    "gcp:assuredworkloads/WorkloadResourceSetting:WorkloadResourceSetting": {
      "properties": {
        "resourceId": {
          "type": "string",
          "description": "Resource identifier. For a project this represents project_number. If the project is already taken, the workload creation will fail.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "resourceType": {
          "type": "string",
          "description": "Indicates the type of resource. This field should be specified to correspond the id to the right project type (CONSUMER_PROJECT or ENCRYPTION_KEYS_PROJECT) Possible values: RESOURCE_TYPE_UNSPECIFIED, CONSUMER_PROJECT, ENCRYPTION_KEYS_PROJECT, KEYRING, CONSUMER_FOLDER\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:assuredworkloads/WorkloadResource:WorkloadResource": {
      "properties": {
        "resourceId": {
          "type": "integer",
          "description": "Resource identifier. For a project this represents project_number. If the project is already taken, the workload creation will fail.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "resourceType": {
          "type": "string",
          "description": "Indicates the type of resource. This field should be specified to correspond the id to the right project type (CONSUMER_PROJECT or ENCRYPTION_KEYS_PROJECT) Possible values: RESOURCE_TYPE_UNSPECIFIED, CONSUMER_PROJECT, ENCRYPTION_KEYS_PROJECT, KEYRING, CONSUMER_FOLDER\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "resourceId",
            "resourceType"
          ]
        }
      }
    },
    "gcp:bigquery/DatasetAccess:DatasetAccess": {
      "properties": {
        "dataset": {
          "$ref": "#/types/gcp:bigquery/DatasetAccessDataset:DatasetAccessDataset",
          "description": "The dataset this entry applies to\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "domain": {
          "type": "string",
          "description": "A domain to grant access to. Any users signed in with the\ndomain specified will be granted the specified access\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "groupByEmail": {
          "type": "string",
          "description": "An email address of a Google Group to grant access to.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "role": {
          "type": "string",
          "description": "Describes the rights granted to the user specified by the other\nmember of the access object. Basic, predefined, and custom roles\nare supported. Predefined roles that have equivalent basic roles\nare swapped by the API to their basic counterparts. See\n[official docs](https://cloud.google.com/bigquery/docs/access-control).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "specialGroup": {
          "type": "string",
          "description": "A special group to grant access to. Possible values include:\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "userByEmail": {
          "type": "string",
          "description": "An email address of a user to grant access to. For example:\nfred@example.com\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "view": {
          "$ref": "#/types/gcp:bigquery/DatasetAccessView:DatasetAccessView",
          "description": "A view from a different dataset to grant access to. Queries\nexecuted against that view will have read access to tables in\nthis dataset. The role field is not required when this field is\nset. If that view is updated by any user, access to the view\nneeds to be granted again via an update operation.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:bigquery/DatasetAccessDataset:DatasetAccessDataset": {
      "properties": {
        "dataset": {
          "$ref": "#/types/gcp:bigquery/DatasetAccessDatasetDataset:DatasetAccessDatasetDataset",
          "description": "The dataset this entry applies to\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "targetTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Which resources in the dataset this entry applies to. Currently, only views are supported,\nbut additional target types may be added in the future. Possible values: VIEWS\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "dataset",
        "targetTypes"
      ]
    },
    "gcp:bigquery/DatasetAccessDatasetDataset:DatasetAccessDatasetDataset": {
      "properties": {
        "datasetId": {
          "type": "string",
          "description": "The ID of the dataset containing this table.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "projectId": {
          "type": "string",
          "description": "The ID of the project containing this table.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "datasetId",
        "projectId"
      ]
    },
    "gcp:bigquery/DatasetAccessView:DatasetAccessView": {
      "properties": {
        "datasetId": {
          "type": "string",
          "description": "The ID of the dataset containing this table.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "projectId": {
          "type": "string",
          "description": "The ID of the project containing this table.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "tableId": {
          "type": "string",
          "description": "The ID of the table. The ID must contain only letters (a-z,\nA-Z), numbers (0-9), or underscores (_). The maximum length\nis 1,024 characters.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "datasetId",
        "projectId",
        "tableId"
      ]
    },
    "gcp:bigquery/DatasetDefaultEncryptionConfiguration:DatasetDefaultEncryptionConfiguration": {
      "properties": {
        "kmsKeyName": {
          "type": "string",
          "description": "Describes the Cloud KMS encryption key that will be used to protect destination\nBigQuery table. The BigQuery Service Account associated with your project requires\naccess to this encryption key.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "kmsKeyName"
      ]
    },
    "gcp:bigquery/DatasetAccessAuthorizedDataset:DatasetAccessAuthorizedDataset": {
      "properties": {
        "dataset": {
          "$ref": "#/types/gcp:bigquery/DatasetAccessAuthorizedDatasetDataset:DatasetAccessAuthorizedDatasetDataset",
          "willReplaceOnChanges": true,
          "description": "The dataset this entry applies to\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "targetTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "willReplaceOnChanges": true,
          "description": "Which resources in the dataset this entry applies to. Currently, only views are supported,\nbut additional target types may be added in the future. Possible values: VIEWS\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "dataset",
        "targetTypes"
      ]
    },
    "gcp:bigquery/DatasetAccessAuthorizedDatasetDataset:DatasetAccessAuthorizedDatasetDataset": {
      "properties": {
        "datasetId": {
          "type": "string",
          "description": "The ID of the dataset containing this table.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "projectId": {
          "type": "string",
          "description": "The ID of the project containing this table.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "datasetId",
        "projectId"
      ]
    },
    "gcp:bigquery/RoutineArgument:RoutineArgument": {
      "properties": {
        "argumentKind": {
          "type": "string",
          "description": "Defaults to FIXED_TYPE.\nDefault value is `FIXED_TYPE`.\nPossible values are `FIXED_TYPE` and `ANY_TYPE`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "dataType": {
          "type": "string",
          "description": "A JSON schema for the data type. Required unless argumentKind = ANY_TYPE.\n~>**NOTE**: Because this field expects a JSON string, any changes to the string\nwill create a diff, even if the JSON itself hasn't changed. If the API returns\na different value for the same schema, e.g. it switched the order of values\nor replaced STRUCT field type with RECORD field type, we currently cannot\nsuppress the recurring diff this causes. As a workaround, we recommend using\nthe schema as returned by the API.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "mode": {
          "type": "string",
          "description": "Specifies whether the argument is input or output. Can be set for procedures only.\nPossible values are `IN`, `OUT`, and `INOUT`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "description": "The name of this argument. Can be absent for function return argument.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:bigtable/GCPolicyMaxAge:GCPolicyMaxAge": {
      "properties": {
        "days": {
          "type": "integer",
          "description": "Number of days before applying GC policy.\n",
          "willReplaceOnChanges": true,
          "deprecationMessage": "Deprecated in favor of duration",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "duration": {
          "type": "string",
          "description": "Duration before applying GC policy (ex. \"8h\"). This is required when `days` isn't set\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "days",
            "duration"
          ]
        }
      }
    },
    "gcp:bigtable/GCPolicyMaxVersion:GCPolicyMaxVersion": {
      "properties": {
        "number": {
          "type": "integer",
          "description": "Number of version before applying the GC policy.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "number"
      ]
    },
    "gcp:bigtable/InstanceCluster:InstanceCluster": {
      "properties": {
        "autoscalingConfig": {
          "$ref": "#/types/gcp:bigtable/InstanceClusterAutoscalingConfig:InstanceClusterAutoscalingConfig",
          "description": "Autoscaling config for the cluster, contains the following arguments:\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "clusterId": {
          "type": "string",
          "description": "The ID of the Cloud Bigtable cluster.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "kmsKeyName": {
          "type": "string",
          "description": "Describes the Cloud KMS encryption key that will be used to protect the destination Bigtable cluster. The requirements for this key are: 1) The Cloud Bigtable service account associated with the project that contains this cluster must be granted the `cloudkms.cryptoKeyEncrypterDecrypter` role on the CMEK key. 2) Only regional keys can be used and the region of the CMEK key must match the region of the cluster.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "numNodes": {
          "type": "integer",
          "description": "The number of nodes in your Cloud Bigtable cluster.\nRequired, with a minimum of `1` for a `PRODUCTION` instance. Must be left unset\nfor a `DEVELOPMENT` instance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "storageType": {
          "type": "string",
          "description": "The storage type to use. One of `\"SSD\"` or\n`\"HDD\"`. Defaults to `\"SSD\"`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "zone": {
          "type": "string",
          "description": "The zone to create the Cloud Bigtable cluster in. If it not\nspecified, the provider zone is used. Each cluster must have a different zone in the same region. Zones that support\nBigtable instances are noted on the [Cloud Bigtable locations page](https://cloud.google.com/bigtable/docs/locations).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "clusterId"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "clusterId",
            "kmsKeyName",
            "numNodes",
            "zone"
          ]
        }
      }
    },
    "gcp:bigtable/InstanceClusterAutoscalingConfig:InstanceClusterAutoscalingConfig": {
      "properties": {
        "cpuTarget": {
          "type": "integer",
          "description": "The CPU utilization target in percentage. Must be between 10 and 80.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxNodes": {
          "type": "integer",
          "description": "The maximum number of nodes for autoscaling.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "minNodes": {
          "type": "integer",
          "description": "The minimum number of nodes for autoscaling.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "cpuTarget",
        "maxNodes",
        "minNodes"
      ]
    },
    "gcp:bigtable/TableColumnFamily:TableColumnFamily": {
      "properties": {
        "family": {
          "type": "string",
          "description": "The name of the column family.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "family"
      ]
    },
    "gcp:binaryauthorization/AttestorAttestationAuthorityNote:AttestorAttestationAuthorityNote": {
      "properties": {
        "delegationServiceAccountEmail": {
          "type": "string",
          "description": "-\nThis field will contain the service account email address that\nthis Attestor will use as the principal when querying Container\nAnalysis. Attestor administrators must grant this service account\nthe IAM role needed to read attestations from the noteReference in\nContainer Analysis (containeranalysis.notes.occurrences.viewer).\nThis email address is fixed for the lifetime of the Attestor, but\ncallers should not make any other assumptions about the service\naccount email; future versions may use an email based on a\ndifferent naming pattern.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "noteReference": {
          "type": "string",
          "description": "The resource name of a ATTESTATION_AUTHORITY Note, created by the\nuser. If the Note is in a different project from the Attestor, it\nshould be specified in the format `projects/*/notes/*` (or the legacy\n`providers/*/notes/*`). This field may not be updated.\nAn attestation by this attestor is stored as a Container Analysis\nATTESTATION_AUTHORITY Occurrence that names a container image\nand that links to this Note.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publicKeys": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:binaryauthorization/AttestorAttestationAuthorityNotePublicKey:AttestorAttestationAuthorityNotePublicKey"
          },
          "description": "Public keys that verify attestations signed by this attestor. This\nfield may be updated.\nIf this field is non-empty, one of the specified public keys must\nverify that an attestation was signed by this attestor for the\nimage specified in the admission request.\nIf this field is empty, this attestor always returns that no valid\nattestations exist.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "noteReference"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "delegationServiceAccountEmail",
            "noteReference"
          ]
        }
      }
    },
    "gcp:binaryauthorization/AttestorAttestationAuthorityNotePublicKey:AttestorAttestationAuthorityNotePublicKey": {
      "properties": {
        "asciiArmoredPgpPublicKey": {
          "type": "string",
          "description": "ASCII-armored representation of a PGP public key, as the\nentire output by the command\n`gpg --export --armor foo@example.com` (either LF or CRLF\nline endings). When using this field, id should be left\nblank. The BinAuthz API handlers will calculate the ID\nand fill it in automatically. BinAuthz computes this ID\nas the OpenPGP RFC4880 V4 fingerprint, represented as\nupper-case hex. If id is provided by the caller, it will\nbe overwritten by the API-calculated ID.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "comment": {
          "type": "string",
          "description": "A descriptive comment. This field may be updated.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "id": {
          "type": "string",
          "description": "The ID of this public key. Signatures verified by BinAuthz\nmust include the ID of the public key that can be used to\nverify them, and that ID must match the contents of this\nfield exactly. Additional restrictions on this field can\nbe imposed based on which public key type is encapsulated.\nSee the documentation on publicKey cases below for details.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "pkixPublicKey": {
          "$ref": "#/types/gcp:binaryauthorization/AttestorAttestationAuthorityNotePublicKeyPkixPublicKey:AttestorAttestationAuthorityNotePublicKeyPkixPublicKey",
          "description": "A raw PKIX SubjectPublicKeyInfo format public key.\nNOTE: id may be explicitly provided by the caller when using this\ntype of public key, but it MUST be a valid RFC3986 URI. If id is left\nblank, a default one will be computed based on the digest of the DER\nencoding of the public key.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "id"
          ]
        }
      }
    },
    "gcp:binaryauthorization/AttestorAttestationAuthorityNotePublicKeyPkixPublicKey:AttestorAttestationAuthorityNotePublicKeyPkixPublicKey": {
      "properties": {
        "publicKeyPem": {
          "type": "string",
          "description": "A PEM-encoded public key, as described in\n`https://tools.ietf.org/html/rfc7468#section-13`\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "signatureAlgorithm": {
          "type": "string",
          "description": "The signature algorithm used to verify a message against\na signature using this key. These signature algorithm must\nmatch the structure and any object identifiers encoded in\npublicKeyPem (i.e. this algorithm must match that of the\npublic key).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:binaryauthorization/PolicyAdmissionWhitelistPattern:PolicyAdmissionWhitelistPattern": {
      "properties": {
        "namePattern": {
          "type": "string",
          "description": "An image name pattern to whitelist, in the form\n`registry/path/to/image`. This supports a trailing * as a\nwildcard, but this is allowed only in text after the registry/\npart.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "namePattern"
      ]
    },
    "gcp:binaryauthorization/PolicyClusterAdmissionRule:PolicyClusterAdmissionRule": {
      "properties": {
        "cluster": {
          "type": "string",
          "description": "The identifier for this object. Format specified above.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "enforcementMode": {
          "type": "string",
          "description": "The action when a pod creation is denied by the admission rule.\nPossible values are `ENFORCED_BLOCK_AND_AUDIT_LOG` and `DRYRUN_AUDIT_LOG_ONLY`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "evaluationMode": {
          "type": "string",
          "description": "How this admission rule will be evaluated.\nPossible values are `ALWAYS_ALLOW`, `REQUIRE_ATTESTATION`, and `ALWAYS_DENY`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "requireAttestationsBies": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The resource names of the attestors that must attest to a\ncontainer image. If the attestor is in a different project from the\npolicy, it should be specified in the format `projects/*/attestors/*`.\nEach attestor must exist before a policy can reference it. To add an\nattestor to a policy the principal issuing the policy change\nrequest must be able to read the attestor resource.\nNote: this field must be non-empty when the evaluation_mode field\nspecifies REQUIRE_ATTESTATION, otherwise it must be empty.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "cluster",
        "enforcementMode",
        "evaluationMode"
      ]
    },
    "gcp:binaryauthorization/PolicyDefaultAdmissionRule:PolicyDefaultAdmissionRule": {
      "properties": {
        "enforcementMode": {
          "type": "string",
          "description": "The action when a pod creation is denied by the admission rule.\nPossible values are `ENFORCED_BLOCK_AND_AUDIT_LOG` and `DRYRUN_AUDIT_LOG_ONLY`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "evaluationMode": {
          "type": "string",
          "description": "How this admission rule will be evaluated.\nPossible values are `ALWAYS_ALLOW`, `REQUIRE_ATTESTATION`, and `ALWAYS_DENY`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "requireAttestationsBies": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The resource names of the attestors that must attest to a\ncontainer image. If the attestor is in a different project from the\npolicy, it should be specified in the format `projects/*/attestors/*`.\nEach attestor must exist before a policy can reference it. To add an\nattestor to a policy the principal issuing the policy change\nrequest must be able to read the attestor resource.\nNote: this field must be non-empty when the evaluation_mode field\nspecifies REQUIRE_ATTESTATION, otherwise it must be empty.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "enforcementMode",
        "evaluationMode"
      ]
    },
    "gcp:certificatemanager/CertificateManaged:CertificateManaged": {
      "properties": {
        "authorizationAttemptInfos": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:certificatemanager/CertificateManagedAuthorizationAttemptInfo:CertificateManagedAuthorizationAttemptInfo"
          },
          "description": "-\nDetailed state of the latest authorization attempt for each domain\nspecified for this Managed Certificate.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "dnsAuthorizations": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "willReplaceOnChanges": true,
          "description": "Authorizations that will be used for performing domain authorization\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "domains": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "willReplaceOnChanges": true,
          "description": "The domains for which a managed SSL certificate will be generated.\nWildcard domains are only supported with DNS challenge resolution\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "provisioningIssues": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:certificatemanager/CertificateManagedProvisioningIssue:CertificateManagedProvisioningIssue"
          },
          "description": "-\nInformation about issues with provisioning this Managed Certificate.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "state": {
          "type": "string",
          "description": "-\nState of the domain for managed certificate issuance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "authorizationAttemptInfos",
            "provisioningIssues",
            "state"
          ]
        }
      }
    },
    "gcp:certificatemanager/CertificateManagedAuthorizationAttemptInfo:CertificateManagedAuthorizationAttemptInfo": {
      "properties": {
        "details": {
          "type": "string",
          "description": "-\nHuman readable explanation for reaching the state. Provided to help\naddress the configuration issues.\nNot guaranteed to be stable. For programmatic access use `failure_reason` field.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "domain": {
          "type": "string",
          "description": "-\nDomain name of the authorization attempt.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "failureReason": {
          "type": "string",
          "description": "-\nReason for failure of the authorization attempt for the domain.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "state": {
          "type": "string",
          "description": "-\nState of the domain for managed certificate issuance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "details",
            "domain",
            "failureReason",
            "state"
          ]
        }
      }
    },
    "gcp:certificatemanager/CertificateManagedProvisioningIssue:CertificateManagedProvisioningIssue": {
      "properties": {
        "details": {
          "type": "string",
          "description": "-\nHuman readable explanation for reaching the state. Provided to help\naddress the configuration issues.\nNot guaranteed to be stable. For programmatic access use `failure_reason` field.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "reason": {
          "type": "string",
          "description": "-\nReason for provisioning failures.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "details",
            "reason"
          ]
        }
      }
    },
    "gcp:certificatemanager/CertificateSelfManaged:CertificateSelfManaged": {
      "properties": {
        "certificatePem": {
          "type": "string",
          "description": "The certificate chain in PEM-encoded form.\nLeaf certificate comes first, followed by intermediate ones if any.\n**Note**: This property is sensitive and will not be displayed in the plan.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "privateKeyPem": {
          "type": "string",
          "description": "The private key of the leaf certificate in PEM-encoded form.\n**Note**: This property is sensitive and will not be displayed in the plan.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "certificatePem",
        "privateKeyPem"
      ]
    },
    "gcp:cloudasset/FolderFeedCondition:FolderFeedCondition": {
      "properties": {
        "description": {
          "type": "string",
          "description": "Description of the expression. This is a longer text which describes the expression,\ne.g. when hovered over it in a UI.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "expression": {
          "type": "string",
          "description": "Textual representation of an expression in Common Expression Language syntax.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "location": {
          "type": "string",
          "description": "String indicating the location of the expression for error reporting, e.g. a file\nname and a position in the file.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "title": {
          "type": "string",
          "description": "Title for the expression, i.e. a short string describing its purpose.\nThis can be used e.g. in UIs which allow to enter the expression.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "expression"
      ]
    },
    "gcp:cloudasset/FolderFeedFeedOutputConfig:FolderFeedFeedOutputConfig": {
      "properties": {
        "pubsubDestination": {
          "$ref": "#/types/gcp:cloudasset/FolderFeedFeedOutputConfigPubsubDestination:FolderFeedFeedOutputConfigPubsubDestination",
          "description": "Destination on Cloud Pubsub.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "pubsubDestination"
      ]
    },
    "gcp:cloudasset/FolderFeedFeedOutputConfigPubsubDestination:FolderFeedFeedOutputConfigPubsubDestination": {
      "properties": {
        "topic": {
          "type": "string",
          "description": "Destination on Cloud Pubsub topic.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "topic"
      ]
    },
    "gcp:cloudasset/OrganizationFeedCondition:OrganizationFeedCondition": {
      "properties": {
        "description": {
          "type": "string",
          "description": "Description of the expression. This is a longer text which describes the expression,\ne.g. when hovered over it in a UI.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "expression": {
          "type": "string",
          "description": "Textual representation of an expression in Common Expression Language syntax.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "location": {
          "type": "string",
          "description": "String indicating the location of the expression for error reporting, e.g. a file\nname and a position in the file.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "title": {
          "type": "string",
          "description": "Title for the expression, i.e. a short string describing its purpose.\nThis can be used e.g. in UIs which allow to enter the expression.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "expression"
      ]
    },
    "gcp:cloudasset/OrganizationFeedFeedOutputConfig:OrganizationFeedFeedOutputConfig": {
      "properties": {
        "pubsubDestination": {
          "$ref": "#/types/gcp:cloudasset/OrganizationFeedFeedOutputConfigPubsubDestination:OrganizationFeedFeedOutputConfigPubsubDestination",
          "description": "Destination on Cloud Pubsub.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "pubsubDestination"
      ]
    },
    "gcp:cloudasset/OrganizationFeedFeedOutputConfigPubsubDestination:OrganizationFeedFeedOutputConfigPubsubDestination": {
      "properties": {
        "topic": {
          "type": "string",
          "description": "Destination on Cloud Pubsub topic.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "topic"
      ]
    },
    "gcp:cloudasset/ProjectFeedCondition:ProjectFeedCondition": {
      "properties": {
        "description": {
          "type": "string",
          "description": "Description of the expression. This is a longer text which describes the expression,\ne.g. when hovered over it in a UI.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "expression": {
          "type": "string",
          "description": "Textual representation of an expression in Common Expression Language syntax.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "location": {
          "type": "string",
          "description": "String indicating the location of the expression for error reporting, e.g. a file\nname and a position in the file.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "title": {
          "type": "string",
          "description": "Title for the expression, i.e. a short string describing its purpose.\nThis can be used e.g. in UIs which allow to enter the expression.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "expression"
      ]
    },
    "gcp:cloudasset/ProjectFeedFeedOutputConfig:ProjectFeedFeedOutputConfig": {
      "properties": {
        "pubsubDestination": {
          "$ref": "#/types/gcp:cloudasset/ProjectFeedFeedOutputConfigPubsubDestination:ProjectFeedFeedOutputConfigPubsubDestination",
          "description": "Destination on Cloud Pubsub.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "pubsubDestination"
      ]
    },
    "gcp:cloudasset/ProjectFeedFeedOutputConfigPubsubDestination:ProjectFeedFeedOutputConfigPubsubDestination": {
      "properties": {
        "topic": {
          "type": "string",
          "description": "Destination on Cloud Pubsub topic.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "topic"
      ]
    },
    "gcp:clouddeploy/DeliveryPipelineSerialPipeline:DeliveryPipelineSerialPipeline": {
      "properties": {
        "stages": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:clouddeploy/DeliveryPipelineSerialPipelineStage:DeliveryPipelineSerialPipelineStage"
          },
          "description": "Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:clouddeploy/DeliveryPipelineSerialPipelineStage:DeliveryPipelineSerialPipelineStage": {
      "properties": {
        "profiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Skaffold profiles to use when rendering the manifest for this stage's `Target`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "targetId": {
          "type": "string",
          "description": "The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:clouddeploy/DeliveryPipelineCondition:DeliveryPipelineCondition": {
      "properties": {
        "pipelineReadyConditions": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:clouddeploy/DeliveryPipelineConditionPipelineReadyCondition:DeliveryPipelineConditionPipelineReadyCondition"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "targetsPresentConditions": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:clouddeploy/DeliveryPipelineConditionTargetsPresentCondition:DeliveryPipelineConditionTargetsPresentCondition"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "pipelineReadyConditions",
            "targetsPresentConditions"
          ]
        }
      }
    },
    "gcp:clouddeploy/DeliveryPipelineConditionPipelineReadyCondition:DeliveryPipelineConditionPipelineReadyCondition": {
      "properties": {
        "status": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "updateTime": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "status",
            "updateTime"
          ]
        }
      }
    },
    "gcp:clouddeploy/DeliveryPipelineConditionTargetsPresentCondition:DeliveryPipelineConditionTargetsPresentCondition": {
      "properties": {
        "missingTargets": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "status": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "updateTime": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "missingTargets",
            "status",
            "updateTime"
          ]
        }
      }
    },
    "gcp:clouddeploy/TargetAnthosCluster:TargetAnthosCluster": {
      "properties": {
        "membership": {
          "type": "string",
          "description": "Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:clouddeploy/TargetExecutionConfig:TargetExecutionConfig": {
      "properties": {
        "artifactStorage": {
          "type": "string",
          "description": "Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket (\"gs://my-bucket\") or a path within a bucket (\"gs://my-bucket/my-dir\"). If unspecified, a default bucket located in the same region will be used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "serviceAccount": {
          "type": "string",
          "description": "Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "usages": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Required. Usages when this configuration should be applied.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "workerPool": {
          "type": "string",
          "description": "Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "usages"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "artifactStorage",
            "serviceAccount",
            "usages"
          ]
        }
      }
    },
    "gcp:clouddeploy/TargetGke:TargetGke": {
      "properties": {
        "cluster": {
          "type": "string",
          "description": "Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "internalIp": {
          "type": "boolean",
          "description": "Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:cloudidentity/GroupMembershipMemberKey:GroupMembershipMemberKey": {
      "properties": {
        "id": {
          "type": "string",
          "description": "The ID of the entity.\nFor Google-managed entities, the id must be the email address of an existing\ngroup or user.\nFor external-identity-mapped entities, the id must be a string conforming\nto the Identity Source's requirements.\nMust be unique within a namespace.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "namespace": {
          "type": "string",
          "description": "The namespace in which the entity exists.\nIf not specified, the EntityKey represents a Google-managed entity\nsuch as a Google user or a Google Group.\nIf specified, the EntityKey represents an external-identity-mapped group.\nThe namespace must correspond to an identity source created in Admin Console\nand must be in the form of `identitysources/{identity_source_id}`.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "id"
      ]
    },
    "gcp:cloudidentity/GroupMembershipPreferredMemberKey:GroupMembershipPreferredMemberKey": {
      "properties": {
        "id": {
          "type": "string",
          "description": "The ID of the entity.\nFor Google-managed entities, the id must be the email address of an existing\ngroup or user.\nFor external-identity-mapped entities, the id must be a string conforming\nto the Identity Source's requirements.\nMust be unique within a namespace.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "namespace": {
          "type": "string",
          "description": "The namespace in which the entity exists.\nIf not specified, the EntityKey represents a Google-managed entity\nsuch as a Google user or a Google Group.\nIf specified, the EntityKey represents an external-identity-mapped group.\nThe namespace must correspond to an identity source created in Admin Console\nand must be in the form of `identitysources/{identity_source_id}`.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "id"
      ]
    },
    "gcp:cloudidentity/GroupMembershipRole:GroupMembershipRole": {
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the MembershipRole. Must be one of OWNER, MANAGER, MEMBER.\nPossible values are `OWNER`, `MANAGER`, and `MEMBER`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "name"
      ]
    },
    "gcp:compute/BackendBucketCdnPolicy:BackendBucketCdnPolicy": {
      "properties": {
        "bypassCacheOnRequestHeaders": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/BackendBucketCdnPolicyBypassCacheOnRequestHeader:BackendBucketCdnPolicyBypassCacheOnRequestHeader"
          },
          "description": "Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified. The cache is bypassed for all cdnPolicy.cacheMode settings.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cacheKeyPolicy": {
          "$ref": "#/types/gcp:compute/BackendBucketCdnPolicyCacheKeyPolicy:BackendBucketCdnPolicyCacheKeyPolicy",
          "description": "The CacheKeyPolicy for this CdnPolicy.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "cacheMode": {
          "type": "string",
          "description": "Specifies the cache setting for all responses from this backend.\nThe possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC\nPossible values are `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, and `CACHE_ALL_STATIC`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "clientTtl": {
          "type": "integer",
          "description": "Specifies the maximum allowed TTL for cached content served by this origin.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "defaultTtl": {
          "type": "integer",
          "description": "Specifies the default TTL for cached content served by this origin for responses\nthat do not have an existing valid TTL (max-age or s-max-age).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxTtl": {
          "type": "integer",
          "description": "Specifies the maximum allowed TTL for cached content served by this origin.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "negativeCaching": {
          "type": "boolean",
          "description": "Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "negativeCachingPolicies": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/BackendBucketCdnPolicyNegativeCachingPolicy:BackendBucketCdnPolicyNegativeCachingPolicy"
          },
          "description": "Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.\nOmitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "requestCoalescing": {
          "type": "boolean",
          "description": "If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests to the origin.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "serveWhileStale": {
          "type": "integer",
          "description": "Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "signedUrlCacheMaxAgeSec": {
          "type": "integer",
          "description": "Maximum number of seconds the response to a signed URL request will\nbe considered fresh. After this time period,\nthe response will be revalidated before being served.\nWhen serving responses to signed URL requests,\nCloud CDN will internally behave as though\nall responses from this backend had a \"Cache-Control: public,\nmax-age=[TTL]\" header, regardless of any existing Cache-Control\nheader. The actual headers served in responses will not be altered.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "cacheMode",
            "clientTtl",
            "defaultTtl",
            "maxTtl",
            "negativeCaching",
            "serveWhileStale"
          ]
        }
      }
    },
    "gcp:compute/BackendBucketCdnPolicyBypassCacheOnRequestHeader:BackendBucketCdnPolicyBypassCacheOnRequestHeader": {
      "properties": {
        "headerName": {
          "type": "string",
          "description": "The header field name to match on when bypassing cache. Values are case-insensitive.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:compute/BackendBucketCdnPolicyCacheKeyPolicy:BackendBucketCdnPolicyCacheKeyPolicy": {
      "properties": {
        "includeHttpHeaders": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Allows HTTP request headers (by name) to be used in the\ncache key.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "queryStringWhitelists": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Names of query string parameters to include in cache keys.\nDefault parameters are always included. '&' and '=' will\nbe percent encoded and not treated as delimiters.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:compute/BackendBucketCdnPolicyNegativeCachingPolicy:BackendBucketCdnPolicyNegativeCachingPolicy": {
      "properties": {
        "code": {
          "type": "integer",
          "description": "The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501\ncan be specified as values, and you cannot specify a status code more than once.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ttl": {
          "type": "integer",
          "description": "The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s\n(30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:compute/ExternalVpnGatewayInterface:ExternalVpnGatewayInterface": {
      "properties": {
        "id": {
          "type": "integer",
          "description": "The numeric ID for this interface. Allowed values are based on the redundancy type\nof this external VPN gateway\n* `0 - SINGLE_IP_INTERNALLY_REDUNDANT`\n* `0, 1 - TWO_IPS_REDUNDANCY`\n* `0, 1, 2, 3 - FOUR_IPS_REDUNDANCY`\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipAddress": {
          "type": "string",
          "description": "IP address of the interface in the external VPN gateway.\nOnly IPv4 is supported. This IP address can be either from\nyour on-premise gateway or another Cloud provider's VPN gateway,\nit cannot be an IP address from Google Compute Engine.\n",
          "willReplaceOnChanges": true,
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      }
    },
    "gcp:organizations/getIAMPolicyAuditConfig:getIAMPolicyAuditConfig": {
      "properties": {
        "auditLogConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:organizations/getIAMPolicyAuditConfigAuditLogConfig:getIAMPolicyAuditConfigAuditLogConfig"
          },
          "description": "A nested block that defines the operations you'd like to log.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "service": {
          "type": "string",
          "description": "Defines a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "auditLogConfigs",
        "service"
      ]
    },
    "gcp:organizations/getIAMPolicyAuditConfigAuditLogConfig:getIAMPolicyAuditConfigAuditLogConfig": {
      "properties": {
        "exemptedMembers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Specifies the identities that are exempt from these types of logging operations. Follows the same format of the `members` array for `binding`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "logType": {
          "type": "string",
          "description": "Defines the logging level. `DATA_READ`, `DATA_WRITE` and `ADMIN_READ` capture different types of events. See [the audit configuration documentation](https://cloud.google.com/resource-manager/reference/rest/Shared.Types/AuditConfig) for more details.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "logType"
      ]
    },
    "gcp:organizations/getIAMPolicyBinding:getIAMPolicyBinding": {
      "properties": {
        "condition": {
          "$ref": "#/types/gcp:organizations/getIAMPolicyBindingCondition:getIAMPolicyBindingCondition",
          "description": "An [IAM Condition](https://cloud.google.com/iam/docs/conditions-overview) for a given binding. Structure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "members": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "An array of identities that will be granted the privilege in the `role`. For more details on format and restrictions see https://cloud.google.com/billing/reference/rest/v1/Policy#Binding\nEach entry can have one of the following values:\n* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account. Some resources **don't** support this identity.\n* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account. Some resources **don't** support this identity.\n* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com.\n* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.\n* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.\n* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "role": {
          "type": "string",
          "description": "The role/permission that will be granted to the members.\nSee the [IAM Roles](https://cloud.google.com/compute/docs/access/iam) documentation for a complete list of roles.\nNote that custom roles must be of the format `[projects|organizations]/{parent-name}/roles/{role-name}`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "members",
        "role"
      ]
    },
    "gcp:organizations/getIAMPolicyBindingCondition:getIAMPolicyBindingCondition": {
      "properties": {
        "description": {
          "type": "string",
          "description": "An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "expression": {
          "type": "string",
          "description": "Textual representation of an expression in Common Expression Language syntax.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "title": {
          "type": "string",
          "description": "A title for the expression, i.e. a short string describing its purpose.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "required": [
        "expression",
        "title"
      ]
    },
    "gcp:compute/InstanceAdvancedMachineFeatures:InstanceAdvancedMachineFeatures": {
      "properties": {
        "enableNestedVirtualization": {
          "type": "boolean",
          "description": "Defines whether the instance should have nested virtualization  enabled. Defaults to false.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "threadsPerCore": {
          "type": "integer",
          "description": "he number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "visibleCoreCount": {
          "type": "integer",
          "description": ") The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "gcp:compute/InstanceAttachedDisk:InstanceAttachedDisk": {
      "properties": {
        "deviceName": {
          "type": "string",
          "description": "Name with which the attached disk will be accessible\nunder `/dev/disk/by-id/google-*`\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "diskEncryptionKeyRaw": {
          "type": "string",
          "description": "A 256-bit [customer-supplied encryption key]\n(\u003chttps://cloud.google.com/compute/docs/disks/customer-supplied-encryption\u003e),\nencoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)\nto encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "diskEncryptionKeySha256": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "kmsKeySelfLink": {
          "type": "string",
          "description": "The self_link of the encryption key that is\nstored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`\nand `disk_encryption_key_raw` may be set.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "mode": {
          "type": "string",
          "description": "Either \"READ_ONLY\" or \"READ_WRITE\", defaults to \"READ_WRITE\"\nIf you have a persistent disk with data that you want to share\nbetween multiple instances, detach it from any read-write instances and\nattach it to one or more instances in read-only mode.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "source": {
          "type": "string",
          "description": "The name or self_link of the disk to attach to this instance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "source"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "deviceName",
            "diskEncryptionKeySha256",
            "kmsKeySelfLink",
            "source"
          ]
        }
      }
    },
    "gcp:compute/InstanceBootDisk:InstanceBootDisk": {
      "properties": {
        "autoDelete": {
          "type": "boolean",
          "description": "Whether the disk will be auto-deleted when the instance\nis deleted. Defaults to true.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "deviceName": {
          "type": "string",
          "description": "Name with which the attached disk will be accessible\nunder `/dev/disk/by-id/google-*`\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "diskEncryptionKeyRaw": {
          "type": "string",
          "description": "A 256-bit [customer-supplied encryption key]\n(\u003chttps://cloud.google.com/compute/docs/disks/customer-supplied-encryption\u003e),\nencoded in [RFC 4648 base64](https://tools.ietf.org/html/rfc4648#section-4)\nto encrypt this disk. Only one of `kms_key_self_link` and `disk_encryption_key_raw` may be set.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "diskEncryptionKeySha256": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "initializeParams": {
          "$ref": "#/types/gcp:compute/InstanceBootDiskInitializeParams:InstanceBootDiskInitializeParams",
          "description": "Parameters for a new disk that will be created\nalongside the new instance. Either `initialize_params` or `source` must be set.\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "kmsKeySelfLink": {
          "type": "string",
          "description": "The self_link of the encryption key that is\nstored in Google Cloud KMS to encrypt this disk. Only one of `kms_key_self_link`\nand `disk_encryption_key_raw` may be set.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "mode": {
          "type": "string",
          "description": "Either \"READ_ONLY\" or \"READ_WRITE\", defaults to \"READ_WRITE\"\nIf you have a persistent disk with data that you want to share\nbetween multiple instances, detach it from any read-write instances and\nattach it to one or more instances in read-only mode.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "source": {
          "type": "string",
          "description": "The name or self_link of the disk to attach to this instance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "deviceName",
            "diskEncryptionKeySha256",
            "initializeParams",
            "kmsKeySelfLink",
            "source"
          ]
        }
      }
    },
    "gcp:compute/InstanceBootDiskInitializeParams:InstanceBootDiskInitializeParams": {
      "properties": {
        "image": {
          "type": "string",
          "description": "The image from which to initialize this disk. This can be\none of: the image's `self_link`, `projects/{project}/global/images/{image}`,\n`projects/{project}/global/images/family/{family}`, `global/images/{image}`,\n`global/images/family/{family}`, `family/{family}`, `{project}/{family}`,\n`{project}/{image}`, `{family}`, or `{image}`. If referred by family, the\nimages names must include the family name. If they don't, use the\n[gcp.compute.Image data source](https://www.terraform.io/docs/providers/google/d/compute_image.html).\nFor instance, the image `centos-6-v20180104` includes its family name `centos-6`.\nThese images can be referred by family name here.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "description": "A map of key/value label pairs to assign to the instance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "size": {
          "type": "integer",
          "description": "The size of the image in gigabytes. If not specified, it\nwill inherit the size of its base image.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "description": "The type of reservation from which this instance can consume resources.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "image",
            "labels",
            "size",
            "type"
          ]
        }
      }
    },
    "gcp:compute/InstanceConfidentialInstanceConfig:InstanceConfidentialInstanceConfig": {
      "properties": {
        "enableConfidentialCompute": {
          "type": "boolean",
          "description": "Defines whether the instance should have confidential compute enabled. `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "enableConfidentialCompute"
      ]
    },
    "gcp:compute/InstanceFromMachineImageAdvancedMachineFeatures:InstanceFromMachineImageAdvancedMachineFeatures": {
      "properties": {
        "enableNestedVirtualization": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "threadsPerCore": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "visibleCoreCount": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "enableNestedVirtualization",
            "threadsPerCore",
            "visibleCoreCount"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageAttachedDisk:InstanceFromMachineImageAttachedDisk": {
      "properties": {
        "deviceName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "diskEncryptionKeyRaw": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "diskEncryptionKeySha256": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "kmsKeySelfLink": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "mode": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "source": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "source"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "deviceName",
            "diskEncryptionKeyRaw",
            "diskEncryptionKeySha256",
            "kmsKeySelfLink",
            "mode",
            "source"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageBootDisk:InstanceFromMachineImageBootDisk": {
      "properties": {
        "autoDelete": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "deviceName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "diskEncryptionKeyRaw": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "diskEncryptionKeySha256": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "initializeParams": {
          "$ref": "#/types/gcp:compute/InstanceFromMachineImageBootDiskInitializeParams:InstanceFromMachineImageBootDiskInitializeParams",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "kmsKeySelfLink": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "mode": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "source": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "autoDelete",
            "deviceName",
            "diskEncryptionKeyRaw",
            "diskEncryptionKeySha256",
            "initializeParams",
            "kmsKeySelfLink",
            "mode",
            "source"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageBootDiskInitializeParams:InstanceFromMachineImageBootDiskInitializeParams": {
      "properties": {
        "image": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "size": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "image",
            "labels",
            "size",
            "type"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageConfidentialInstanceConfig:InstanceFromMachineImageConfidentialInstanceConfig": {
      "properties": {
        "enableConfidentialCompute": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "enableConfidentialCompute"
      ]
    },
    "gcp:compute/InstanceFromMachineImageGuestAccelerator:InstanceFromMachineImageGuestAccelerator": {
      "properties": {
        "count": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "count",
        "type"
      ]
    },
    "gcp:compute/InstanceFromMachineImageNetworkInterface:InstanceFromMachineImageNetworkInterface": {
      "properties": {
        "accessConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceFromMachineImageNetworkInterfaceAccessConfig:InstanceFromMachineImageNetworkInterfaceAccessConfig"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "aliasIpRanges": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceFromMachineImageNetworkInterfaceAliasIpRange:InstanceFromMachineImageNetworkInterfaceAliasIpRange"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6AccessConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig:InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6AccessType": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "description": "A unique name for the resource, required by GCE.\nChanging this forces a new resource to be created.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "network": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkIp": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nicType": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "queueCount": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "stackType": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnetwork": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnetworkProject": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "accessConfigs",
            "aliasIpRanges",
            "ipv6AccessConfigs",
            "ipv6AccessType",
            "name",
            "network",
            "networkIp",
            "nicType",
            "queueCount",
            "stackType",
            "subnetwork",
            "subnetworkProject"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageNetworkInterfaceAccessConfig:InstanceFromMachineImageNetworkInterfaceAccessConfig": {
      "properties": {
        "natIp": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkTier": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publicPtrDomainName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "natIp",
            "networkTier",
            "publicPtrDomainName"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageNetworkInterfaceAliasIpRange:InstanceFromMachineImageNetworkInterfaceAliasIpRange": {
      "properties": {
        "ipCidrRange": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnetworkRangeName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "ipCidrRange"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "ipCidrRange",
            "subnetworkRangeName"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig:InstanceFromMachineImageNetworkInterfaceIpv6AccessConfig": {
      "properties": {
        "externalIpv6": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "externalIpv6PrefixLength": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkTier": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publicPtrDomainName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "networkTier"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "externalIpv6",
            "externalIpv6PrefixLength",
            "networkTier",
            "publicPtrDomainName"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageNetworkPerformanceConfig:InstanceFromMachineImageNetworkPerformanceConfig": {
      "properties": {
        "totalEgressBandwidthTier": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "totalEgressBandwidthTier"
      ]
    },
    "gcp:compute/InstanceFromMachineImageReservationAffinity:InstanceFromMachineImageReservationAffinity": {
      "properties": {
        "specificReservation": {
          "$ref": "#/types/gcp:compute/InstanceFromMachineImageReservationAffinitySpecificReservation:InstanceFromMachineImageReservationAffinitySpecificReservation",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "type"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "specificReservation",
            "type"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageReservationAffinitySpecificReservation:InstanceFromMachineImageReservationAffinitySpecificReservation": {
      "properties": {
        "key": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "key",
        "values"
      ]
    },
    "gcp:compute/InstanceFromMachineImageScheduling:InstanceFromMachineImageScheduling": {
      "properties": {
        "automaticRestart": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "instanceTerminationAction": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "minNodeCpus": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nodeAffinities": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceFromMachineImageSchedulingNodeAffinity:InstanceFromMachineImageSchedulingNodeAffinity"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "onHostMaintenance": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "preemptible": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "provisioningModel": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "automaticRestart",
            "instanceTerminationAction",
            "minNodeCpus",
            "nodeAffinities",
            "onHostMaintenance",
            "preemptible",
            "provisioningModel"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageSchedulingNodeAffinity:InstanceFromMachineImageSchedulingNodeAffinity": {
      "properties": {
        "key": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "operator": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "key",
        "operator",
        "values"
      ]
    },
    "gcp:compute/InstanceFromMachineImageScratchDisk:InstanceFromMachineImageScratchDisk": {
      "properties": {
        "interface": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "interface"
      ]
    },
    "gcp:compute/InstanceFromMachineImageServiceAccount:InstanceFromMachineImageServiceAccount": {
      "properties": {
        "email": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "scopes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "scopes"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "email",
            "scopes"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromMachineImageShieldedInstanceConfig:InstanceFromMachineImageShieldedInstanceConfig": {
      "properties": {
        "enableIntegrityMonitoring": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "enableSecureBoot": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "enableVtpm": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "enableIntegrityMonitoring",
            "enableSecureBoot",
            "enableVtpm"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateAdvancedMachineFeatures:InstanceFromTemplateAdvancedMachineFeatures": {
      "properties": {
        "enableNestedVirtualization": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "threadsPerCore": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "visibleCoreCount": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "enableNestedVirtualization",
            "threadsPerCore",
            "visibleCoreCount"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateAttachedDisk:InstanceFromTemplateAttachedDisk": {
      "properties": {
        "deviceName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "diskEncryptionKeyRaw": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "diskEncryptionKeySha256": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "kmsKeySelfLink": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "mode": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "source": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "source"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "deviceName",
            "diskEncryptionKeyRaw",
            "diskEncryptionKeySha256",
            "kmsKeySelfLink",
            "mode",
            "source"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateBootDisk:InstanceFromTemplateBootDisk": {
      "properties": {
        "autoDelete": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "deviceName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "diskEncryptionKeyRaw": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "diskEncryptionKeySha256": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "initializeParams": {
          "$ref": "#/types/gcp:compute/InstanceFromTemplateBootDiskInitializeParams:InstanceFromTemplateBootDiskInitializeParams",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "kmsKeySelfLink": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "mode": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "source": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "autoDelete",
            "deviceName",
            "diskEncryptionKeyRaw",
            "diskEncryptionKeySha256",
            "initializeParams",
            "kmsKeySelfLink",
            "mode",
            "source"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateBootDiskInitializeParams:InstanceFromTemplateBootDiskInitializeParams": {
      "properties": {
        "image": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "$ref": "pulumi.json#/Any"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "size": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "image",
            "labels",
            "size",
            "type"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateConfidentialInstanceConfig:InstanceFromTemplateConfidentialInstanceConfig": {
      "properties": {
        "enableConfidentialCompute": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "enableConfidentialCompute"
      ]
    },
    "gcp:compute/InstanceFromTemplateGuestAccelerator:InstanceFromTemplateGuestAccelerator": {
      "properties": {
        "count": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "count",
        "type"
      ]
    },
    "gcp:compute/InstanceFromTemplateNetworkInterface:InstanceFromTemplateNetworkInterface": {
      "properties": {
        "accessConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceFromTemplateNetworkInterfaceAccessConfig:InstanceFromTemplateNetworkInterfaceAccessConfig"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "aliasIpRanges": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceFromTemplateNetworkInterfaceAliasIpRange:InstanceFromTemplateNetworkInterfaceAliasIpRange"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6AccessConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceFromTemplateNetworkInterfaceIpv6AccessConfig:InstanceFromTemplateNetworkInterfaceIpv6AccessConfig"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6AccessType": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "description": "A unique name for the resource, required by GCE.\nChanging this forces a new resource to be created.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "network": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkIp": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nicType": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "queueCount": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "stackType": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnetwork": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnetworkProject": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "accessConfigs",
            "aliasIpRanges",
            "ipv6AccessConfigs",
            "ipv6AccessType",
            "name",
            "network",
            "networkIp",
            "nicType",
            "queueCount",
            "stackType",
            "subnetwork",
            "subnetworkProject"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateNetworkInterfaceAccessConfig:InstanceFromTemplateNetworkInterfaceAccessConfig": {
      "properties": {
        "natIp": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkTier": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publicPtrDomainName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "natIp",
            "networkTier",
            "publicPtrDomainName"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateNetworkInterfaceAliasIpRange:InstanceFromTemplateNetworkInterfaceAliasIpRange": {
      "properties": {
        "ipCidrRange": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnetworkRangeName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "ipCidrRange"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "ipCidrRange",
            "subnetworkRangeName"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateNetworkInterfaceIpv6AccessConfig:InstanceFromTemplateNetworkInterfaceIpv6AccessConfig": {
      "properties": {
        "externalIpv6": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "externalIpv6PrefixLength": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkTier": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publicPtrDomainName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "networkTier"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "externalIpv6",
            "externalIpv6PrefixLength",
            "networkTier",
            "publicPtrDomainName"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateNetworkPerformanceConfig:InstanceFromTemplateNetworkPerformanceConfig": {
      "properties": {
        "totalEgressBandwidthTier": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "totalEgressBandwidthTier"
      ]
    },
    "gcp:compute/InstanceFromTemplateReservationAffinity:InstanceFromTemplateReservationAffinity": {
      "properties": {
        "specificReservation": {
          "$ref": "#/types/gcp:compute/InstanceFromTemplateReservationAffinitySpecificReservation:InstanceFromTemplateReservationAffinitySpecificReservation",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "type"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "specificReservation",
            "type"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateReservationAffinitySpecificReservation:InstanceFromTemplateReservationAffinitySpecificReservation": {
      "properties": {
        "key": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "key",
        "values"
      ]
    },
    "gcp:compute/InstanceFromTemplateScheduling:InstanceFromTemplateScheduling": {
      "properties": {
        "automaticRestart": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "instanceTerminationAction": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "minNodeCpus": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nodeAffinities": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceFromTemplateSchedulingNodeAffinity:InstanceFromTemplateSchedulingNodeAffinity"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "onHostMaintenance": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "preemptible": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "provisioningModel": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "automaticRestart",
            "instanceTerminationAction",
            "minNodeCpus",
            "nodeAffinities",
            "onHostMaintenance",
            "preemptible",
            "provisioningModel"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateSchedulingNodeAffinity:InstanceFromTemplateSchedulingNodeAffinity": {
      "properties": {
        "key": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "operator": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "key",
        "operator",
        "values"
      ]
    },
    "gcp:compute/InstanceFromTemplateScratchDisk:InstanceFromTemplateScratchDisk": {
      "properties": {
        "interface": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "interface"
      ]
    },
    "gcp:compute/InstanceFromTemplateServiceAccount:InstanceFromTemplateServiceAccount": {
      "properties": {
        "email": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "scopes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "scopes"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "email",
            "scopes"
          ]
        }
      }
    },
    "gcp:compute/InstanceFromTemplateShieldedInstanceConfig:InstanceFromTemplateShieldedInstanceConfig": {
      "properties": {
        "enableIntegrityMonitoring": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "enableSecureBoot": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "enableVtpm": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "enableIntegrityMonitoring",
            "enableSecureBoot",
            "enableVtpm"
          ]
        }
      }
    },
    "gcp:compute/InstanceGroupManagerAllInstancesConfig:InstanceGroupManagerAllInstancesConfig": {
      "properties": {
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "), The label key-value pairs that you want to patch onto the instance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "), The metadata key-value pairs that you want to patch onto the instance. For more information, see [Project and instance metadata](https://cloud.google.com/compute/docs/metadata#project_and_instance_metadata).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "gcp:compute/InstanceGroupManagerAutoHealingPolicies:InstanceGroupManagerAutoHealingPolicies": {
      "properties": {
        "healthCheck": {
          "type": "string",
          "description": "The health check resource that signals autohealing.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "initialDelaySec": {
          "type": "integer",
          "description": "The number of seconds that the managed instance group waits before\nit applies autohealing policies to new instances or recently recreated instances. Between 0 and 3600.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "healthCheck",
        "initialDelaySec"
      ]
    },
    "gcp:compute/InstanceGroupManagerNamedPort:InstanceGroupManagerNamedPort": {
      "properties": {
        "name": {
          "type": "string",
          "description": "- Version name.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "port": {
          "type": "integer",
          "description": "The port number.\n- - -\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "name",
        "port"
      ]
    },
    "gcp:compute/InstanceGroupManagerStatefulDisk:InstanceGroupManagerStatefulDisk": {
      "properties": {
        "deleteRule": {
          "type": "string",
          "description": ", A value that prescribes what should happen to the stateful disk when the VM instance is deleted. The available options are `NEVER` and `ON_PERMANENT_INSTANCE_DELETION`. `NEVER` - detach the disk when the VM is deleted, but do not delete the disk. `ON_PERMANENT_INSTANCE_DELETION` will delete the stateful disk when the VM is permanently deleted from the instance group. The default is `NEVER`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "deviceName": {
          "type": "string",
          "description": ", The device name of the disk to be attached.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "deviceName"
      ]
    },
    "gcp:compute/InstanceGroupManagerStatus:InstanceGroupManagerStatus": {
      "properties": {
        "allInstancesConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceGroupManagerStatusAllInstancesConfig:InstanceGroupManagerStatusAllInstancesConfig"
          },
          "description": ")\nProperties to set on all instances in the group. After setting\nallInstancesConfig on the group, you must update the group's instances to\napply the configuration.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "isStable": {
          "type": "boolean",
          "description": "A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "statefuls": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceGroupManagerStatusStateful:InstanceGroupManagerStatusStateful"
          },
          "description": "Stateful status of the given Instance Group Manager.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "versionTargets": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceGroupManagerStatusVersionTarget:InstanceGroupManagerStatusVersionTarget"
          },
          "description": "A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "allInstancesConfigs",
            "isStable",
            "statefuls",
            "versionTargets"
          ]
        }
      }
    },
    "gcp:compute/InstanceGroupManagerStatusAllInstancesConfig:InstanceGroupManagerStatusAllInstancesConfig": {
      "properties": {
        "effective": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "effective"
          ]
        }
      }
    },
    "gcp:compute/InstanceGroupManagerStatusStateful:InstanceGroupManagerStatusStateful": {
      "properties": {
        "hasStatefulConfig": {
          "type": "boolean",
          "description": "A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful config even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "perInstanceConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceGroupManagerStatusStatefulPerInstanceConfig:InstanceGroupManagerStatusStatefulPerInstanceConfig"
          },
          "description": "Status of per-instance configs on the instance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "hasStatefulConfig",
            "perInstanceConfigs"
          ]
        }
      }
    },
    "gcp:compute/InstanceGroupManagerStatusStatefulPerInstanceConfig:InstanceGroupManagerStatusStatefulPerInstanceConfig": {
      "properties": {
        "allEffective": {
          "type": "boolean",
          "description": "A bit indicating if all of the group's per-instance configs (listed in the output of a listPerInstanceConfigs API call) have status `EFFECTIVE` or there are no per-instance-configs.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "allEffective"
          ]
        }
      }
    },
    "gcp:compute/InstanceGroupManagerStatusVersionTarget:InstanceGroupManagerStatusVersionTarget": {
      "properties": {
        "isReached": {
          "type": "boolean",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "isReached"
          ]
        }
      }
    },
    "gcp:compute/InstanceGroupManagerUpdatePolicy:InstanceGroupManagerUpdatePolicy": {
      "properties": {
        "maxSurgeFixed": {
          "type": "integer",
          "description": ", The maximum number of instances that can be created above the specified targetSize during the update process. Conflicts with `max_surge_percent`. If neither is set, defaults to 1\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxSurgePercent": {
          "type": "integer",
          "description": ", The maximum number of instances(calculated as percentage) that can be created above the specified targetSize during the update process. Conflicts with `max_surge_fixed`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxUnavailableFixed": {
          "type": "integer",
          "description": ", The maximum number of instances that can be unavailable during the update process. Conflicts with `max_unavailable_percent`. If neither is set, defaults to 1\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "maxUnavailablePercent": {
          "type": "integer",
          "description": ", The maximum number of instances(calculated as percentage) that can be unavailable during the update process. Conflicts with `max_unavailable_fixed`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "minReadySec": {
          "type": "integer",
          "description": "), Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600]\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "minimalAction": {
          "type": "string",
          "description": "- Minimal action to be taken on an instance. You can specify either `REFRESH` to update without stopping instances, `RESTART` to restart existing instances or `REPLACE` to delete and create new instances from the target template. If you specify a `REFRESH`, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "mostDisruptiveAllowedAction": {
          "type": "string",
          "description": "- Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "replacementMethod": {
          "type": "string",
          "description": ", The instance replacement method for managed instance groups. Valid values are: \"RECREATE\", \"SUBSTITUTE\". If SUBSTITUTE (default), the group replaces VM instances with new instances that have randomly generated names. If RECREATE, instance names are preserved.  You must also set max_unavailable_fixed or max_unavailable_percent to be greater than 0.\n- - -\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "type": {
          "type": "string",
          "description": "- The type of update process. You can specify either `PROACTIVE` so that the instance group manager proactively executes actions in order to bring instances to their target versions or `OPPORTUNISTIC` so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "minimalAction",
        "type"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "maxSurgeFixed",
            "maxUnavailableFixed",
            "minimalAction",
            "type"
          ]
        }
      }
    },
    "gcp:compute/InstanceGroupManagerVersion:InstanceGroupManagerVersion": {
      "properties": {
        "instanceTemplate": {
          "type": "string",
          "description": "- The full URL to an instance template from which all new instances of this version will be created.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "description": "- Version name.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "targetSize": {
          "$ref": "#/types/gcp:compute/InstanceGroupManagerVersionTargetSize:InstanceGroupManagerVersionTargetSize",
          "description": "- The number of instances calculated as a fixed number or a percentage depending on the settings. Structure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "instanceTemplate"
      ]
    },
    "gcp:compute/InstanceGroupManagerVersionTargetSize:InstanceGroupManagerVersionTargetSize": {
      "properties": {
        "fixed": {
          "type": "integer",
          "description": ", The number of instances which are managed for this version. Conflicts with `percent`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "percent": {
          "type": "integer",
          "description": ", The number of instances (calculated as percentage) which are managed for this version. Conflicts with `fixed`.\nNote that when using `percent`, rounding will be in favor of explicitly set `target_size` values; a managed instance group with 2 instances and 2 `version`s,\none of which has a `target_size.percent` of `60` will create 2 instances of that `version`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "gcp:compute/InstanceGroupNamedPort:InstanceGroupNamedPort": {
      "properties": {
        "name": {
          "type": "string",
          "description": "The name which the port will be mapped to.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "port": {
          "type": "integer",
          "description": "The port number to map the name to.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "name",
        "port"
      ]
    },
    "gcp:compute/InstanceGuestAccelerator:InstanceGuestAccelerator": {
      "properties": {
        "count": {
          "type": "integer",
          "description": "The number of the guest accelerator cards exposed to this instance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "description": "The type of reservation from which this instance can consume resources.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "count",
        "type"
      ]
    },
    "gcp:compute/InstanceIAMBindingCondition:InstanceIAMBindingCondition": {
      "properties": {
        "description": {
          "type": "string",
          "description": "An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "expression": {
          "type": "string",
          "description": "Textual representation of an expression in Common Expression Language syntax.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "title": {
          "type": "string",
          "description": "A title for the expression, i.e. a short string describing its purpose.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "expression",
        "title"
      ]
    },
    "gcp:compute/InstanceIAMMemberCondition:InstanceIAMMemberCondition": {
      "properties": {
        "description": {
          "type": "string",
          "description": "An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "expression": {
          "type": "string",
          "description": "Textual representation of an expression in Common Expression Language syntax.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "title": {
          "type": "string",
          "description": "A title for the expression, i.e. a short string describing its purpose.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "expression",
        "title"
      ]
    },
    "gcp:compute/InstanceNetworkInterface:InstanceNetworkInterface": {
      "properties": {
        "accessConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceNetworkInterfaceAccessConfig:InstanceNetworkInterfaceAccessConfig"
          },
          "description": "Access configurations, i.e. IPs via which this\ninstance can be accessed via the Internet. Omit to ensure that the instance\nis not accessible from the Internet. If omitted, ssh will not\nwork unless this provider can send traffic to the instance's network (e.g. via\ntunnel or because it is running on another cloud instance on that network).\nThis block can be repeated multiple times. Structure documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "aliasIpRanges": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceNetworkInterfaceAliasIpRange:InstanceNetworkInterfaceAliasIpRange"
          },
          "description": "An\narray of alias IP ranges for this network interface. Can only be specified for network\ninterfaces on subnet-mode networks. Structure documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6AccessConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceNetworkInterfaceIpv6AccessConfig:InstanceNetworkInterfaceIpv6AccessConfig"
          },
          "description": "An array of IPv6 access configurations for this interface.\nCurrently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig\nspecified, then this instance will have no external IPv6 Internet access. Structure documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6AccessType": {
          "type": "string",
          "description": "One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet.\nThis field is always inherited from its subnetwork.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "description": "A unique name for the resource, required by GCE.\nChanging this forces a new resource to be created.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "network": {
          "type": "string",
          "description": "The name or self_link of the network to attach this interface to.\nEither `network` or `subnetwork` must be provided. If network isn't provided it will\nbe inferred from the subnetwork.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkIp": {
          "type": "string",
          "description": "The private IP address to assign to the instance. If\nempty, the address will be automatically assigned.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nicType": {
          "type": "string",
          "description": "The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "queueCount": {
          "type": "integer",
          "description": "The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "stackType": {
          "type": "string",
          "description": "The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6 or IPV4_ONLY. If not specified, IPV4_ONLY will be used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnetwork": {
          "type": "string",
          "description": "The name or self_link of the subnetwork to attach this\ninterface to. Either `network` or `subnetwork` must be provided. If network isn't provided\nit will be inferred from the subnetwork. The subnetwork must exist in the same region this\ninstance will be created in. If the network resource is in\n[legacy](https://cloud.google.com/vpc/docs/legacy) mode, do not specify this field. If the\nnetwork is in auto subnet mode, specifying the subnetwork is optional. If the network is\nin custom subnet mode, specifying the subnetwork is required.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnetworkProject": {
          "type": "string",
          "description": "The project in which the subnetwork belongs.\nIf the `subnetwork` is a self_link, this field is ignored in favor of the project\ndefined in the subnetwork self_link. If the `subnetwork` is a name and this\nfield is not provided, the provider project is used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "ipv6AccessType",
            "name",
            "network",
            "networkIp",
            "stackType",
            "subnetwork",
            "subnetworkProject"
          ]
        }
      }
    },
    "gcp:compute/InstanceNetworkInterfaceAccessConfig:InstanceNetworkInterfaceAccessConfig": {
      "properties": {
        "natIp": {
          "type": "string",
          "description": "The IP address that will be 1:1 mapped to the instance's\nnetwork ip. If not given, one will be generated.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkTier": {
          "type": "string",
          "description": "The service-level to be provided for IPv6 traffic when the\nsubnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publicPtrDomainName": {
          "type": "string",
          "description": "The domain name to be used when creating DNSv6\nrecords for the external IPv6 ranges..\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "natIp",
            "networkTier"
          ]
        }
      }
    },
    "gcp:compute/InstanceNetworkInterfaceAliasIpRange:InstanceNetworkInterfaceAliasIpRange": {
      "properties": {
        "ipCidrRange": {
          "type": "string",
          "description": "The IP CIDR range represented by this alias IP range. This IP CIDR range\nmust belong to the specified subnetwork and cannot contain IP addresses reserved by\nsystem or used by other network interfaces. This range may be a single IP address\n(e.g. 10.2.3.4), a netmask (e.g. /24) or a CIDR format string (e.g. 10.1.2.0/24).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnetworkRangeName": {
          "type": "string",
          "description": "The subnetwork secondary range name specifying\nthe secondary range from which to allocate the IP CIDR range for this alias IP\nrange. If left unspecified, the primary range of the subnetwork will be used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "ipCidrRange"
      ]
    },
    "gcp:compute/InstanceNetworkInterfaceIpv6AccessConfig:InstanceNetworkInterfaceIpv6AccessConfig": {
      "properties": {
        "externalIpv6": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "externalIpv6PrefixLength": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkTier": {
          "type": "string",
          "description": "The service-level to be provided for IPv6 traffic when the\nsubnet has an external subnet. Only PREMIUM or STANDARD tier is valid for IPv6.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publicPtrDomainName": {
          "type": "string",
          "description": "The domain name to be used when creating DNSv6\nrecords for the external IPv6 ranges..\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "networkTier"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "externalIpv6",
            "externalIpv6PrefixLength",
            "networkTier"
          ]
        }
      }
    },
    "gcp:compute/InstanceNetworkPerformanceConfig:InstanceNetworkPerformanceConfig": {
      "properties": {
        "totalEgressBandwidthTier": {
          "type": "string",
          "description": "The egress bandwidth tier to enable.\nPossible values: TIER_1, DEFAULT\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "totalEgressBandwidthTier"
      ]
    },
    "gcp:compute/InstanceReservationAffinity:InstanceReservationAffinity": {
      "properties": {
        "specificReservation": {
          "$ref": "#/types/gcp:compute/InstanceReservationAffinitySpecificReservation:InstanceReservationAffinitySpecificReservation",
          "description": "Specifies the label selector for the reservation to use..\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "description": "The type of reservation from which this instance can consume resources.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "type"
      ]
    },
    "gcp:compute/InstanceReservationAffinitySpecificReservation:InstanceReservationAffinitySpecificReservation": {
      "properties": {
        "key": {
          "type": "string",
          "description": "Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Corresponds to the label values of a reservation resource.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "key",
        "values"
      ]
    },
    "gcp:compute/InstanceScheduling:InstanceScheduling": {
      "properties": {
        "automaticRestart": {
          "type": "boolean",
          "description": "Specifies if the instance should be\nrestarted if it was terminated by Compute Engine (not a user).\nDefaults to true.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "instanceTerminationAction": {
          "type": "string",
          "description": "Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "minNodeCpus": {
          "type": "integer",
          "description": "The minimum number of virtual CPUs this instance will consume when running on a sole-tenant node.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nodeAffinities": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceSchedulingNodeAffinity:InstanceSchedulingNodeAffinity"
          },
          "description": "Specifies node affinities or anti-affinities\nto determine which sole-tenant nodes your instances and managed instance\ngroups will use as host systems. Read more on sole-tenant node creation\n[here](https://cloud.google.com/compute/docs/nodes/create-nodes).\nStructure documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "onHostMaintenance": {
          "type": "string",
          "description": "Describes maintenance behavior for the\ninstance. Can be MIGRATE or TERMINATE, for more info, read\n[here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "preemptible": {
          "type": "boolean",
          "description": "Specifies if the instance is preemptible.\nIf this field is set to true, then `automatic_restart` must be\nset to false.  Defaults to false.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "provisioningModel": {
          "type": "string",
          "description": "Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`,\n`preemptible` should be `true` and `auto_restart` should be\n`false`. For more info about\n`SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "onHostMaintenance",
            "provisioningModel"
          ]
        }
      }
    },
    "gcp:compute/InstanceSchedulingNodeAffinity:InstanceSchedulingNodeAffinity": {
      "properties": {
        "key": {
          "type": "string",
          "description": "Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "operator": {
          "type": "string",
          "description": "The operator. Can be `IN` for node-affinities\nor `NOT_IN` for anti-affinities.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Corresponds to the label values of a reservation resource.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "key",
        "operator",
        "values"
      ]
    },
    "gcp:compute/InstanceScratchDisk:InstanceScratchDisk": {
      "properties": {
        "interface": {
          "type": "string",
          "description": "The disk interface to use for attaching this disk; either SCSI or NVME.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "interface"
      ]
    },
    "gcp:compute/InstanceServiceAccount:InstanceServiceAccount": {
      "properties": {
        "email": {
          "type": "string",
          "description": "The service account e-mail address. If not given, the\ndefault Google Compute Engine service account is used.\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "scopes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of service scopes. Both OAuth2 URLs and gcloud\nshort names are supported. To allow full access to all Cloud APIs, use the\n`cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "scopes"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "email",
            "scopes"
          ]
        }
      }
    },
    "gcp:compute/InstanceShieldedInstanceConfig:InstanceShieldedInstanceConfig": {
      "properties": {
        "enableIntegrityMonitoring": {
          "type": "boolean",
          "description": "-- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "enableSecureBoot": {
          "type": "boolean",
          "description": "-- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "enableVtpm": {
          "type": "boolean",
          "description": "-- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.\n**Note**: `allow_stopping_for_update` must be set to true or your instance must have a `desired_status` of `TERMINATED` in order to update this field.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object"
    },
    "gcp:compute/InstanceTemplateAdvancedMachineFeatures:InstanceTemplateAdvancedMachineFeatures": {
      "properties": {
        "enableNestedVirtualization": {
          "type": "boolean",
          "description": "Defines whether the instance should have nested virtualization enabled. Defaults to false.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "threadsPerCore": {
          "type": "integer",
          "description": "The number of threads per physical core. To disable [simultaneous multithreading (SMT)](https://cloud.google.com/compute/docs/instances/disabling-smt) set this to 1.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "visibleCoreCount": {
          "type": "integer",
          "description": ") The number of physical cores to expose to an instance. [visible cores info (VC)](https://cloud.google.com/compute/docs/instances/customize-visible-cores).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object"
    },
    "gcp:compute/InstanceTemplateConfidentialInstanceConfig:InstanceTemplateConfidentialInstanceConfig": {
      "properties": {
        "enableConfidentialCompute": {
          "type": "boolean",
          "description": "Defines whether the instance should have confidential compute enabled. `on_host_maintenance` has to be set to TERMINATE or this will fail to create the VM.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "enableConfidentialCompute"
      ]
    },
    "gcp:compute/InstanceTemplateDisk:InstanceTemplateDisk": {
      "properties": {
        "autoDelete": {
          "type": "boolean",
          "description": "Whether or not the disk should be auto-deleted.\nThis defaults to true.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "boot": {
          "type": "boolean",
          "description": "Indicates that this is a boot disk.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "deviceName": {
          "type": "string",
          "description": "A unique device name that is reflected into the\n/dev/  tree of a Linux operating system running within the instance. If not\nspecified, the server chooses a default device name to apply to this disk.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "diskEncryptionKey": {
          "$ref": "#/types/gcp:compute/InstanceTemplateDiskDiskEncryptionKey:InstanceTemplateDiskDiskEncryptionKey",
          "description": "Encrypts or decrypts a disk using a customer-supplied encryption key.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "diskName": {
          "type": "string",
          "description": "Name of the disk. When not provided, this defaults\nto the name of the instance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "diskSizeGb": {
          "type": "integer",
          "description": "The size of the image in gigabytes. If not\nspecified, it will inherit the size of its base image. For SCRATCH disks,\nthe size must be exactly 375GB.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "diskType": {
          "type": "string",
          "description": "The GCE disk type. Such as `\"pd-ssd\"`, `\"local-ssd\"`,\n`\"pd-balanced\"` or `\"pd-standard\"`.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "interface": {
          "type": "string",
          "description": "Specifies the disk interface to use for attaching this disk,\nwhich is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI\nand the request will fail if you attempt to attach a persistent disk in any other format\nthan SCSI. Local SSDs can use either NVME or SCSI.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A set of ket/value label pairs to assign to disk created from\nthis template\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "mode": {
          "type": "string",
          "description": "The mode in which to attach this disk, either READ_WRITE\nor READ_ONLY. If you are attaching or creating a boot disk, this must\nread-write mode.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "resourcePolicies": {
          "type": "string",
          "description": "-- A list (short name or id) of resource policies to attach to this disk for automatic snapshot creations. Currently a max of 1 resource policy is supported.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "source": {
          "type": "string",
          "description": "The name (**not self_link**)\nof the disk (such as those managed by `gcp.compute.Disk`) to attach.\n\u003e **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "sourceImage": {
          "type": "string",
          "description": "The image from which to\ninitialize this disk. This can be one of: the image's `self_link`,\n`projects/{project}/global/images/{image}`,\n`projects/{project}/global/images/family/{family}`, `global/images/{image}`,\n`global/images/family/{family}`, `family/{family}`, `{project}/{family}`,\n`{project}/{image}`, `{family}`, or `{image}`.\n\u003e **Note:** Either `source` or `source_image` is **required** in a disk block unless the disk type is `local-ssd`. Check the API [docs](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates/insert) for details.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "description": "The type of reservation from which this instance can consume resources.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "boot",
            "deviceName",
            "diskSizeGb",
            "diskType",
            "interface",
            "mode",
            "sourceImage",
            "type"
          ]
        }
      }
    },
    "gcp:compute/InstanceTemplateDiskDiskEncryptionKey:InstanceTemplateDiskDiskEncryptionKey": {
      "properties": {
        "kmsKeySelfLink": {
          "type": "string",
          "description": "The self link of the encryption key that is stored in Google Cloud KMS\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "kmsKeySelfLink"
      ]
    },
    "gcp:compute/InstanceTemplateGuestAccelerator:InstanceTemplateGuestAccelerator": {
      "properties": {
        "count": {
          "type": "integer",
          "description": "The number of the guest accelerator cards exposed to this instance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "description": "The type of reservation from which this instance can consume resources.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "count",
        "type"
      ]
    },
    "gcp:compute/InstanceTemplateNetworkInterface:InstanceTemplateNetworkInterface": {
      "properties": {
        "accessConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceTemplateNetworkInterfaceAccessConfig:InstanceTemplateNetworkInterfaceAccessConfig"
          },
          "description": "Access configurations, i.e. IPs via which this\ninstance can be accessed via the Internet. Omit to ensure that the instance\nis not accessible from the Internet (this means that ssh provisioners will\nnot work unless you can send traffic to the instance's\nnetwork (e.g. via tunnel or because it is running on another cloud instance\non that network). This block can be repeated multiple times. Structure documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "aliasIpRanges": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceTemplateNetworkInterfaceAliasIpRange:InstanceTemplateNetworkInterfaceAliasIpRange"
          },
          "description": "An\narray of alias IP ranges for this network interface. Can only be specified for network\ninterfaces on subnet-mode networks. Structure documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "ipv6AccessConfigs": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceTemplateNetworkInterfaceIpv6AccessConfig:InstanceTemplateNetworkInterfaceIpv6AccessConfig"
          },
          "description": "An array of IPv6 access configurations for this interface.\nCurrently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig\nspecified, then this instance will have no external IPv6 Internet access. Structure documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "ipv6AccessType": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "name": {
          "type": "string",
          "description": "The name of the instance template. If you leave\nthis blank, the provider will auto-generate a unique name.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "network": {
          "type": "string",
          "description": "The name or self_link of the network to attach this interface to.\nUse `network` attribute for Legacy or Auto subnetted networks and\n`subnetwork` for custom subnetted networks.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "networkIp": {
          "type": "string",
          "description": "The private IP address to assign to the instance. If\nempty, the address will be automatically assigned.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "nicType": {
          "type": "string",
          "description": "The type of vNIC to be used on this interface. Possible values: GVNIC, VIRTIO_NET.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "queueCount": {
          "type": "integer",
          "description": "The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It will be empty if not specified.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "stackType": {
          "type": "string",
          "description": "The stack type for this network interface to identify whether the IPv6 feature is enabled or not. Values are IPV4_IPV6 or IPV4_ONLY. If not specified, IPV4_ONLY will be used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "subnetwork": {
          "type": "string",
          "description": "the name of the subnetwork to attach this interface\nto. The subnetwork must exist in the same `region` this instance will be\ncreated in. Either `network` or `subnetwork` must be provided.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "subnetworkProject": {
          "type": "string",
          "description": "The ID of the project in which the subnetwork belongs.\nIf it is not provided, the provider project is used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "ipv6AccessType",
            "name",
            "network",
            "stackType",
            "subnetwork",
            "subnetworkProject"
          ]
        }
      }
    },
    "gcp:compute/InstanceTemplateNetworkInterfaceAccessConfig:InstanceTemplateNetworkInterfaceAccessConfig": {
      "properties": {
        "natIp": {
          "type": "string",
          "description": "The IP address that will be 1:1 mapped to the instance's\nnetwork ip. If not given, one will be generated.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "networkTier": {
          "type": "string",
          "description": "The service-level to be provided for IPv6 traffic when the\nsubnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "publicPtrDomainName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "natIp",
            "networkTier",
            "publicPtrDomainName"
          ]
        }
      }
    },
    "gcp:compute/InstanceTemplateNetworkInterfaceAliasIpRange:InstanceTemplateNetworkInterfaceAliasIpRange": {
      "properties": {
        "ipCidrRange": {
          "type": "string",
          "description": "The IP CIDR range represented by this alias IP range. This IP CIDR range\nmust belong to the specified subnetwork and cannot contain IP addresses reserved by\nsystem or used by other network interfaces. At the time of writing only a\nnetmask (e.g. /24) may be supplied, with a CIDR format resulting in an API\nerror.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "subnetworkRangeName": {
          "type": "string",
          "description": "The subnetwork secondary range name specifying\nthe secondary range from which to allocate the IP CIDR range for this alias IP\nrange. If left unspecified, the primary range of the subnetwork will be used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "ipCidrRange"
      ]
    },
    "gcp:compute/InstanceTemplateNetworkInterfaceIpv6AccessConfig:InstanceTemplateNetworkInterfaceIpv6AccessConfig": {
      "properties": {
        "externalIpv6": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "externalIpv6PrefixLength": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "networkTier": {
          "type": "string",
          "description": "The service-level to be provided for IPv6 traffic when the\nsubnet has an external subnet. Only PREMIUM and STANDARD tier is valid for IPv6.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "publicPtrDomainName": {
          "type": "string",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "networkTier"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "externalIpv6",
            "externalIpv6PrefixLength",
            "networkTier",
            "publicPtrDomainName"
          ]
        }
      }
    },
    "gcp:compute/InstanceTemplateNetworkPerformanceConfig:InstanceTemplateNetworkPerformanceConfig": {
      "properties": {
        "totalEgressBandwidthTier": {
          "type": "string",
          "description": "The egress bandwidth tier to enable. Possible values: TIER_1, DEFAULT\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "totalEgressBandwidthTier"
      ]
    },
    "gcp:compute/InstanceTemplateReservationAffinity:InstanceTemplateReservationAffinity": {
      "properties": {
        "specificReservation": {
          "$ref": "#/types/gcp:compute/InstanceTemplateReservationAffinitySpecificReservation:InstanceTemplateReservationAffinitySpecificReservation",
          "description": "Specifies the label selector for the reservation to use..\nStructure is documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "type": {
          "type": "string",
          "description": "The type of reservation from which this instance can consume resources.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "type"
      ]
    },
    "gcp:compute/InstanceTemplateReservationAffinitySpecificReservation:InstanceTemplateReservationAffinitySpecificReservation": {
      "properties": {
        "key": {
          "type": "string",
          "description": "Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Corresponds to the label values of a reservation resource.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "key",
        "values"
      ]
    },
    "gcp:compute/InstanceTemplateScheduling:InstanceTemplateScheduling": {
      "properties": {
        "automaticRestart": {
          "type": "boolean",
          "description": "Specifies whether the instance should be\nautomatically restarted if it is terminated by Compute Engine (not\nterminated by a user). This defaults to true.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "instanceTerminationAction": {
          "type": "string",
          "description": "Describe the type of termination action for `SPOT` VM. Can be `STOP` or `DELETE`.  Read more on [here](https://cloud.google.com/compute/docs/instances/create-use-spot)\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "minNodeCpus": {
          "type": "integer",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "nodeAffinities": {
          "type": "array",
          "items": {
            "$ref": "#/types/gcp:compute/InstanceTemplateSchedulingNodeAffinity:InstanceTemplateSchedulingNodeAffinity"
          },
          "description": "Specifies node affinities or anti-affinities\nto determine which sole-tenant nodes your instances and managed instance\ngroups will use as host systems. Read more on sole-tenant node creation\n[here](https://cloud.google.com/compute/docs/nodes/create-nodes).\nStructure documented below.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "onHostMaintenance": {
          "type": "string",
          "description": "Defines the maintenance behavior for this\ninstance.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "preemptible": {
          "type": "boolean",
          "description": "Allows instance to be preempted. This defaults to\nfalse. Read more on this\n[here](https://cloud.google.com/compute/docs/instances/preemptible).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "provisioningModel": {
          "type": "string",
          "description": "Describe the type of preemptible VM. This field accepts the value `STANDARD` or `SPOT`. If the value is `STANDARD`, there will be no discount. If this   is set to `SPOT`, \n`preemptible` should be `true` and `auto_restart` should be\n`false`. For more info about\n`SPOT`, read [here](https://cloud.google.com/compute/docs/instances/spot)\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "onHostMaintenance",
            "provisioningModel"
          ]
        }
      }
    },
    "gcp:compute/InstanceTemplateSchedulingNodeAffinity:InstanceTemplateSchedulingNodeAffinity": {
      "properties": {
        "key": {
          "type": "string",
          "description": "Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify compute.googleapis.com/reservation-name as the key and specify the name of your reservation as the only value.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "operator": {
          "type": "string",
          "description": "The operator. Can be `IN` for node-affinities\nor `NOT_IN` for anti-affinities.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Corresponds to the label values of a reservation resource.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          }
        }
      },
      "type": "object",
      "required": [
        "key",
        "operator",
        "values"
      ]
    },
    "gcp:compute/InstanceTemplateServiceAccount:InstanceTemplateServiceAccount": {
      "properties": {
        "email": {
          "type": "string",
          "description": "The service account e-mail address. If not given, the\ndefault Google Compute Engine service account is used.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "scopes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of service scopes. Both OAuth2 URLs and gcloud\nshort names are supported. To allow full access to all Cloud APIs, use the\n`cloud-platform` scope. See a complete list of scopes [here](https://cloud.google.com/sdk/gcloud/reference/alpha/compute/instances/set-scopes#--scopes).\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object",
      "required": [
        "scopes"
      ],
      "language": {
        "nodejs": {
          "requiredOutputs": [
            "email",
            "scopes"
          ]
        }
      }
    },
    "gcp:compute/InstanceTemplateShieldedInstanceConfig:InstanceTemplateShieldedInstanceConfig": {
      "properties": {
        "enableIntegrityMonitoring": {
          "type": "boolean",
          "description": "-- Compare the most recent boot measurements to the integrity policy baseline and return a pair of pass/fail results depending on whether they match or not. Defaults to true.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "enableSecureBoot": {
          "type": "boolean",
          "description": "-- Verify the digital signature of all boot components, and halt the boot process if signature verification fails. Defaults to false.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        },
        "enableVtpm": {
          "type": "boolean",
          "description": "-- Use a virtualized trusted platform module, which is a specialized computer chip you can use to encrypt objects like keys and certificates. Defaults to true.\n",
          "language": {
            "python": {
              "mapCase": false
            }
          },
          "willReplaceOnChanges": true
        }
      },
      "type": "object"
    }
  }
}
